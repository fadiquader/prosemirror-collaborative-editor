export function isVisible(item: any, snapshot?: any): boolean;
/**
 * Either a node if type is YXmlElement or an Array of text nodes if YXmlText
 * @typedef {Map<Y.AbstractType, PModel.Node | Array<PModel.Node>>} ProsemirrorMapping
 */
/**
 * The unique prosemirror plugin key for prosemirrorPlugin.
 *
 * @public
 */
export const ySyncPluginKey: PluginKey<any, any>;
export function ySyncPlugin(yXmlFragment: any, { colors, colorMapping, permanentUserData }?: YSyncOpts): any;
export function getRelativeSelection(pmbinding: any, state: any): {
    anchor: any;
    head: any;
};
/**
 * Binding for prosemirror.
 *
 * @protected
 */
export class ProsemirrorBinding {
    /**
     * @param {Y.XmlFragment} yXmlFragment The bind source
     * @param {any} prosemirrorView The target binding
     */
    constructor(yXmlFragment: any, prosemirrorView: any);
    type: any;
    prosemirrorView: any;
    mux: any;
    /**
     * @type {ProsemirrorMapping}
     */
    mapping: ProsemirrorMapping;
    _observeFunction: any;
    /**
     * @type {Y.Doc}
     */
    doc: Y.Doc;
    /**
     * current selection as relative positions in the Yjs model
     */
    beforeTransactionSelection: {
        anchor: any;
        head: any;
    };
    renderSnapshot(snapshot: any, prevSnapshot: any): void;
    unrenderSnapshot(): void;
    _forceRerender(): void;
    /**
     * @param {Y.Snapshot} snapshot
     * @param {Y.Snapshot} prevSnapshot
     * @param {Object} pluginState
     */
    _renderSnapshot(snapshot: any, prevSnapshot: any, pluginState: any): void;
    /**
     * @param {Array<Y.YEvent>} events
     * @param {Y.Transaction} transaction
     */
    _typeChanged(events: any[], transaction: any): void;
    _prosemirrorChanged(doc: any): void;
    destroy(): void;
}
export function createNodeIfNotExists(el: any, schema: PModel.Schema<any, any>, mapping: Map<any, PModel.Node<any> | PModel.Node<any>[]>, snapshot?: any, prevSnapshot?: any, computeYChange?: (arg0: "removed" | "added", arg1: any) => any): PModel.Node<any>;
export function createNodeFromYElement(el: any, schema: any, mapping: Map<any, PModel.Node<any> | PModel.Node<any>[]>, snapshot?: any, prevSnapshot?: any, computeYChange?: (arg0: "removed" | "added", arg1: any) => any): PModel.Node<any>;
export function createTextNodesFromYText(text: any, schema: any, mapping: Map<any, PModel.Node<any> | PModel.Node<any>[]>, snapshot?: any, prevSnapshot?: any, computeYChange?: (arg0: "removed" | "added", arg1: any) => any): PModel.Node<any>[];
export function createTypeFromTextNodes(nodes: any[], mapping: Map<any, PModel.Node<any> | PModel.Node<any>[]>): any;
export function createTypeFromElementNode(node: any, mapping: Map<any, PModel.Node<any> | PModel.Node<any>[]>): any;
export function createTypeFromTextOrElementNode(node: PModel.Node<any> | PModel.Node<any>[], mapping: Map<any, PModel.Node<any> | PModel.Node<any>[]>): any;
export function normalizePNodeContent(pnode: any): (PModel.Node<any> | PModel.Node<any>[])[];
/**
 * Either a node if type is YXmlElement or an Array of text nodes if YXmlText
 */
export type ProsemirrorMapping = Map<any, PModel.Node<any> | PModel.Node<any>[]>;
export type ColorDef = {
    light: string;
    dark: string;
};
export type YSyncOpts = {
    colors?: ColorDef[];
    colorMapping?: Map<string, ColorDef>;
    permanentUserData?: any;
};
export type NormalizedPNodeContent = (PModel.Node<any> | PModel.Node<any>[])[];
import { PluginKey } from "prosemirror-state";
import * as PModel from "prosemirror-model";
