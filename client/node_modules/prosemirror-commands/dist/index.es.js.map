{"version":3,"file":"index.es.js","sources":["../src/commands.js"],"sourcesContent":["import {joinPoint, canJoin, findWrapping, liftTarget, canSplit, ReplaceAroundStep} from \"prosemirror-transform\"\nimport {Slice, Fragment} from \"prosemirror-model\"\nimport {Selection, TextSelection, NodeSelection, AllSelection} from \"prosemirror-state\"\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Delete the selection, if there is one.\nexport function deleteSelection(state, dispatch) {\n  if (state.selection.empty) return false\n  if (dispatch) dispatch(state.tr.deleteSelection().scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// If the selection is empty and at the start of a textblock, try to\n// reduce the distance between that block and the one before it—if\n// there's a block directly before it that can be joined, join them.\n// If not, try to move the selected block closer to the next one in\n// the document structure by lifting it out of its parent or moving it\n// into a parent of the previous block. Will use the view for accurate\n// (bidi-aware) start-of-textblock detection if given.\nexport function joinBackward(state, dispatch, view) {\n  let {$cursor} = state.selection\n  if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state)\n                        : $cursor.parentOffset > 0))\n    return false\n\n  let $cut = findCutBefore($cursor)\n\n  // If there is no node before this, try to lift\n  if (!$cut) {\n    let range = $cursor.blockRange(), target = range && liftTarget(range)\n    if (target == null) return false\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n    return true\n  }\n\n  let before = $cut.nodeBefore\n  // Apply the joining algorithm\n  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))\n    return true\n\n  // If the node below has no content and the node above is\n  // selectable, delete the node below and select the one above.\n  if ($cursor.parent.content.size == 0 &&\n      (textblockAt(before, \"end\") || NodeSelection.isSelectable(before))) {\n    if (dispatch) {\n      let tr = state.tr.deleteRange($cursor.before(), $cursor.after())\n      tr.setSelection(textblockAt(before, \"end\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1)\n                      : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize))\n      dispatch(tr.scrollIntoView())\n    }\n    return true\n  }\n\n  // If the node before is an atom, delete it\n  if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView())\n    return true\n  }\n\n  return false\n}\n\nfunction textblockAt(node, side) {\n  for (; node; node = (side == \"start\" ? node.firstChild : node.lastChild))\n    if (node.isTextblock) return true\n  return false\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// When the selection is empty and at the start of a textblock, select\n// the node before that textblock, if possible. This is intended to be\n// bound to keys like backspace, after\n// [`joinBackward`](#commands.joinBackward) or other deleting\n// commands, as a fall-back behavior when the schema doesn't allow\n// deletion at the selected point.\nexport function selectNodeBackward(state, dispatch, view) {\n  let {$head, empty} = state.selection, $cut = $head\n  if (!empty) return false\n\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0) return false\n    $cut = findCutBefore($head)\n  }\n  let node = $cut && $cut.nodeBefore\n  if (!node || !NodeSelection.isSelectable(node)) return false\n  if (dispatch)\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView())\n  return true\n}\n\nfunction findCutBefore($pos) {\n  if (!$pos.parent.type.spec.isolating) for (let i = $pos.depth - 1; i >= 0; i--) {\n    if ($pos.index(i) > 0) return $pos.doc.resolve($pos.before(i + 1))\n    if ($pos.node(i).type.spec.isolating) break\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// If the selection is empty and the cursor is at the end of a\n// textblock, try to reduce or remove the boundary between that block\n// and the one after it, either by joining them or by moving the other\n// block closer to this one in the tree structure. Will use the view\n// for accurate start-of-textblock detection if given.\nexport function joinForward(state, dispatch, view) {\n  let {$cursor} = state.selection\n  if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state)\n                        : $cursor.parentOffset < $cursor.parent.content.size))\n    return false\n\n  let $cut = findCutAfter($cursor)\n\n  // If there is no node after this, there's nothing to do\n  if (!$cut) return false\n\n  let after = $cut.nodeAfter\n  // Try the joining algorithm\n  if (deleteBarrier(state, $cut, dispatch)) return true\n\n  // If the node above has no content and the node below is\n  // selectable, delete the node above and select the one below.\n  if ($cursor.parent.content.size == 0 &&\n      (textblockAt(after, \"start\") || NodeSelection.isSelectable(after))) {\n    if (dispatch) {\n      let tr = state.tr.deleteRange($cursor.before(), $cursor.after())\n      tr.setSelection(textblockAt(after, \"start\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1)\n                      : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)))\n      dispatch(tr.scrollIntoView())\n    }\n    return true\n  }\n\n  // If the next node is an atom, delete it\n  if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView())\n    return true\n  }\n\n  return false\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// When the selection is empty and at the end of a textblock, select\n// the node coming after that textblock, if possible. This is intended\n// to be bound to keys like delete, after\n// [`joinForward`](#commands.joinForward) and similar deleting\n// commands, to provide a fall-back behavior when the schema doesn't\n// allow deletion at the selected point.\nexport function selectNodeForward(state, dispatch, view) {\n  let {$head, empty} = state.selection, $cut = $head\n  if (!empty) return false\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size)\n      return false\n    $cut = findCutAfter($head)\n  }\n  let node = $cut && $cut.nodeAfter\n  if (!node || !NodeSelection.isSelectable(node)) return false\n  if (dispatch)\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView())\n  return true\n}\n\nfunction findCutAfter($pos) {\n  if (!$pos.parent.type.spec.isolating) for (let i = $pos.depth - 1; i >= 0; i--) {\n    let parent = $pos.node(i)\n    if ($pos.index(i) + 1 < parent.childCount) return $pos.doc.resolve($pos.after(i + 1))\n    if (parent.type.spec.isolating) break\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Join the selected block or, if there is a text selection, the\n// closest ancestor block of the selection that can be joined, with\n// the sibling above it.\nexport function joinUp(state, dispatch) {\n  let sel = state.selection, nodeSel = sel instanceof NodeSelection, point\n  if (nodeSel) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.from)) return false\n    point = sel.from\n  } else {\n    point = joinPoint(state.doc, sel.from, -1)\n    if (point == null) return false\n  }\n  if (dispatch) {\n    let tr = state.tr.join(point)\n    if (nodeSel) tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Join the selected block, or the closest ancestor of the selection\n// that can be joined, with the sibling after it.\nexport function joinDown(state, dispatch) {\n  let sel = state.selection, point\n  if (sel instanceof NodeSelection) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.to)) return false\n    point = sel.to\n  } else {\n    point = joinPoint(state.doc, sel.to, 1)\n    if (point == null) return false\n  }\n  if (dispatch)\n    dispatch(state.tr.join(point).scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Lift the selected block, or the closest ancestor block of the\n// selection that can be lifted, out of its parent node.\nexport function lift(state, dispatch) {\n  let {$from, $to} = state.selection\n  let range = $from.blockRange($to), target = range && liftTarget(range)\n  if (target == null) return false\n  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If the selection is in a node whose type has a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, replace the\n// selection with a newline character.\nexport function newlineInCode(state, dispatch) {\n  let {$head, $anchor} = state.selection\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false\n  if (dispatch) dispatch(state.tr.insertText(\"\\n\").scrollIntoView())\n  return true\n}\n\nfunction defaultBlockAt(match) {\n  for (let i = 0; i < match.edgeCount; i++) {\n    let {type} = match.edge(i)\n    if (type.isTextblock && !type.hasRequiredAttrs()) return type\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// When the selection is in a node with a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, create a\n// default block after the code block, and move the cursor there.\nexport function exitCode(state, dispatch) {\n  let {$head, $anchor} = state.selection\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false\n  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after))\n  if (!above.canReplaceWith(after, after, type)) return false\n  if (dispatch) {\n    let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill())\n    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If a block node is selected, create an empty paragraph before (if\n// it is its parent's first child) or after it.\nexport function createParagraphNear(state, dispatch) {\n  let {$from, $to} = state.selection\n  if ($from.parent.inlineContent || $to.parent.inlineContent) return false\n  let type = defaultBlockAt($from.parent.contentMatchAt($to.indexAfter()))\n  if (!type || !type.isTextblock) return false\n  if (dispatch) {\n    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos\n    let tr = state.tr.insert(side, type.createAndFill())\n    tr.setSelection(TextSelection.create(tr.doc, side + 1))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If the cursor is in an empty textblock that can be lifted, lift the\n// block.\nexport function liftEmptyBlock(state, dispatch) {\n  let {$cursor} = state.selection\n  if (!$cursor || $cursor.parent.content.size) return false\n  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n    let before = $cursor.before()\n    if (canSplit(state.doc, before)) {\n      if (dispatch) dispatch(state.tr.split(before).scrollIntoView())\n      return true\n    }\n  }\n  let range = $cursor.blockRange(), target = range && liftTarget(range)\n  if (target == null) return false\n  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Split the parent block of the selection. If the selection is a text\n// selection, also delete its content.\nexport function splitBlock(state, dispatch) {\n  let {$from, $to} = state.selection\n  if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {\n    if (!$from.parentOffset || !canSplit(state.doc, $from.pos)) return false\n    if (dispatch) dispatch(state.tr.split($from.pos).scrollIntoView())\n    return true\n  }\n\n  if (!$from.parent.isBlock) return false\n\n  if (dispatch) {\n    let atEnd = $to.parentOffset == $to.parent.content.size\n    let tr = state.tr\n    if (state.selection instanceof TextSelection) tr.deleteSelection()\n    let deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)))\n    let types = atEnd && deflt ? [{type: deflt}] : null\n    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types)\n    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{type: deflt}])) {\n      types = [{type: deflt}]\n      can = true\n    }\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types)\n      if (!atEnd && !$from.parentOffset && $from.parent.type != deflt &&\n          $from.node(-1).canReplace($from.index(-1), $from.indexAfter(-1), Fragment.from(deflt.create(), $from.parent)))\n        tr.setNodeMarkup(tr.mapping.map($from.before()), deflt)\n    }\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Acts like [`splitBlock`](#commands.splitBlock), but without\n// resetting the set of active marks at the cursor.\nexport function splitBlockKeepMarks(state, dispatch) {\n  return splitBlock(state, dispatch && (tr => {\n    let marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks())\n    if (marks) tr.ensureMarks(marks)\n    dispatch(tr)\n  }))\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Move the selection to the node wrapping the current selection, if\n// any. (Will not select the document node.)\nexport function selectParentNode(state, dispatch) {\n  let {$from, to} = state.selection, pos\n  let same = $from.sharedDepth(to)\n  if (same == 0) return false\n  pos = $from.before(same)\n  if (dispatch) dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)))\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Select the whole document.\nexport function selectAll(state, dispatch) {\n  if (dispatch) dispatch(state.tr.setSelection(new AllSelection(state.doc)))\n  return true\n}\n\nfunction joinMaybeClear(state, $pos, dispatch) {\n  let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index()\n  if (!before || !after || !before.type.compatibleContent(after.type)) return false\n  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n    if (dispatch) dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView())\n    return true\n  }\n  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))\n    return false\n  if (dispatch)\n    dispatch(state.tr\n             .clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount))\n             .join($pos.pos)\n             .scrollIntoView())\n  return true\n}\n\nfunction deleteBarrier(state, $cut, dispatch) {\n  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match\n  if (before.type.spec.isolating || after.type.spec.isolating) return false\n  if (joinMaybeClear(state, $cut, dispatch)) return true\n\n  if ($cut.parent.canReplace($cut.index(), $cut.index() + 1) &&\n      (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) &&\n      match.matchType(conn[0] || after.type).validEnd) {\n    if (dispatch) {\n      let end = $cut.pos + after.nodeSize, wrap = Fragment.empty\n      for (let i = conn.length - 1; i >= 0; i--)\n        wrap = Fragment.from(conn[i].create(null, wrap))\n      wrap = Fragment.from(before.copy(wrap))\n      let tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap, 1, 0), conn.length, true))\n      let joinAt = end + 2 * conn.length\n      if (canJoin(tr.doc, joinAt)) tr.join(joinAt)\n      dispatch(tr.scrollIntoView())\n    }\n    return true\n  }\n\n  let selAfter = Selection.findFrom($cut, 1)\n  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range)\n  if (target != null && target >= $cut.depth) {\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n    return true\n  }\n\n  return false\n}\n\n// Parameterized commands\n\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Wrap the selection in a node of the given type with the given\n// attributes.\nexport function wrapIn(nodeType, attrs) {\n  return function(state, dispatch) {\n    let {$from, $to} = state.selection\n    let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs)\n    if (!wrapping) return false\n    if (dispatch) dispatch(state.tr.wrap(range, wrapping).scrollIntoView())\n    return true\n  }\n}\n\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command that tries to set the selected textblocks to the\n// given node type with the given attributes.\nexport function setBlockType(nodeType, attrs) {\n  return function(state, dispatch) {\n    let {from, to} = state.selection\n    let applicable = false\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (applicable) return false\n      if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) return\n      if (node.type == nodeType) {\n        applicable = true\n      } else {\n        let $pos = state.doc.resolve(pos), index = $pos.index()\n        applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType)\n      }\n    })\n    if (!applicable) return false\n    if (dispatch) dispatch(state.tr.setBlockType(from, to, nodeType, attrs).scrollIntoView())\n    return true\n  }\n}\n\nfunction markApplies(doc, ranges, type) {\n  for (let i = 0; i < ranges.length; i++) {\n    let {$from, $to} = ranges[i]\n    let can = $from.depth == 0 ? doc.type.allowsMarkType(type) : false\n    doc.nodesBetween($from.pos, $to.pos, node => {\n      if (can) return false\n      can = node.inlineContent && node.type.allowsMarkType(type)\n    })\n    if (can) return true\n  }\n  return false\n}\n\n// :: (MarkType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Create a command function that toggles the given mark with the\n// given attributes. Will return `false` when the current selection\n// doesn't support that mark. This will remove the mark if any marks\n// of that type exist in the selection, or add it otherwise. If the\n// selection is empty, this applies to the [stored\n// marks](#state.EditorState.storedMarks) instead of a range of the\n// document.\nexport function toggleMark(markType, attrs) {\n  return function(state, dispatch) {\n    let {empty, $cursor, ranges} = state.selection\n    if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType)) return false\n    if (dispatch) {\n      if ($cursor) {\n        if (markType.isInSet(state.storedMarks || $cursor.marks()))\n          dispatch(state.tr.removeStoredMark(markType))\n        else\n          dispatch(state.tr.addStoredMark(markType.create(attrs)))\n      } else {\n        let has = false, tr = state.tr\n        for (let i = 0; !has && i < ranges.length; i++) {\n          let {$from, $to} = ranges[i]\n          has = state.doc.rangeHasMark($from.pos, $to.pos, markType)\n        }\n        for (let i = 0; i < ranges.length; i++) {\n          let {$from, $to} = ranges[i]\n          if (has) tr.removeMark($from.pos, $to.pos, markType)\n          else tr.addMark($from.pos, $to.pos, markType.create(attrs))\n        }\n        dispatch(tr.scrollIntoView())\n      }\n    }\n    return true\n  }\n}\n\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n  return tr => {\n    if (!tr.isGeneric) return dispatch(tr)\n\n    let ranges = []\n    for (let i = 0; i < tr.mapping.maps.length; i++) {\n      let map = tr.mapping.maps[i]\n      for (let j = 0; j < ranges.length; j++)\n        ranges[j] = map.map(ranges[j])\n      map.forEach((_s, _e, from, to) => ranges.push(from, to))\n    }\n\n    // Figure out which joinable points exist inside those ranges,\n    // by checking all node boundaries in their parent nodes.\n    let joinable = []\n    for (let i = 0; i < ranges.length; i += 2) {\n      let from = ranges[i], to = ranges[i + 1]\n      let $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth)\n      for (let index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {\n        let after = parent.maybeChild(index)\n        if (!after) break\n        if (index && joinable.indexOf(pos) == -1) {\n          let before = parent.child(index - 1)\n          if (before.type == after.type && isJoinable(before, after))\n            joinable.push(pos)\n        }\n        pos += after.nodeSize\n      }\n    }\n    // Join the joinable points\n    joinable.sort((a, b) => a - b)\n    for (let i = joinable.length - 1; i >= 0; i--) {\n      if (canJoin(tr.doc, joinable[i])) tr.join(joinable[i])\n    }\n    dispatch(tr)\n  }\n}\n\n// :: ((state: EditorState, ?(tr: Transaction)) → bool, union<(before: Node, after: Node) → bool, [string]>) → (state: EditorState, ?(tr: Transaction)) → bool\n// Wrap a command so that, when it produces a transform that causes\n// two joinable nodes to end up next to each other, those are joined.\n// Nodes are considered joinable when they are of the same type and\n// when the `isJoinable` predicate returns true for them or, if an\n// array of strings was passed, if their node type name is in that\n// array.\nexport function autoJoin(command, isJoinable) {\n  if (Array.isArray(isJoinable)) {\n    let types = isJoinable\n    isJoinable = node => types.indexOf(node.type.name) > -1\n  }\n  return (state, dispatch) => command(state, dispatch && wrapDispatchForJoin(dispatch, isJoinable))\n}\n\n// :: (...[(EditorState, ?(tr: Transaction), ?EditorView) → bool]) → (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// Combine a number of command functions into a single function (which\n// calls them one by one until one returns true).\nexport function chainCommands(...commands) {\n  return function(state, dispatch, view) {\n    for (let i = 0; i < commands.length; i++)\n      if (commands[i](state, dispatch, view)) return true\n    return false\n  }\n}\n\nlet backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward)\nlet del = chainCommands(deleteSelection, joinForward, selectNodeForward)\n\n// :: Object\n// A basic keymap containing bindings not specific to any schema.\n// Binds the following keys (when multiple commands are listed, they\n// are chained with [`chainCommands`](#commands.chainCommands)):\n//\n// * **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n// * **Mod-Enter** to `exitCode`\n// * **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n// * **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-a** to `selectAll`\nexport let pcBaseKeymap = {\n  \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n  \"Mod-Enter\": exitCode,\n  \"Backspace\": backspace,\n  \"Mod-Backspace\": backspace,\n  \"Delete\": del,\n  \"Mod-Delete\": del,\n  \"Mod-a\": selectAll\n}\n\n// :: Object\n// A copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n// **Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n// **Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\n// Ctrl-Delete.\nexport let macBaseKeymap = {\n  \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n  \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n  \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n  \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"]\n}\nfor (let key in pcBaseKeymap) macBaseKeymap[key] = pcBaseKeymap[key]\n\n// declare global: os, navigator\nconst mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform)\n          : typeof os != \"undefined\" ? os.platform() == \"darwin\" : false\n\n// :: Object\n// Depending on the detected platform, this will hold\n// [`pcBasekeymap`](#commands.pcBaseKeymap) or\n// [`macBaseKeymap`](#commands.macBaseKeymap).\nexport let baseKeymap = mac ? macBaseKeymap : pcBaseKeymap\n"],"names":["let","i","$from","$to","const"],"mappings":"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"}