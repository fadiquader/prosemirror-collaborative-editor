{"version":3,"file":"index.es.js","sources":["../src/inputrules.js","../src/rules.js","../src/rulebuilders.js"],"sourcesContent":["import {Plugin} from \"prosemirror-state\"\n\n// ::- Input rules are regular expressions describing a piece of text\n// that, when typed, causes something to happen. This might be\n// changing two dashes into an emdash, wrapping a paragraph starting\n// with `\"> \"` into a blockquote, or something entirely different.\nexport class InputRule {\n  // :: (RegExp, union<string, (state: EditorState, match: [string], start: number, end: number) → ?Transaction>)\n  // Create an input rule. The rule applies when the user typed\n  // something and the text directly in front of the cursor matches\n  // `match`, which should probably end with `$`.\n  //\n  // The `handler` can be a string, in which case the matched text, or\n  // the first matched group in the regexp, is replaced by that\n  // string.\n  //\n  // Or a it can be a function, which will be called with the match\n  // array produced by\n  // [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),\n  // as well as the start and end of the matched range, and which can\n  // return a [transaction](#state.Transaction) that describes the\n  // rule's effect, or null to indicate the input was not handled.\n  constructor(match, handler) {\n    this.match = match\n    this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler\n  }\n}\n\nfunction stringHandler(string) {\n  return function(state, match, start, end) {\n    let insert = string\n    if (match[1]) {\n      let offset = match[0].lastIndexOf(match[1])\n      insert += match[0].slice(offset + match[1].length)\n      start += offset\n      let cutOff = start - end\n      if (cutOff > 0) {\n        insert = match[0].slice(offset - cutOff, offset) + insert\n        start = end\n      }\n    }\n    return state.tr.insertText(insert, start, end)\n  }\n}\n\nconst MAX_MATCH = 500\n\n// :: (config: {rules: [InputRule]}) → Plugin\n// Create an input rules plugin. When enabled, it will cause text\n// input that matches any of the given rules to trigger the rule's\n// action.\nexport function inputRules({rules}) {\n  let plugin = new Plugin({\n    state: {\n      init() { return null },\n      apply(tr, prev) {\n        let stored = tr.getMeta(this)\n        if (stored) return stored\n        return tr.selectionSet || tr.docChanged ? null : prev\n      }\n    },\n\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run(view, from, to, text, rules, plugin)\n      },\n      handleDOMEvents: {\n        compositionend: (view) => {\n          setTimeout(() => {\n            let {$cursor} = view.state.selection\n            if ($cursor) run(view, $cursor.pos, $cursor.pos, \"\", rules, plugin)\n          })\n        }\n      }\n    },\n\n    isInputRules: true\n  })\n  return plugin\n}\n\nfunction run(view, from, to, text, rules, plugin) {\n  if (view.composing) return false\n  let state = view.state, $from = state.doc.resolve(from)\n  if ($from.parent.type.spec.code) return false\n  let textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset,\n                                            null, \"\\ufffc\") + text\n  for (let i = 0; i < rules.length; i++) {\n    let match = rules[i].match.exec(textBefore)\n    let tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to)\n    if (!tr) continue\n    view.dispatch(tr.setMeta(plugin, {transform: tr, from, to, text}))\n    return true\n  }\n  return false\n}\n\n// :: (EditorState, ?(Transaction)) → bool\n// This is a command that will undo an input rule, if applying such a\n// rule was the last thing that the user did.\nexport function undoInputRule(state, dispatch) {\n  let plugins = state.plugins\n  for (let i = 0; i < plugins.length; i++) {\n    let plugin = plugins[i], undoable\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        let tr = state.tr, toUndo = undoable.transform\n        for (let j = toUndo.steps.length - 1; j >= 0; j--)\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]))\n        let marks = tr.doc.resolve(undoable.from).marks()\n        dispatch(tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks)))\n      }\n      return true\n    }\n  }\n  return false\n}\n","import {InputRule} from \"./inputrules\"\n\n// :: InputRule Converts double dashes to an emdash.\nexport const emDash = new InputRule(/--$/, \"—\")\n// :: InputRule Converts three dots to an ellipsis character.\nexport const ellipsis = new InputRule(/\\.\\.\\.$/, \"…\")\n// :: InputRule “Smart” opening double quotes.\nexport const openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(\")$/, \"“\")\n// :: InputRule “Smart” closing double quotes.\nexport const closeDoubleQuote = new InputRule(/\"$/, \"”\")\n// :: InputRule “Smart” opening single quotes.\nexport const openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(')$/, \"‘\")\n// :: InputRule “Smart” closing single quotes.\nexport const closeSingleQuote = new InputRule(/'$/, \"’\")\n\n// :: [InputRule] Smart-quote related input rules.\nexport const smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote]\n","import {InputRule} from \"./inputrules\"\nimport {findWrapping, canJoin} from \"prosemirror-transform\"\n\n// :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>, ?([string], Node) → bool) → InputRule\n// Build an input rule for automatically wrapping a textblock when a\n// given string is typed. The `regexp` argument is\n// directly passed through to the `InputRule` constructor. You'll\n// probably want the regexp to start with `^`, so that the pattern can\n// only occur at the start of a textblock.\n//\n// `nodeType` is the type of node to wrap in. If it needs attributes,\n// you can either pass them directly, or pass a function that will\n// compute them from the regular expression match.\n//\n// By default, if there's a node with the same type above the newly\n// wrapped node, the rule will try to [join](#transform.Transform.join) those\n// two nodes. You can pass a join predicate, which takes a regular\n// expression match and the node before the wrapped node, and can\n// return a boolean to indicate whether a join should happen.\nexport function wrappingInputRule(regexp, nodeType, getAttrs, joinPredicate) {\n  return new InputRule(regexp, (state, match, start, end) => {\n    let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs\n    let tr = state.tr.delete(start, end)\n    let $start = tr.doc.resolve(start), range = $start.blockRange(), wrapping = range && findWrapping(range, nodeType, attrs)\n    if (!wrapping) return null\n    tr.wrap(range, wrapping)\n    let before = tr.doc.resolve(start - 1).nodeBefore\n    if (before && before.type == nodeType && canJoin(tr.doc, start - 1) &&\n        (!joinPredicate || joinPredicate(match, before)))\n      tr.join(start - 1)\n    return tr\n  })\n}\n\n// :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>) → InputRule\n// Build an input rule that changes the type of a textblock when the\n// matched text is typed into it. You'll usually want to start your\n// regexp with `^` to that it is only matched at the start of a\n// textblock. The optional `getAttrs` parameter can be used to compute\n// the new node's attributes, and works the same as in the\n// `wrappingInputRule` function.\nexport function textblockTypeInputRule(regexp, nodeType, getAttrs) {\n  return new InputRule(regexp, (state, match, start, end) => {\n    let $start = state.doc.resolve(start)\n    let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs\n    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType)) return null\n    return state.tr\n      .delete(start, end)\n      .setBlockType(start, start, nodeType, attrs)\n  })\n}\n"],"names":["let","const"],"mappings":"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"}