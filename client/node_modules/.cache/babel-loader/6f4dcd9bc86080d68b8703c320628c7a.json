{"ast":null,"code":"import RopeSequence from 'rope-sequence';\nimport { Mapping } from 'prosemirror-transform';\nimport { PluginKey, Plugin } from 'prosemirror-state'; // ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' — a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n// Used to schedule history compression\n\nvar max_empty_items = 500;\n\nvar Branch = function Branch(items, eventCount) {\n  this.items = items;\n  this.eventCount = eventCount;\n}; // : (EditorState, bool) → ?{transform: Transform, selection: ?SelectionBookmark, remaining: Branch}\n// Pop the latest event off the branch's history and apply it\n// to a document transform.\n\n\nBranch.prototype.popEvent = function popEvent(state, preserveItems) {\n  var this$1 = this;\n\n  if (this.eventCount == 0) {\n    return null;\n  }\n\n  var end = this.items.length;\n\n  for (;; end--) {\n    var next = this.items.get(end - 1);\n\n    if (next.selection) {\n      --end;\n      break;\n    }\n  }\n\n  var remap, mapFrom;\n\n  if (preserveItems) {\n    remap = this.remapping(end, this.items.length);\n    mapFrom = remap.maps.length;\n  }\n\n  var transform = state.tr;\n  var selection, remaining;\n  var addAfter = [],\n      addBefore = [];\n  this.items.forEach(function (item, i) {\n    if (!item.step) {\n      if (!remap) {\n        remap = this$1.remapping(end, i + 1);\n        mapFrom = remap.maps.length;\n      }\n\n      mapFrom--;\n      addBefore.push(item);\n      return;\n    }\n\n    if (remap) {\n      addBefore.push(new Item(item.map));\n      var step = item.step.map(remap.slice(mapFrom)),\n          map;\n\n      if (step && transform.maybeStep(step).doc) {\n        map = transform.mapping.maps[transform.mapping.maps.length - 1];\n        addAfter.push(new Item(map, null, null, addAfter.length + addBefore.length));\n      }\n\n      mapFrom--;\n\n      if (map) {\n        remap.appendMap(map, mapFrom);\n      }\n    } else {\n      transform.maybeStep(item.step);\n    }\n\n    if (item.selection) {\n      selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n      remaining = new Branch(this$1.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this$1.eventCount - 1);\n      return false;\n    }\n  }, this.items.length, 0);\n  return {\n    remaining: remaining,\n    transform: transform,\n    selection: selection\n  };\n}; // : (Transform, ?SelectionBookmark, Object) → Branch\n// Create a new branch with the given transform added.\n\n\nBranch.prototype.addTransform = function addTransform(transform, selection, histOptions, preserveItems) {\n  var newItems = [],\n      eventCount = this.eventCount;\n  var oldItems = this.items,\n      lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n\n  for (var i = 0; i < transform.steps.length; i++) {\n    var step = transform.steps[i].invert(transform.docs[i]);\n    var item = new Item(transform.mapping.maps[i], step, selection),\n        merged = void 0;\n\n    if (merged = lastItem && lastItem.merge(item)) {\n      item = merged;\n\n      if (i) {\n        newItems.pop();\n      } else {\n        oldItems = oldItems.slice(0, oldItems.length - 1);\n      }\n    }\n\n    newItems.push(item);\n\n    if (selection) {\n      eventCount++;\n      selection = null;\n    }\n\n    if (!preserveItems) {\n      lastItem = item;\n    }\n  }\n\n  var overflow = eventCount - histOptions.depth;\n\n  if (overflow > DEPTH_OVERFLOW) {\n    oldItems = cutOffEvents(oldItems, overflow);\n    eventCount -= overflow;\n  }\n\n  return new Branch(oldItems.append(newItems), eventCount);\n};\n\nBranch.prototype.remapping = function remapping(from, to) {\n  var maps = new Mapping();\n  this.items.forEach(function (item, i) {\n    var mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from ? maps.maps.length - item.mirrorOffset : null;\n    maps.appendMap(item.map, mirrorPos);\n  }, from, to);\n  return maps;\n};\n\nBranch.prototype.addMaps = function addMaps(array) {\n  if (this.eventCount == 0) {\n    return this;\n  }\n\n  return new Branch(this.items.append(array.map(function (map) {\n    return new Item(map);\n  })), this.eventCount);\n}; // : (Transform, number)\n// When the collab module receives remote changes, the history has\n// to know about those, so that it can adjust the steps that were\n// rebased on top of the remote changes, and include the position\n// maps for the remote changes in its array of items.\n\n\nBranch.prototype.rebased = function rebased(rebasedTransform, rebasedCount) {\n  if (!this.eventCount) {\n    return this;\n  }\n\n  var rebasedItems = [],\n      start = Math.max(0, this.items.length - rebasedCount);\n  var mapping = rebasedTransform.mapping;\n  var newUntil = rebasedTransform.steps.length;\n  var eventCount = this.eventCount;\n  this.items.forEach(function (item) {\n    if (item.selection) {\n      eventCount--;\n    }\n  }, start);\n  var iRebased = rebasedCount;\n  this.items.forEach(function (item) {\n    var pos = mapping.getMirror(--iRebased);\n\n    if (pos == null) {\n      return;\n    }\n\n    newUntil = Math.min(newUntil, pos);\n    var map = mapping.maps[pos];\n\n    if (item.step) {\n      var step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n      var selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n\n      if (selection) {\n        eventCount++;\n      }\n\n      rebasedItems.push(new Item(map, step, selection));\n    } else {\n      rebasedItems.push(new Item(map));\n    }\n  }, start);\n  var newMaps = [];\n\n  for (var i = rebasedCount; i < newUntil; i++) {\n    newMaps.push(new Item(mapping.maps[i]));\n  }\n\n  var items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n  var branch = new Branch(items, eventCount);\n\n  if (branch.emptyItemCount() > max_empty_items) {\n    branch = branch.compress(this.items.length - rebasedItems.length);\n  }\n\n  return branch;\n};\n\nBranch.prototype.emptyItemCount = function emptyItemCount() {\n  var count = 0;\n  this.items.forEach(function (item) {\n    if (!item.step) {\n      count++;\n    }\n  });\n  return count;\n}; // Compressing a branch means rewriting it to push the air (map-only\n// items) out. During collaboration, these naturally accumulate\n// because each remote change adds one. The `upto` argument is used\n// to ensure that only the items below a given level are compressed,\n// because `rebased` relies on a clean, untouched set of items in\n// order to associate old items with rebased steps.\n\n\nBranch.prototype.compress = function compress(upto) {\n  if (upto === void 0) upto = this.items.length;\n  var remap = this.remapping(0, upto),\n      mapFrom = remap.maps.length;\n  var items = [],\n      events = 0;\n  this.items.forEach(function (item, i) {\n    if (i >= upto) {\n      items.push(item);\n\n      if (item.selection) {\n        events++;\n      }\n    } else if (item.step) {\n      var step = item.step.map(remap.slice(mapFrom)),\n          map = step && step.getMap();\n      mapFrom--;\n\n      if (map) {\n        remap.appendMap(map, mapFrom);\n      }\n\n      if (step) {\n        var selection = item.selection && item.selection.map(remap.slice(mapFrom));\n\n        if (selection) {\n          events++;\n        }\n\n        var newItem = new Item(map.invert(), step, selection),\n            merged,\n            last = items.length - 1;\n\n        if (merged = items.length && items[last].merge(newItem)) {\n          items[last] = merged;\n        } else {\n          items.push(newItem);\n        }\n      }\n    } else if (item.map) {\n      mapFrom--;\n    }\n  }, this.items.length, 0);\n  return new Branch(RopeSequence.from(items.reverse()), events);\n};\n\nBranch.empty = new Branch(RopeSequence.empty, 0);\n\nfunction cutOffEvents(items, n) {\n  var cutPoint;\n  items.forEach(function (item, i) {\n    if (item.selection && n-- == 0) {\n      cutPoint = i;\n      return false;\n    }\n  });\n  return items.slice(cutPoint);\n}\n\nvar Item = function Item(map, step, selection, mirrorOffset) {\n  // The (forward) step map for this item.\n  this.map = map; // The inverted step\n\n  this.step = step; // If this is non-null, this item is the start of a group, and\n  // this selection is the starting selection for the group (the one\n  // that was active before the first step was applied)\n\n  this.selection = selection; // If this item is the inverse of a previous mapping on the stack,\n  // this points at the inverse's offset\n\n  this.mirrorOffset = mirrorOffset;\n};\n\nItem.prototype.merge = function merge(other) {\n  if (this.step && other.step && !other.selection) {\n    var step = other.step.merge(this.step);\n\n    if (step) {\n      return new Item(step.getMap().invert(), step, this.selection);\n    }\n  }\n}; // The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\n\n\nvar HistoryState = function HistoryState(done, undone, prevRanges, prevTime) {\n  this.done = done;\n  this.undone = undone;\n  this.prevRanges = prevRanges;\n  this.prevTime = prevTime;\n};\n\nvar DEPTH_OVERFLOW = 20; // : (HistoryState, EditorState, Transaction, Object)\n// Record a transformation in undo history.\n\nfunction applyTransaction(history, state, tr, options) {\n  var historyTr = tr.getMeta(historyKey),\n      rebased;\n\n  if (historyTr) {\n    return historyTr.historyState;\n  }\n\n  if (tr.getMeta(closeHistoryKey)) {\n    history = new HistoryState(history.done, history.undone, null, 0);\n  }\n\n  var appended = tr.getMeta(\"appendedTransaction\");\n\n  if (tr.steps.length == 0) {\n    return history;\n  } else if (appended && appended.getMeta(historyKey)) {\n    if (appended.getMeta(historyKey).redo) {\n      return new HistoryState(history.done.addTransform(tr, null, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime);\n    } else {\n      return new HistoryState(history.done, history.undone.addTransform(tr, null, options, mustPreserveItems(state)), null, history.prevTime);\n    }\n  } else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n    // Group transforms that occur in quick succession into one event.\n    var newGroup = history.prevTime == 0 || !appended && (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges));\n    var prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);\n    return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : null, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time);\n  } else if (rebased = tr.getMeta(\"rebased\")) {\n    // Used by the collab module to tell the history that some of its\n    // content has been rebased.\n    return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime);\n  } else {\n    return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime);\n  }\n}\n\nfunction isAdjacentTo(transform, prevRanges) {\n  if (!prevRanges) {\n    return false;\n  }\n\n  if (!transform.docChanged) {\n    return true;\n  }\n\n  var adjacent = false;\n  transform.mapping.maps[0].forEach(function (start, end) {\n    for (var i = 0; i < prevRanges.length; i += 2) {\n      if (start <= prevRanges[i + 1] && end >= prevRanges[i]) {\n        adjacent = true;\n      }\n    }\n  });\n  return adjacent;\n}\n\nfunction rangesFor(map) {\n  var result = [];\n  map.forEach(function (_from, _to, from, to) {\n    return result.push(from, to);\n  });\n  return result;\n}\n\nfunction mapRanges(ranges, mapping) {\n  if (!ranges) {\n    return null;\n  }\n\n  var result = [];\n\n  for (var i = 0; i < ranges.length; i += 2) {\n    var from = mapping.map(ranges[i], 1),\n        to = mapping.map(ranges[i + 1], -1);\n\n    if (from <= to) {\n      result.push(from, to);\n    }\n  }\n\n  return result;\n} // : (HistoryState, EditorState, (tr: Transaction), bool)\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\n\n\nfunction histTransaction(history, state, dispatch, redo) {\n  var preserveItems = mustPreserveItems(state),\n      histOptions = historyKey.get(state).spec.config;\n  var pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n\n  if (!pop) {\n    return;\n  }\n\n  var selection = pop.selection.resolve(pop.transform.doc);\n  var added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n  var newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0);\n  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, {\n    redo: redo,\n    historyState: newHist\n  }).scrollIntoView());\n}\n\nvar cachedPreserveItems = false,\n    cachedPreserveItemsPlugins = null; // Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\n\nfunction mustPreserveItems(state) {\n  var plugins = state.plugins;\n\n  if (cachedPreserveItemsPlugins != plugins) {\n    cachedPreserveItems = false;\n    cachedPreserveItemsPlugins = plugins;\n\n    for (var i = 0; i < plugins.length; i++) {\n      if (plugins[i].spec.historyPreserveItems) {\n        cachedPreserveItems = true;\n        break;\n      }\n    }\n  }\n\n  return cachedPreserveItems;\n} // :: (Transaction) → Transaction\n// Set a flag on the given transaction that will prevent further steps\n// from being appended to an existing history event (so that they\n// require a separate undo command to undo).\n\n\nfunction closeHistory(tr) {\n  return tr.setMeta(closeHistoryKey, true);\n}\n\nvar historyKey = new PluginKey(\"history\");\nvar closeHistoryKey = new PluginKey(\"closeHistory\"); // :: (?Object) → Plugin\n// Returns a plugin that enables the undo history for an editor. The\n// plugin will track undo and redo stacks, which can be used with the\n// [`undo`](#history.undo) and [`redo`](#history.redo) commands.\n//\n// You can set an `\"addToHistory\"` [metadata\n// property](#state.Transaction.setMeta) of `false` on a transaction\n// to prevent it from being rolled back by undo.\n//\n//   config::-\n//   Supports the following configuration options:\n//\n//     depth:: ?number\n//     The amount of history events that are collected before the\n//     oldest events are discarded. Defaults to 100.\n//\n//     newGroupDelay:: ?number\n//     The delay between changes after which a new group should be\n//     started. Defaults to 500 (milliseconds). Note that when changes\n//     aren't adjacent, a new group is always started.\n\nfunction history(config) {\n  config = {\n    depth: config && config.depth || 100,\n    newGroupDelay: config && config.newGroupDelay || 500\n  };\n  return new Plugin({\n    key: historyKey,\n    state: {\n      init: function init() {\n        return new HistoryState(Branch.empty, Branch.empty, null, 0);\n      },\n      apply: function apply(tr, hist, state) {\n        return applyTransaction(hist, state, tr, config);\n      }\n    },\n    config: config\n  });\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// A command function that undoes the last change, if any.\n\n\nfunction undo(state, dispatch) {\n  var hist = historyKey.getState(state);\n\n  if (!hist || hist.done.eventCount == 0) {\n    return false;\n  }\n\n  if (dispatch) {\n    histTransaction(hist, state, dispatch, false);\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// A command function that redoes the last undone change, if any.\n\n\nfunction redo(state, dispatch) {\n  var hist = historyKey.getState(state);\n\n  if (!hist || hist.undone.eventCount == 0) {\n    return false;\n  }\n\n  if (dispatch) {\n    histTransaction(hist, state, dispatch, true);\n  }\n\n  return true;\n} // :: (EditorState) → number\n// The amount of undoable events available in a given state.\n\n\nfunction undoDepth(state) {\n  var hist = historyKey.getState(state);\n  return hist ? hist.done.eventCount : 0;\n} // :: (EditorState) → number\n// The amount of redoable events available in a given editor state.\n\n\nfunction redoDepth(state) {\n  var hist = historyKey.getState(state);\n  return hist ? hist.undone.eventCount : 0;\n}\n\nexport { HistoryState, closeHistory, history, redo, redoDepth, undo, undoDepth };","map":{"version":3,"sources":["../src/history.js"],"names":["const","let","this"],"mappings":"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","sourcesContent":["import RopeSequence from \"rope-sequence\"\nimport {Mapping} from \"prosemirror-transform\"\nimport {Plugin, PluginKey} from \"prosemirror-state\"\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' — a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n\n// Used to schedule history compression\nconst max_empty_items = 500\n\nclass Branch {\n  constructor(items, eventCount) {\n    this.items = items\n    this.eventCount = eventCount\n  }\n\n  // : (EditorState, bool) → ?{transform: Transform, selection: ?SelectionBookmark, remaining: Branch}\n  // Pop the latest event off the branch's history and apply it\n  // to a document transform.\n  popEvent(state, preserveItems) {\n    if (this.eventCount == 0) return null\n\n    let end = this.items.length\n    for (;; end--) {\n      let next = this.items.get(end - 1)\n      if (next.selection) { --end; break }\n    }\n\n    let remap, mapFrom\n    if (preserveItems) {\n      remap = this.remapping(end, this.items.length)\n      mapFrom = remap.maps.length\n    }\n    let transform = state.tr\n    let selection, remaining\n    let addAfter = [], addBefore = []\n\n    this.items.forEach((item, i) => {\n      if (!item.step) {\n        if (!remap) {\n          remap = this.remapping(end, i + 1)\n          mapFrom = remap.maps.length\n        }\n        mapFrom--\n        addBefore.push(item)\n        return\n      }\n\n      if (remap) {\n        addBefore.push(new Item(item.map))\n        let step = item.step.map(remap.slice(mapFrom)), map\n\n        if (step && transform.maybeStep(step).doc) {\n          map = transform.mapping.maps[transform.mapping.maps.length - 1]\n          addAfter.push(new Item(map, null, null, addAfter.length + addBefore.length))\n        }\n        mapFrom--\n        if (map) remap.appendMap(map, mapFrom)\n      } else {\n        transform.maybeStep(item.step)\n      }\n\n      if (item.selection) {\n        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection\n        remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1)\n        return false\n      }\n    }, this.items.length, 0)\n\n    return {remaining, transform, selection}\n  }\n\n  // : (Transform, ?SelectionBookmark, Object) → Branch\n  // Create a new branch with the given transform added.\n  addTransform(transform, selection, histOptions, preserveItems) {\n    let newItems = [], eventCount = this.eventCount\n    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null\n\n    for (let i = 0; i < transform.steps.length; i++) {\n      let step = transform.steps[i].invert(transform.docs[i])\n      let item = new Item(transform.mapping.maps[i], step, selection), merged\n      if (merged = lastItem && lastItem.merge(item)) {\n        item = merged\n        if (i) newItems.pop()\n        else oldItems = oldItems.slice(0, oldItems.length - 1)\n      }\n      newItems.push(item)\n      if (selection) {\n        eventCount++\n        selection = null\n      }\n      if (!preserveItems) lastItem = item\n    }\n    let overflow = eventCount - histOptions.depth\n    if (overflow > DEPTH_OVERFLOW) {\n      oldItems = cutOffEvents(oldItems, overflow)\n      eventCount -= overflow\n    }\n    return new Branch(oldItems.append(newItems), eventCount)\n  }\n\n  remapping(from, to) {\n    let maps = new Mapping\n    this.items.forEach((item, i) => {\n      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from\n          ? maps.maps.length - item.mirrorOffset : null\n      maps.appendMap(item.map, mirrorPos)\n    }, from, to)\n    return maps\n  }\n\n  addMaps(array) {\n    if (this.eventCount == 0) return this\n    return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount)\n  }\n\n  // : (Transform, number)\n  // When the collab module receives remote changes, the history has\n  // to know about those, so that it can adjust the steps that were\n  // rebased on top of the remote changes, and include the position\n  // maps for the remote changes in its array of items.\n  rebased(rebasedTransform, rebasedCount) {\n    if (!this.eventCount) return this\n\n    let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount)\n\n    let mapping = rebasedTransform.mapping\n    let newUntil = rebasedTransform.steps.length\n    let eventCount = this.eventCount\n    this.items.forEach(item => { if (item.selection) eventCount-- }, start)\n\n    let iRebased = rebasedCount\n    this.items.forEach(item => {\n      let pos = mapping.getMirror(--iRebased)\n      if (pos == null) return\n      newUntil = Math.min(newUntil, pos)\n      let map = mapping.maps[pos]\n      if (item.step) {\n        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos])\n        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos))\n        if (selection) eventCount++\n        rebasedItems.push(new Item(map, step, selection))\n      } else {\n        rebasedItems.push(new Item(map))\n      }\n    }, start)\n\n    let newMaps = []\n    for (let i = rebasedCount; i < newUntil; i++)\n      newMaps.push(new Item(mapping.maps[i]))\n    let items = this.items.slice(0, start).append(newMaps).append(rebasedItems)\n    let branch = new Branch(items, eventCount)\n\n    if (branch.emptyItemCount() > max_empty_items)\n      branch = branch.compress(this.items.length - rebasedItems.length)\n    return branch\n  }\n\n  emptyItemCount() {\n    let count = 0\n    this.items.forEach(item => { if (!item.step) count++ })\n    return count\n  }\n\n  // Compressing a branch means rewriting it to push the air (map-only\n  // items) out. During collaboration, these naturally accumulate\n  // because each remote change adds one. The `upto` argument is used\n  // to ensure that only the items below a given level are compressed,\n  // because `rebased` relies on a clean, untouched set of items in\n  // order to associate old items with rebased steps.\n  compress(upto = this.items.length) {\n    let remap = this.remapping(0, upto), mapFrom = remap.maps.length\n    let items = [], events = 0\n    this.items.forEach((item, i) => {\n      if (i >= upto) {\n        items.push(item)\n        if (item.selection) events++\n      } else if (item.step) {\n        let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap()\n        mapFrom--\n        if (map) remap.appendMap(map, mapFrom)\n        if (step) {\n          let selection = item.selection && item.selection.map(remap.slice(mapFrom))\n          if (selection) events++\n          let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1\n          if (merged = items.length && items[last].merge(newItem))\n            items[last] = merged\n          else\n            items.push(newItem)\n        }\n      } else if (item.map) {\n        mapFrom--\n      }\n    }, this.items.length, 0)\n    return new Branch(RopeSequence.from(items.reverse()), events)\n  }\n}\n\nBranch.empty = new Branch(RopeSequence.empty, 0)\n\nfunction cutOffEvents(items, n) {\n  let cutPoint\n  items.forEach((item, i) => {\n    if (item.selection && (n-- == 0)) {\n      cutPoint = i\n      return false\n    }\n  })\n  return items.slice(cutPoint)\n}\n\nclass Item {\n  constructor(map, step, selection, mirrorOffset) {\n    // The (forward) step map for this item.\n    this.map = map\n    // The inverted step\n    this.step = step\n    // If this is non-null, this item is the start of a group, and\n    // this selection is the starting selection for the group (the one\n    // that was active before the first step was applied)\n    this.selection = selection\n    // If this item is the inverse of a previous mapping on the stack,\n    // this points at the inverse's offset\n    this.mirrorOffset = mirrorOffset\n  }\n\n  merge(other) {\n    if (this.step && other.step && !other.selection) {\n      let step = other.step.merge(this.step)\n      if (step) return new Item(step.getMap().invert(), step, this.selection)\n    }\n  }\n}\n\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nexport class HistoryState {\n  constructor(done, undone, prevRanges, prevTime) {\n    this.done = done\n    this.undone = undone\n    this.prevRanges = prevRanges\n    this.prevTime = prevTime\n  }\n}\n\nconst DEPTH_OVERFLOW = 20\n\n// : (HistoryState, EditorState, Transaction, Object)\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n  let historyTr = tr.getMeta(historyKey), rebased\n  if (historyTr) return historyTr.historyState\n\n  if (tr.getMeta(closeHistoryKey)) history = new HistoryState(history.done, history.undone, null, 0)\n\n  let appended = tr.getMeta(\"appendedTransaction\")\n\n  if (tr.steps.length == 0) {\n    return history\n  } else if (appended && appended.getMeta(historyKey)) {\n    if (appended.getMeta(historyKey).redo)\n      return new HistoryState(history.done.addTransform(tr, null, options, mustPreserveItems(state)),\n                              history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime)\n    else\n      return new HistoryState(history.done, history.undone.addTransform(tr, null, options, mustPreserveItems(state)),\n                              null, history.prevTime)\n  } else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n    // Group transforms that occur in quick succession into one event.\n    let newGroup = history.prevTime == 0 || !appended && (history.prevTime < (tr.time || 0) - options.newGroupDelay ||\n                                                          !isAdjacentTo(tr, history.prevRanges))\n    let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1])\n    return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : null,\n                                                      options, mustPreserveItems(state)),\n                            Branch.empty, prevRanges, tr.time)\n  } else if (rebased = tr.getMeta(\"rebased\")) {\n    // Used by the collab module to tell the history that some of its\n    // content has been rebased.\n    return new HistoryState(history.done.rebased(tr, rebased),\n                            history.undone.rebased(tr, rebased),\n                            mapRanges(history.prevRanges, tr.mapping), history.prevTime)\n  } else {\n    return new HistoryState(history.done.addMaps(tr.mapping.maps),\n                            history.undone.addMaps(tr.mapping.maps),\n                            mapRanges(history.prevRanges, tr.mapping), history.prevTime)\n  }\n}\n\nfunction isAdjacentTo(transform, prevRanges) {\n  if (!prevRanges) return false\n  if (!transform.docChanged) return true\n  let adjacent = false\n  transform.mapping.maps[0].forEach((start, end) => {\n    for (let i = 0; i < prevRanges.length; i += 2)\n      if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n        adjacent = true\n  })\n  return adjacent\n}\n\nfunction rangesFor(map) {\n  let result = []\n  map.forEach((_from, _to, from, to) => result.push(from, to))\n  return result\n}\n\nfunction mapRanges(ranges, mapping) {\n  if (!ranges) return null\n  let result = []\n  for (let i = 0; i < ranges.length; i += 2) {\n    let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1)\n    if (from <= to) result.push(from, to)\n  }\n  return result\n}\n\n// : (HistoryState, EditorState, (tr: Transaction), bool)\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, dispatch, redo) {\n  let preserveItems = mustPreserveItems(state), histOptions = historyKey.get(state).spec.config\n  let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems)\n  if (!pop) return\n\n  let selection = pop.selection.resolve(pop.transform.doc)\n  let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(),\n                                                                  histOptions, preserveItems)\n\n  let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0)\n  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, {redo, historyState: newHist}).scrollIntoView())\n}\n\nlet cachedPreserveItems = false, cachedPreserveItemsPlugins = null\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n  let plugins = state.plugins\n  if (cachedPreserveItemsPlugins != plugins) {\n    cachedPreserveItems = false\n    cachedPreserveItemsPlugins = plugins\n    for (let i = 0; i < plugins.length; i++) if (plugins[i].spec.historyPreserveItems) {\n      cachedPreserveItems = true\n      break\n    }\n  }\n  return cachedPreserveItems\n}\n\n// :: (Transaction) → Transaction\n// Set a flag on the given transaction that will prevent further steps\n// from being appended to an existing history event (so that they\n// require a separate undo command to undo).\nexport function closeHistory(tr) {\n  return tr.setMeta(closeHistoryKey, true)\n}\n\nconst historyKey = new PluginKey(\"history\")\nconst closeHistoryKey = new PluginKey(\"closeHistory\")\n\n// :: (?Object) → Plugin\n// Returns a plugin that enables the undo history for an editor. The\n// plugin will track undo and redo stacks, which can be used with the\n// [`undo`](#history.undo) and [`redo`](#history.redo) commands.\n//\n// You can set an `\"addToHistory\"` [metadata\n// property](#state.Transaction.setMeta) of `false` on a transaction\n// to prevent it from being rolled back by undo.\n//\n//   config::-\n//   Supports the following configuration options:\n//\n//     depth:: ?number\n//     The amount of history events that are collected before the\n//     oldest events are discarded. Defaults to 100.\n//\n//     newGroupDelay:: ?number\n//     The delay between changes after which a new group should be\n//     started. Defaults to 500 (milliseconds). Note that when changes\n//     aren't adjacent, a new group is always started.\nexport function history(config) {\n  config = {depth: config && config.depth || 100,\n            newGroupDelay: config && config.newGroupDelay || 500}\n  return new Plugin({\n    key: historyKey,\n\n    state: {\n      init() {\n        return new HistoryState(Branch.empty, Branch.empty, null, 0)\n      },\n      apply(tr, hist, state) {\n        return applyTransaction(hist, state, tr, config)\n      }\n    },\n\n    config\n  })\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// A command function that undoes the last change, if any.\nexport function undo(state, dispatch) {\n  let hist = historyKey.getState(state)\n  if (!hist || hist.done.eventCount == 0) return false\n  if (dispatch) histTransaction(hist, state, dispatch, false)\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// A command function that redoes the last undone change, if any.\nexport function redo(state, dispatch) {\n  let hist = historyKey.getState(state)\n  if (!hist || hist.undone.eventCount == 0) return false\n  if (dispatch) histTransaction(hist, state, dispatch, true)\n  return true\n}\n\n// :: (EditorState) → number\n// The amount of undoable events available in a given state.\nexport function undoDepth(state) {\n  let hist = historyKey.getState(state)\n  return hist ? hist.done.eventCount : 0\n}\n\n// :: (EditorState) → number\n// The amount of redoable events available in a given editor state.\nexport function redoDepth(state) {\n  let hist = historyKey.getState(state)\n  return hist ? hist.undone.eventCount : 0\n}\n"]},"metadata":{},"sourceType":"module"}