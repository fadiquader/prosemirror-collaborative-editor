{"ast":null,"code":"/**\n * @module sync-protocol\n */\nimport * as encoding from 'lib0/encoding.js';\nimport * as decoding from 'lib0/decoding.js';\nimport * as Y from 'yjs';\n/**\n * @typedef {Map<number, number>} StateMap\n */\n\n/**\n * Core Yjs defines three message types:\n * • YjsSyncStep1: Includes the State Set of the sending client. When received, the client should reply with YjsSyncStep2.\n * • YjsSyncStep2: Includes all missing structs and the complete delete set. When received, the the client is assured that\n *   it received all information from the remote client.\n *\n * In a peer-to-peer network, you may want to introduce a SyncDone message type. Both parties should initiate the connection\n * with SyncStep1. When a client received SyncStep2, it should reply with SyncDone. When the local client received both\n * SyncStep2 and SyncDone, it is assured that it is synced to the remote client.\n *\n * In a client-server model, you want to handle this differently: The client should initiate the connection with SyncStep1.\n * When the server receives SyncStep1, it should reply with SyncStep2 immediately followed by SyncStep1. The client replies\n * with SyncStep2 when it receives SyncStep1. Optionally the server may send a SyncDone after it received SyncStep2, so the\n * client knows that the sync is finished.  There are two reasons for this more elaborated sync model: 1. This protocol can\n * easily be implemented on top of http and websockets. 2. The server shoul only reply to requests, and not initiate them.\n * Therefore it is necesarry that the client initiates the sync.\n *\n * Construction of a message:\n * [messageType : varUint, message definition..]\n *\n * Note: A message does not include information about the room name. This must to be handled by the upper layer protocol!\n *\n * stringify[messageType] stringifies a message definition (messageType is already read from the bufffer)\n */\n\nexport const messageYjsSyncStep1 = 0;\nexport const messageYjsSyncStep2 = 1;\nexport const messageYjsUpdate = 2;\n/**\n * Create a sync step 1 message based on the state of the current shared document.\n *\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n */\n\nexport const writeSyncStep1 = (encoder, doc) => {\n  encoding.writeVarUint(encoder, messageYjsSyncStep1);\n  const sv = Y.encodeStateVector(doc);\n  encoding.writeVarUint8Array(encoder, sv);\n};\n/**\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n * @param {Uint8Array} [encodedStateVector]\n */\n\nexport const writeSyncStep2 = (encoder, doc, encodedStateVector) => {\n  encoding.writeVarUint(encoder, messageYjsSyncStep2);\n  encoding.writeVarUint8Array(encoder, Y.encodeStateAsUpdate(doc, encodedStateVector));\n};\n/**\n * Read SyncStep1 message and reply with SyncStep2.\n *\n * @param {decoding.Decoder} decoder The reply to the received message\n * @param {encoding.Encoder} encoder The received message\n * @param {Y.Doc} doc\n */\n\nexport const readSyncStep1 = (decoder, encoder, doc) => writeSyncStep2(encoder, doc, decoding.readVarUint8Array(decoder));\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\n\nexport const readSyncStep2 = (decoder, doc, transactionOrigin) => {\n  Y.applyUpdate(doc, decoding.readVarUint8Array(decoder), transactionOrigin);\n};\n/**\n * @param {encoding.Encoder} encoder\n * @param {Uint8Array} update\n */\n\nexport const writeUpdate = (encoder, update) => {\n  encoding.writeVarUint(encoder, messageYjsUpdate);\n  encoding.writeVarUint8Array(encoder, update);\n};\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\n\nexport const readUpdate = readSyncStep2;\n/**\n * @param {decoding.Decoder} decoder A message received from another client\n * @param {encoding.Encoder} encoder The reply message. Will not be sent if empty.\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\n\nexport const readSyncMessage = (decoder, encoder, doc, transactionOrigin) => {\n  const messageType = decoding.readVarUint(decoder);\n\n  switch (messageType) {\n    case messageYjsSyncStep1:\n      readSyncStep1(decoder, encoder, doc);\n      break;\n\n    case messageYjsSyncStep2:\n      readSyncStep2(decoder, doc, transactionOrigin);\n      break;\n\n    case messageYjsUpdate:\n      readUpdate(decoder, doc, transactionOrigin);\n      break;\n\n    default:\n      throw new Error('Unknown message type');\n  }\n\n  return messageType;\n};","map":{"version":3,"sources":["/Users/meeopp/Development/Others/editor-yjs/client/node_modules/y-websocket/node_modules/y-protocols/sync.js"],"names":["encoding","decoding","Y","messageYjsSyncStep1","messageYjsSyncStep2","messageYjsUpdate","writeSyncStep1","encoder","doc","writeVarUint","sv","encodeStateVector","writeVarUint8Array","writeSyncStep2","encodedStateVector","encodeStateAsUpdate","readSyncStep1","decoder","readVarUint8Array","readSyncStep2","transactionOrigin","applyUpdate","writeUpdate","update","readUpdate","readSyncMessage","messageType","readVarUint","Error"],"mappings":"AAAA;;;AAIA,OAAO,KAAKA,QAAZ,MAA0B,kBAA1B;AACA,OAAO,KAAKC,QAAZ,MAA0B,kBAA1B;AACA,OAAO,KAAKC,CAAZ,MAAmB,KAAnB;AAEA;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,OAAO,MAAMC,mBAAmB,GAAG,CAA5B;AACP,OAAO,MAAMC,mBAAmB,GAAG,CAA5B;AACP,OAAO,MAAMC,gBAAgB,GAAG,CAAzB;AAEP;;;;;;;AAMA,OAAO,MAAMC,cAAc,GAAG,CAACC,OAAD,EAAUC,GAAV,KAAkB;AAC9CR,EAAAA,QAAQ,CAACS,YAAT,CAAsBF,OAAtB,EAA+BJ,mBAA/B;AACA,QAAMO,EAAE,GAAGR,CAAC,CAACS,iBAAF,CAAoBH,GAApB,CAAX;AACAR,EAAAA,QAAQ,CAACY,kBAAT,CAA4BL,OAA5B,EAAqCG,EAArC;AACD,CAJM;AAMP;;;;;;AAKA,OAAO,MAAMG,cAAc,GAAG,CAACN,OAAD,EAAUC,GAAV,EAAeM,kBAAf,KAAsC;AAClEd,EAAAA,QAAQ,CAACS,YAAT,CAAsBF,OAAtB,EAA+BH,mBAA/B;AACAJ,EAAAA,QAAQ,CAACY,kBAAT,CAA4BL,OAA5B,EAAqCL,CAAC,CAACa,mBAAF,CAAsBP,GAAtB,EAA2BM,kBAA3B,CAArC;AACD,CAHM;AAKP;;;;;;;;AAOA,OAAO,MAAME,aAAa,GAAG,CAACC,OAAD,EAAUV,OAAV,EAAmBC,GAAnB,KAC3BK,cAAc,CAACN,OAAD,EAAUC,GAAV,EAAeP,QAAQ,CAACiB,iBAAT,CAA2BD,OAA3B,CAAf,CADT;AAGP;;;;;;;;AAOA,OAAO,MAAME,aAAa,GAAG,CAACF,OAAD,EAAUT,GAAV,EAAeY,iBAAf,KAAqC;AAChElB,EAAAA,CAAC,CAACmB,WAAF,CAAcb,GAAd,EAAmBP,QAAQ,CAACiB,iBAAT,CAA2BD,OAA3B,CAAnB,EAAwDG,iBAAxD;AACD,CAFM;AAIP;;;;;AAIA,OAAO,MAAME,WAAW,GAAG,CAACf,OAAD,EAAUgB,MAAV,KAAqB;AAC9CvB,EAAAA,QAAQ,CAACS,YAAT,CAAsBF,OAAtB,EAA+BF,gBAA/B;AACAL,EAAAA,QAAQ,CAACY,kBAAT,CAA4BL,OAA5B,EAAqCgB,MAArC;AACD,CAHM;AAKP;;;;;;;;AAOA,OAAO,MAAMC,UAAU,GAAGL,aAAnB;AAEP;;;;;;;AAMA,OAAO,MAAMM,eAAe,GAAG,CAACR,OAAD,EAAUV,OAAV,EAAmBC,GAAnB,EAAwBY,iBAAxB,KAA8C;AAC3E,QAAMM,WAAW,GAAGzB,QAAQ,CAAC0B,WAAT,CAAqBV,OAArB,CAApB;;AACA,UAAQS,WAAR;AACE,SAAKvB,mBAAL;AACEa,MAAAA,aAAa,CAACC,OAAD,EAAUV,OAAV,EAAmBC,GAAnB,CAAb;AACA;;AACF,SAAKJ,mBAAL;AACEe,MAAAA,aAAa,CAACF,OAAD,EAAUT,GAAV,EAAeY,iBAAf,CAAb;AACA;;AACF,SAAKf,gBAAL;AACEmB,MAAAA,UAAU,CAACP,OAAD,EAAUT,GAAV,EAAeY,iBAAf,CAAV;AACA;;AACF;AACE,YAAM,IAAIQ,KAAJ,CAAU,sBAAV,CAAN;AAXJ;;AAaA,SAAOF,WAAP;AACD,CAhBM","sourcesContent":["/**\n * @module sync-protocol\n */\n\nimport * as encoding from 'lib0/encoding.js'\nimport * as decoding from 'lib0/decoding.js'\nimport * as Y from 'yjs'\n\n/**\n * @typedef {Map<number, number>} StateMap\n */\n\n/**\n * Core Yjs defines three message types:\n * • YjsSyncStep1: Includes the State Set of the sending client. When received, the client should reply with YjsSyncStep2.\n * • YjsSyncStep2: Includes all missing structs and the complete delete set. When received, the the client is assured that\n *   it received all information from the remote client.\n *\n * In a peer-to-peer network, you may want to introduce a SyncDone message type. Both parties should initiate the connection\n * with SyncStep1. When a client received SyncStep2, it should reply with SyncDone. When the local client received both\n * SyncStep2 and SyncDone, it is assured that it is synced to the remote client.\n *\n * In a client-server model, you want to handle this differently: The client should initiate the connection with SyncStep1.\n * When the server receives SyncStep1, it should reply with SyncStep2 immediately followed by SyncStep1. The client replies\n * with SyncStep2 when it receives SyncStep1. Optionally the server may send a SyncDone after it received SyncStep2, so the\n * client knows that the sync is finished.  There are two reasons for this more elaborated sync model: 1. This protocol can\n * easily be implemented on top of http and websockets. 2. The server shoul only reply to requests, and not initiate them.\n * Therefore it is necesarry that the client initiates the sync.\n *\n * Construction of a message:\n * [messageType : varUint, message definition..]\n *\n * Note: A message does not include information about the room name. This must to be handled by the upper layer protocol!\n *\n * stringify[messageType] stringifies a message definition (messageType is already read from the bufffer)\n */\n\nexport const messageYjsSyncStep1 = 0\nexport const messageYjsSyncStep2 = 1\nexport const messageYjsUpdate = 2\n\n/**\n * Create a sync step 1 message based on the state of the current shared document.\n *\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n */\nexport const writeSyncStep1 = (encoder, doc) => {\n  encoding.writeVarUint(encoder, messageYjsSyncStep1)\n  const sv = Y.encodeStateVector(doc)\n  encoding.writeVarUint8Array(encoder, sv)\n}\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n * @param {Uint8Array} [encodedStateVector]\n */\nexport const writeSyncStep2 = (encoder, doc, encodedStateVector) => {\n  encoding.writeVarUint(encoder, messageYjsSyncStep2)\n  encoding.writeVarUint8Array(encoder, Y.encodeStateAsUpdate(doc, encodedStateVector))\n}\n\n/**\n * Read SyncStep1 message and reply with SyncStep2.\n *\n * @param {decoding.Decoder} decoder The reply to the received message\n * @param {encoding.Encoder} encoder The received message\n * @param {Y.Doc} doc\n */\nexport const readSyncStep1 = (decoder, encoder, doc) =>\n  writeSyncStep2(encoder, doc, decoding.readVarUint8Array(decoder))\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nexport const readSyncStep2 = (decoder, doc, transactionOrigin) => {\n  Y.applyUpdate(doc, decoding.readVarUint8Array(decoder), transactionOrigin)\n}\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Uint8Array} update\n */\nexport const writeUpdate = (encoder, update) => {\n  encoding.writeVarUint(encoder, messageYjsUpdate)\n  encoding.writeVarUint8Array(encoder, update)\n}\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nexport const readUpdate = readSyncStep2\n\n/**\n * @param {decoding.Decoder} decoder A message received from another client\n * @param {encoding.Encoder} encoder The reply message. Will not be sent if empty.\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nexport const readSyncMessage = (decoder, encoder, doc, transactionOrigin) => {\n  const messageType = decoding.readVarUint(decoder)\n  switch (messageType) {\n    case messageYjsSyncStep1:\n      readSyncStep1(decoder, encoder, doc)\n      break\n    case messageYjsSyncStep2:\n      readSyncStep2(decoder, doc, transactionOrigin)\n      break\n    case messageYjsUpdate:\n      readUpdate(decoder, doc, transactionOrigin)\n      break\n    default:\n      throw new Error('Unknown message type')\n  }\n  return messageType\n}\n"]},"metadata":{},"sourceType":"module"}