{"ast":null,"code":"import { keyName, base } from 'w3c-keyname';\nimport { Plugin } from 'prosemirror-state'; // declare global: navigator\n\nvar mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform) : false;\n\nfunction normalizeKeyName(name) {\n  var parts = name.split(/-(?!$)/),\n      result = parts[parts.length - 1];\n\n  if (result == \"Space\") {\n    result = \" \";\n  }\n\n  var alt, ctrl, shift, meta;\n\n  for (var i = 0; i < parts.length - 1; i++) {\n    var mod = parts[i];\n\n    if (/^(cmd|meta|m)$/i.test(mod)) {\n      meta = true;\n    } else if (/^a(lt)?$/i.test(mod)) {\n      alt = true;\n    } else if (/^(c|ctrl|control)$/i.test(mod)) {\n      ctrl = true;\n    } else if (/^s(hift)?$/i.test(mod)) {\n      shift = true;\n    } else if (/^mod$/i.test(mod)) {\n      if (mac) {\n        meta = true;\n      } else {\n        ctrl = true;\n      }\n    } else {\n      throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n  }\n\n  if (alt) {\n    result = \"Alt-\" + result;\n  }\n\n  if (ctrl) {\n    result = \"Ctrl-\" + result;\n  }\n\n  if (meta) {\n    result = \"Meta-\" + result;\n  }\n\n  if (shift) {\n    result = \"Shift-\" + result;\n  }\n\n  return result;\n}\n\nfunction normalize(map) {\n  var copy = Object.create(null);\n\n  for (var prop in map) {\n    copy[normalizeKeyName(prop)] = map[prop];\n  }\n\n  return copy;\n}\n\nfunction modifiers(name, event, shift) {\n  if (event.altKey) {\n    name = \"Alt-\" + name;\n  }\n\n  if (event.ctrlKey) {\n    name = \"Ctrl-\" + name;\n  }\n\n  if (event.metaKey) {\n    name = \"Meta-\" + name;\n  }\n\n  if (shift !== false && event.shiftKey) {\n    name = \"Shift-\" + name;\n  }\n\n  return name;\n} // :: (Object) → Plugin\n// Create a keymap plugin for the given set of bindings.\n//\n// Bindings should map key names to [command](#commands)-style\n// functions, which will be called with `(EditorState, dispatch,\n// EditorView)` arguments, and should return true when they've handled\n// the key. Note that the view argument isn't part of the command\n// protocol, but can be used as an escape hatch if a binding needs to\n// directly interact with the UI.\n//\n// Key names may be strings like `\"Shift-Ctrl-Enter\"`—a key\n// identifier prefixed with zero or more modifiers. Key identifiers\n// are based on the strings that can appear in\n// [`KeyEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).\n// Use lowercase letters to refer to letter keys (or uppercase letters\n// if you want shift to be held). You may use `\"Space\"` as an alias\n// for the `\" \"` name.\n//\n// Modifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or\n// `a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or\n// `Meta-`) are recognized. For characters that are created by holding\n// shift, the `Shift-` prefix is implied, and should not be added\n// explicitly.\n//\n// You can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on\n// other platforms.\n//\n// You can add multiple keymap plugins to an editor. The order in\n// which they appear determines their precedence (the ones early in\n// the array get to dispatch first).\n\n\nfunction keymap(bindings) {\n  return new Plugin({\n    props: {\n      handleKeyDown: keydownHandler(bindings)\n    }\n  });\n} // :: (Object) → (view: EditorView, event: dom.Event) → bool\n// Given a set of bindings (using the same format as\n// [`keymap`](#keymap.keymap), return a [keydown\n// handler](#view.EditorProps.handleKeyDown) that handles them.\n\n\nfunction keydownHandler(bindings) {\n  var map = normalize(bindings);\n  return function (view, event) {\n    var name = keyName(event),\n        isChar = name.length == 1 && name != \" \",\n        baseName;\n    var direct = map[modifiers(name, event, !isChar)];\n\n    if (direct && direct(view.state, view.dispatch, view)) {\n      return true;\n    }\n\n    if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = base[event.keyCode]) && baseName != name) {\n      // Try falling back to the keyCode when there's a modifier\n      // active or the character produced isn't ASCII, and our table\n      // produces a different name from the the keyCode. See #668,\n      // #1060\n      var fromCode = map[modifiers(baseName, event, true)];\n\n      if (fromCode && fromCode(view.state, view.dispatch, view)) {\n        return true;\n      }\n    } else if (isChar && event.shiftKey) {\n      // Otherwise, if shift is active, also try the binding with the\n      // Shift- prefix enabled. See #997\n      var withShift = map[modifiers(name, event, true)];\n\n      if (withShift && withShift(view.state, view.dispatch, view)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n}\n\nexport { keydownHandler, keymap };","map":{"version":3,"sources":["../src/keymap.js"],"names":["const","let"],"mappings":"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","sourcesContent":["import {base, keyName} from \"w3c-keyname\"\nimport {Plugin} from \"prosemirror-state\"\n\n// declare global: navigator\n\nconst mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform) : false\n\nfunction normalizeKeyName(name) {\n  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1]\n  if (result == \"Space\") result = \" \"\n  let alt, ctrl, shift, meta\n  for (let i = 0; i < parts.length - 1; i++) {\n    let mod = parts[i]\n    if (/^(cmd|meta|m)$/i.test(mod)) meta = true\n    else if (/^a(lt)?$/i.test(mod)) alt = true\n    else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true\n    else if (/^s(hift)?$/i.test(mod)) shift = true\n    else if (/^mod$/i.test(mod)) { if (mac) meta = true; else ctrl = true }\n    else throw new Error(\"Unrecognized modifier name: \" + mod)\n  }\n  if (alt) result = \"Alt-\" + result\n  if (ctrl) result = \"Ctrl-\" + result\n  if (meta) result = \"Meta-\" + result\n  if (shift) result = \"Shift-\" + result\n  return result\n}\n\nfunction normalize(map) {\n  let copy = Object.create(null)\n  for (let prop in map) copy[normalizeKeyName(prop)] = map[prop]\n  return copy\n}\n\nfunction modifiers(name, event, shift) {\n  if (event.altKey) name = \"Alt-\" + name\n  if (event.ctrlKey) name = \"Ctrl-\" + name\n  if (event.metaKey) name = \"Meta-\" + name\n  if (shift !== false && event.shiftKey) name = \"Shift-\" + name\n  return name\n}\n\n// :: (Object) → Plugin\n// Create a keymap plugin for the given set of bindings.\n//\n// Bindings should map key names to [command](#commands)-style\n// functions, which will be called with `(EditorState, dispatch,\n// EditorView)` arguments, and should return true when they've handled\n// the key. Note that the view argument isn't part of the command\n// protocol, but can be used as an escape hatch if a binding needs to\n// directly interact with the UI.\n//\n// Key names may be strings like `\"Shift-Ctrl-Enter\"`—a key\n// identifier prefixed with zero or more modifiers. Key identifiers\n// are based on the strings that can appear in\n// [`KeyEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).\n// Use lowercase letters to refer to letter keys (or uppercase letters\n// if you want shift to be held). You may use `\"Space\"` as an alias\n// for the `\" \"` name.\n//\n// Modifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or\n// `a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or\n// `Meta-`) are recognized. For characters that are created by holding\n// shift, the `Shift-` prefix is implied, and should not be added\n// explicitly.\n//\n// You can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on\n// other platforms.\n//\n// You can add multiple keymap plugins to an editor. The order in\n// which they appear determines their precedence (the ones early in\n// the array get to dispatch first).\nexport function keymap(bindings) {\n  return new Plugin({props: {handleKeyDown: keydownHandler(bindings)}})\n}\n\n// :: (Object) → (view: EditorView, event: dom.Event) → bool\n// Given a set of bindings (using the same format as\n// [`keymap`](#keymap.keymap), return a [keydown\n// handler](#view.EditorProps.handleKeyDown) that handles them.\nexport function keydownHandler(bindings) {\n  let map = normalize(bindings)\n  return function(view, event) {\n    let name = keyName(event), isChar = name.length == 1 && name != \" \", baseName\n    let direct = map[modifiers(name, event, !isChar)]\n    if (direct && direct(view.state, view.dispatch, view)) return true\n    if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) &&\n        (baseName = base[event.keyCode]) && baseName != name) {\n      // Try falling back to the keyCode when there's a modifier\n      // active or the character produced isn't ASCII, and our table\n      // produces a different name from the the keyCode. See #668,\n      // #1060\n      let fromCode = map[modifiers(baseName, event, true)]\n      if (fromCode && fromCode(view.state, view.dispatch, view)) return true\n    } else if (isChar && event.shiftKey) {\n      // Otherwise, if shift is active, also try the binding with the\n      // Shift- prefix enabled. See #997\n      let withShift = map[modifiers(name, event, true)]\n      if (withShift && withShift(view.state, view.dispatch, view)) return true\n    }\n    return false\n  }\n}\n"]},"metadata":{},"sourceType":"module"}