{"ast":null,"code":"import { ProsemirrorMapping } from './plugins/sync-plugin.js'; // eslint-disable-line\n\nimport * as Y from 'yjs'; // eslint-disable-next-line\n\nimport { EditorView } from 'prosemirror-view';\nimport * as error from 'lib0/error.js';\nimport * as map from 'lib0/map.js';\nimport * as eventloop from 'lib0/eventloop.js';\n/**\n * Is null if no timeout is in progress.\n * Is defined if a timeout is in progress.\n * Maps from view\n * @type {Map<EditorView, Map<any, any>>|null}\n */\n\nlet viewsToUpdate = null;\n\nconst updateMetas = () => {\n  const ups =\n  /** @type {Map<EditorView, Map<any, any>>} */\n  viewsToUpdate;\n  viewsToUpdate = null;\n  ups.forEach((metas, view) => {\n    const tr = view.state.tr;\n    metas.forEach((val, key) => {\n      tr.setMeta(key, val);\n    });\n    view.dispatch(tr);\n  });\n};\n\nexport const setMeta = (view, key, value) => {\n  if (!viewsToUpdate) {\n    viewsToUpdate = new Map();\n    eventloop.timeout(0, updateMetas);\n  }\n\n  map.setIfUndefined(viewsToUpdate, view, map.create).set(key, value);\n};\n/**\n * Transforms a Prosemirror based absolute position to a Yjs Cursor (relative position in the Yjs model).\n *\n * @param {number} pos\n * @param {Y.XmlFragment} type\n * @param {ProsemirrorMapping} mapping\n * @return {any} relative position\n */\n\nexport const absolutePositionToRelativePosition = (pos, type, mapping) => {\n  if (pos === 0) {\n    return Y.createRelativePositionFromTypeIndex(type, 0);\n  }\n\n  let n = type._first === null ? null :\n  /** @type {Y.ContentType} */\n  type._first.content.type;\n\n  while (n !== null && type !== n) {\n    if (n.constructor === Y.XmlText) {\n      if (n._length >= pos) {\n        return Y.createRelativePositionFromTypeIndex(n, pos);\n      } else {\n        pos -= n._length;\n      }\n\n      if (n._item !== null && n._item.next !== null) {\n        n =\n        /** @type {Y.ContentType} */\n        n._item.next.content.type;\n      } else {\n        do {\n          n = n._item === null ? null : n._item.parent;\n          pos--;\n        } while (n !== type && n !== null && n._item !== null && n._item.next === null);\n\n        if (n !== null && n !== type) {\n          // @ts-gnore we know that n.next !== null because of above loop conditition\n          n = n._item === null ? null :\n          /** @type {Y.ContentType} */\n\n          /** @type Y.Item */\n          n._item.next.content.type;\n        }\n      }\n    } else {\n      const pNodeSize =\n      /** @type {any} */\n      (mapping.get(n) || {\n        nodeSize: 0\n      }).nodeSize;\n\n      if (n._first !== null && pos < pNodeSize) {\n        n =\n        /** @type {Y.ContentType} */\n        n._first.content.type;\n        pos--;\n      } else {\n        if (pos === 1 && n._length === 0 && pNodeSize > 1) {\n          // edge case, should end in this paragraph\n          return new Y.RelativePosition(n._item === null ? null : n._item.id, n._item === null ? Y.findRootTypeKey(n) : null, null);\n        }\n\n        pos -= pNodeSize;\n\n        if (n._item !== null && n._item.next !== null) {\n          n =\n          /** @type {Y.ContentType} */\n          n._item.next.content.type;\n        } else {\n          if (pos === 0) {\n            // set to end of n.parent\n            n = n._item === null ? n : n._item.parent;\n            return new Y.RelativePosition(n._item === null ? null : n._item.id, n._item === null ? Y.findRootTypeKey(n) : null, null);\n          }\n\n          do {\n            n =\n            /** @type {Y.Item} */\n            n._item.parent;\n            pos--;\n          } while (n !== type &&\n          /** @type {Y.Item} */\n          n._item.next === null); // if n is null at this point, we have an unexpected case\n\n\n          if (n !== type) {\n            // We know that n._item.next is defined because of above loop condition\n            n =\n            /** @type {Y.ContentType} */\n\n            /** @type {Y.Item} */\n\n            /** @type {Y.Item} */\n            n._item.next.content.type;\n          }\n        }\n      }\n    }\n\n    if (n === null) {\n      throw error.unexpectedCase();\n    }\n\n    if (pos === 0 && n.constructor !== Y.XmlText && n !== type) {\n      // TODO: set to <= 0\n      return new Y.RelativePosition(n._item === null ? null : n._item.id, n._item === null ? Y.findRootTypeKey(n) : null, null);\n    }\n  }\n\n  return Y.createRelativePositionFromTypeIndex(type, type._length);\n};\n/**\n * @param {Y.Doc} y\n * @param {Y.XmlFragment} documentType Top level type that is bound to pView\n * @param {any} relPos Encoded Yjs based relative position\n * @param {ProsemirrorMapping} mapping\n */\n\nexport const relativePositionToAbsolutePosition = (y, documentType, relPos, mapping) => {\n  const decodedPos = Y.createAbsolutePositionFromRelativePosition(relPos, y);\n\n  if (decodedPos === null || !Y.isParentOf(documentType, decodedPos.type._item)) {\n    return null;\n  }\n\n  let type = decodedPos.type;\n  let pos = 0;\n\n  if (type.constructor === Y.XmlText) {\n    pos = decodedPos.index;\n  } else if (type._item === null || !type._item.deleted) {\n    let n = type._first;\n    let i = 0;\n\n    while (i < type._length && i < decodedPos.index && n !== null) {\n      if (!n.deleted) {\n        const t =\n        /** @type {Y.ContentType} */\n        n.content.type;\n        i++;\n\n        if (t.constructor === Y.XmlText) {\n          pos += t._length;\n        } else {\n          pos +=\n          /** @type {any} */\n          mapping.get(t).nodeSize;\n        }\n      }\n\n      n =\n      /** @type {Y.Item} */\n      n.right;\n    }\n\n    pos += 1; // increase because we go out of n\n  }\n\n  while (type !== documentType && type._item !== null) {\n    // @ts-ignore\n    const parent = type._item.parent; // @ts-ignore\n\n    if (parent._item === null || !parent._item.deleted) {\n      pos += 1; // the start tag\n\n      let n = parent._first; // now iterate until we found type\n\n      while (n !== null) {\n        const contentType =\n        /** @type {Y.ContentType} */\n        n.content.type;\n\n        if (contentType === type) {\n          break;\n        }\n\n        if (!n.deleted) {\n          if (contentType.constructor === Y.XmlText) {\n            pos += contentType._length;\n          } else {\n            pos +=\n            /** @type {any} */\n            mapping.get(contentType).nodeSize;\n          }\n        }\n\n        n = n.right;\n      }\n    }\n\n    type = parent;\n  }\n\n  return pos - 1; // we don't count the most outer tag, because it is a fragment\n};","map":{"version":3,"sources":["/Users/meeopp/Development/Others/editor-yjs/client/node_modules/y-prosemirror/src/lib.js"],"names":["ProsemirrorMapping","Y","EditorView","error","map","eventloop","viewsToUpdate","updateMetas","ups","forEach","metas","view","tr","state","val","key","setMeta","dispatch","value","Map","timeout","setIfUndefined","create","set","absolutePositionToRelativePosition","pos","type","mapping","createRelativePositionFromTypeIndex","n","_first","content","constructor","XmlText","_length","_item","next","parent","pNodeSize","get","nodeSize","RelativePosition","id","findRootTypeKey","unexpectedCase","relativePositionToAbsolutePosition","y","documentType","relPos","decodedPos","createAbsolutePositionFromRelativePosition","isParentOf","index","deleted","i","t","right","contentType"],"mappings":"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","sourcesContent":["import { ProsemirrorMapping } from './plugins/sync-plugin.js' // eslint-disable-line\n\nimport * as Y from 'yjs'\n// eslint-disable-next-line\nimport { EditorView } from 'prosemirror-view'\nimport * as error from 'lib0/error.js'\nimport * as map from 'lib0/map.js'\nimport * as eventloop from 'lib0/eventloop.js'\n\n/**\n * Is null if no timeout is in progress.\n * Is defined if a timeout is in progress.\n * Maps from view\n * @type {Map<EditorView, Map<any, any>>|null}\n */\nlet viewsToUpdate = null\n\nconst updateMetas = () => {\n  const ups = /** @type {Map<EditorView, Map<any, any>>} */ (viewsToUpdate)\n  viewsToUpdate = null\n  ups.forEach((metas, view) => {\n    const tr = view.state.tr\n    metas.forEach((val, key) => {\n      tr.setMeta(key, val)\n    })\n    view.dispatch(tr)\n  })\n}\n\nexport const setMeta = (view, key, value) => {\n  if (!viewsToUpdate) {\n    viewsToUpdate = new Map()\n    eventloop.timeout(0, updateMetas)\n  }\n  map.setIfUndefined(viewsToUpdate, view, map.create).set(key, value)\n}\n\n/**\n * Transforms a Prosemirror based absolute position to a Yjs Cursor (relative position in the Yjs model).\n *\n * @param {number} pos\n * @param {Y.XmlFragment} type\n * @param {ProsemirrorMapping} mapping\n * @return {any} relative position\n */\nexport const absolutePositionToRelativePosition = (pos, type, mapping) => {\n  if (pos === 0) {\n    return Y.createRelativePositionFromTypeIndex(type, 0)\n  }\n  let n = type._first === null ? null : /** @type {Y.ContentType} */ (type._first.content).type\n  while (n !== null && type !== n) {\n    if (n.constructor === Y.XmlText) {\n      if (n._length >= pos) {\n        return Y.createRelativePositionFromTypeIndex(n, pos)\n      } else {\n        pos -= n._length\n      }\n      if (n._item !== null && n._item.next !== null) {\n        n = /** @type {Y.ContentType} */ (n._item.next.content).type\n      } else {\n        do {\n          n = n._item === null ? null : n._item.parent\n          pos--\n        } while (n !== type && n !== null && n._item !== null && n._item.next === null)\n        if (n !== null && n !== type) {\n          // @ts-gnore we know that n.next !== null because of above loop conditition\n          n = n._item === null ? null : /** @type {Y.ContentType} */ (/** @type Y.Item */ (n._item.next).content).type\n        }\n      }\n    } else {\n      const pNodeSize = /** @type {any} */ (mapping.get(n) || { nodeSize: 0 }).nodeSize\n      if (n._first !== null && pos < pNodeSize) {\n        n = /** @type {Y.ContentType} */ (n._first.content).type\n        pos--\n      } else {\n        if (pos === 1 && n._length === 0 && pNodeSize > 1) {\n          // edge case, should end in this paragraph\n          return new Y.RelativePosition(n._item === null ? null : n._item.id, n._item === null ? Y.findRootTypeKey(n) : null, null)\n        }\n        pos -= pNodeSize\n        if (n._item !== null && n._item.next !== null) {\n          n = /** @type {Y.ContentType} */ (n._item.next.content).type\n        } else {\n          if (pos === 0) {\n            // set to end of n.parent\n            n = n._item === null ? n : n._item.parent\n            return new Y.RelativePosition(n._item === null ? null : n._item.id, n._item === null ? Y.findRootTypeKey(n) : null, null)\n          }\n          do {\n            n = /** @type {Y.Item} */ (n._item).parent\n            pos--\n          } while (n !== type && /** @type {Y.Item} */ (n._item).next === null)\n          // if n is null at this point, we have an unexpected case\n          if (n !== type) {\n            // We know that n._item.next is defined because of above loop condition\n            n = /** @type {Y.ContentType} */ (/** @type {Y.Item} */ (/** @type {Y.Item} */ (n._item).next).content).type\n          }\n        }\n      }\n    }\n    if (n === null) {\n      throw error.unexpectedCase()\n    }\n    if (pos === 0 && n.constructor !== Y.XmlText && n !== type) { // TODO: set to <= 0\n      return new Y.RelativePosition(n._item === null ? null : n._item.id, n._item === null ? Y.findRootTypeKey(n) : null, null)\n    }\n  }\n  return Y.createRelativePositionFromTypeIndex(type, type._length)\n}\n\n/**\n * @param {Y.Doc} y\n * @param {Y.XmlFragment} documentType Top level type that is bound to pView\n * @param {any} relPos Encoded Yjs based relative position\n * @param {ProsemirrorMapping} mapping\n */\nexport const relativePositionToAbsolutePosition = (y, documentType, relPos, mapping) => {\n  const decodedPos = Y.createAbsolutePositionFromRelativePosition(relPos, y)\n  if (decodedPos === null || !Y.isParentOf(documentType, decodedPos.type._item)) {\n    return null\n  }\n  let type = decodedPos.type\n  let pos = 0\n  if (type.constructor === Y.XmlText) {\n    pos = decodedPos.index\n  } else if (type._item === null || !type._item.deleted) {\n    let n = type._first\n    let i = 0\n    while (i < type._length && i < decodedPos.index && n !== null) {\n      if (!n.deleted) {\n        const t = /** @type {Y.ContentType} */ (n.content).type\n        i++\n        if (t.constructor === Y.XmlText) {\n          pos += t._length\n        } else {\n          pos += /** @type {any} */ (mapping.get(t)).nodeSize\n        }\n      }\n      n = /** @type {Y.Item} */ (n.right)\n    }\n    pos += 1 // increase because we go out of n\n  }\n  while (type !== documentType && type._item !== null) {\n    // @ts-ignore\n    const parent = type._item.parent\n    // @ts-ignore\n    if (parent._item === null || !parent._item.deleted) {\n      pos += 1 // the start tag\n      let n = parent._first\n      // now iterate until we found type\n      while (n !== null) {\n        const contentType = /** @type {Y.ContentType} */ (n.content).type\n        if (contentType === type) {\n          break\n        }\n        if (!n.deleted) {\n          if (contentType.constructor === Y.XmlText) {\n            pos += contentType._length\n          } else {\n            pos += /** @type {any} */ (mapping.get(contentType)).nodeSize\n          }\n        }\n        n = n.right\n      }\n    }\n    type = parent\n  }\n  return pos - 1 // we don't count the most outer tag, because it is a fragment\n}\n"]},"metadata":{},"sourceType":"module"}