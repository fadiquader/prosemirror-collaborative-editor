{"ast":null,"code":"// ::- Persistent data structure representing an ordered mapping from\n// strings to values, with some convenient update methods.\nfunction OrderedMap(content) {\n  this.content = content;\n}\n\nOrderedMap.prototype = {\n  constructor: OrderedMap,\n  find: function (key) {\n    for (var i = 0; i < this.content.length; i += 2) if (this.content[i] === key) return i;\n\n    return -1;\n  },\n  // :: (string) → ?any\n  // Retrieve the value stored under `key`, or return undefined when\n  // no such key exists.\n  get: function (key) {\n    var found = this.find(key);\n    return found == -1 ? undefined : this.content[found + 1];\n  },\n  // :: (string, any, ?string) → OrderedMap\n  // Create a new map by replacing the value of `key` with a new\n  // value, or adding a binding to the end of the map. If `newKey` is\n  // given, the key of the binding will be replaced with that key.\n  update: function (key, value, newKey) {\n    var self = newKey && newKey != key ? this.remove(newKey) : this;\n    var found = self.find(key),\n        content = self.content.slice();\n\n    if (found == -1) {\n      content.push(newKey || key, value);\n    } else {\n      content[found + 1] = value;\n      if (newKey) content[found] = newKey;\n    }\n\n    return new OrderedMap(content);\n  },\n  // :: (string) → OrderedMap\n  // Return a map with the given key removed, if it existed.\n  remove: function (key) {\n    var found = this.find(key);\n    if (found == -1) return this;\n    var content = this.content.slice();\n    content.splice(found, 2);\n    return new OrderedMap(content);\n  },\n  // :: (string, any) → OrderedMap\n  // Add a new key to the start of the map.\n  addToStart: function (key, value) {\n    return new OrderedMap([key, value].concat(this.remove(key).content));\n  },\n  // :: (string, any) → OrderedMap\n  // Add a new key to the end of the map.\n  addToEnd: function (key, value) {\n    var content = this.remove(key).content.slice();\n    content.push(key, value);\n    return new OrderedMap(content);\n  },\n  // :: (string, string, any) → OrderedMap\n  // Add a key after the given key. If `place` is not found, the new\n  // key is added to the end.\n  addBefore: function (place, key, value) {\n    var without = this.remove(key),\n        content = without.content.slice();\n    var found = without.find(place);\n    content.splice(found == -1 ? content.length : found, 0, key, value);\n    return new OrderedMap(content);\n  },\n  // :: ((key: string, value: any))\n  // Call the given function for each key/value pair in the map, in\n  // order.\n  forEach: function (f) {\n    for (var i = 0; i < this.content.length; i += 2) f(this.content[i], this.content[i + 1]);\n  },\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by prepending the keys in this map that don't\n  // appear in `map` before the keys in `map`.\n  prepend: function (map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this;\n    return new OrderedMap(map.content.concat(this.subtract(map).content));\n  },\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by appending the keys in this map that don't\n  // appear in `map` after the keys in `map`.\n  append: function (map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this;\n    return new OrderedMap(this.subtract(map).content.concat(map.content));\n  },\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a map containing all the keys in this map that don't\n  // appear in `map`.\n  subtract: function (map) {\n    var result = this;\n    map = OrderedMap.from(map);\n\n    for (var i = 0; i < map.content.length; i += 2) result = result.remove(map.content[i]);\n\n    return result;\n  },\n\n  // :: number\n  // The amount of keys in this map.\n  get size() {\n    return this.content.length >> 1;\n  }\n\n}; // :: (?union<Object, OrderedMap>) → OrderedMap\n// Return a map with the given content. If null, create an empty\n// map. If given an ordered map, return that map itself. If given an\n// object, create a map from the object's properties.\n\nOrderedMap.from = function (value) {\n  if (value instanceof OrderedMap) return value;\n  var content = [];\n  if (value) for (var prop in value) content.push(prop, value[prop]);\n  return new OrderedMap(content);\n};\n\nvar orderedmap = OrderedMap;\nexport default orderedmap;","map":{"version":3,"sources":["/Users/meeopp/Development/Others/editor-yjs/client/node_modules/orderedmap/index.es.js"],"names":["OrderedMap","content","prototype","constructor","find","key","i","length","get","found","undefined","update","value","newKey","self","remove","slice","push","splice","addToStart","concat","addToEnd","addBefore","place","without","forEach","f","prepend","map","from","size","subtract","append","result","prop","orderedmap"],"mappings":"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","sourcesContent":["// ::- Persistent data structure representing an ordered mapping from\n// strings to values, with some convenient update methods.\nfunction OrderedMap(content) {\n  this.content = content;\n}\n\nOrderedMap.prototype = {\n  constructor: OrderedMap,\n\n  find: function(key) {\n    for (var i = 0; i < this.content.length; i += 2)\n      if (this.content[i] === key) return i\n    return -1\n  },\n\n  // :: (string) → ?any\n  // Retrieve the value stored under `key`, or return undefined when\n  // no such key exists.\n  get: function(key) {\n    var found = this.find(key);\n    return found == -1 ? undefined : this.content[found + 1]\n  },\n\n  // :: (string, any, ?string) → OrderedMap\n  // Create a new map by replacing the value of `key` with a new\n  // value, or adding a binding to the end of the map. If `newKey` is\n  // given, the key of the binding will be replaced with that key.\n  update: function(key, value, newKey) {\n    var self = newKey && newKey != key ? this.remove(newKey) : this;\n    var found = self.find(key), content = self.content.slice();\n    if (found == -1) {\n      content.push(newKey || key, value);\n    } else {\n      content[found + 1] = value;\n      if (newKey) content[found] = newKey;\n    }\n    return new OrderedMap(content)\n  },\n\n  // :: (string) → OrderedMap\n  // Return a map with the given key removed, if it existed.\n  remove: function(key) {\n    var found = this.find(key);\n    if (found == -1) return this\n    var content = this.content.slice();\n    content.splice(found, 2);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, any) → OrderedMap\n  // Add a new key to the start of the map.\n  addToStart: function(key, value) {\n    return new OrderedMap([key, value].concat(this.remove(key).content))\n  },\n\n  // :: (string, any) → OrderedMap\n  // Add a new key to the end of the map.\n  addToEnd: function(key, value) {\n    var content = this.remove(key).content.slice();\n    content.push(key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, string, any) → OrderedMap\n  // Add a key after the given key. If `place` is not found, the new\n  // key is added to the end.\n  addBefore: function(place, key, value) {\n    var without = this.remove(key), content = without.content.slice();\n    var found = without.find(place);\n    content.splice(found == -1 ? content.length : found, 0, key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: ((key: string, value: any))\n  // Call the given function for each key/value pair in the map, in\n  // order.\n  forEach: function(f) {\n    for (var i = 0; i < this.content.length; i += 2)\n      f(this.content[i], this.content[i + 1]);\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by prepending the keys in this map that don't\n  // appear in `map` before the keys in `map`.\n  prepend: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(map.content.concat(this.subtract(map).content))\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by appending the keys in this map that don't\n  // appear in `map` after the keys in `map`.\n  append: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(this.subtract(map).content.concat(map.content))\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a map containing all the keys in this map that don't\n  // appear in `map`.\n  subtract: function(map) {\n    var result = this;\n    map = OrderedMap.from(map);\n    for (var i = 0; i < map.content.length; i += 2)\n      result = result.remove(map.content[i]);\n    return result\n  },\n\n  // :: number\n  // The amount of keys in this map.\n  get size() {\n    return this.content.length >> 1\n  }\n};\n\n// :: (?union<Object, OrderedMap>) → OrderedMap\n// Return a map with the given content. If null, create an empty\n// map. If given an ordered map, return that map itself. If given an\n// object, create a map from the object's properties.\nOrderedMap.from = function(value) {\n  if (value instanceof OrderedMap) return value\n  var content = [];\n  if (value) for (var prop in value) content.push(prop, value[prop]);\n  return new OrderedMap(content)\n};\n\nvar orderedmap = OrderedMap;\n\nexport default orderedmap;\n"]},"metadata":{},"sourceType":"module"}