{"ast":null,"code":"/* eslint-env browser */\n\n/**\n * Utility module to work with the DOM.\n *\n * @module dom\n */\nimport * as pair from './pair.js';\nimport * as map from './map.js';\n/* istanbul ignore next */\n\n/**\n * @type {Document}\n */\n\nexport const doc =\n/** @type {Document} */\ntypeof document !== 'undefined' ? document : {};\n/**\n * @param {string} name\n * @return {HTMLElement}\n */\n\n/* istanbul ignore next */\n\nexport const createElement = name => doc.createElement(name);\n/**\n * @return {DocumentFragment}\n */\n\n/* istanbul ignore next */\n\nexport const createDocumentFragment = () => doc.createDocumentFragment();\n/**\n * @param {string} text\n * @return {Text}\n */\n\n/* istanbul ignore next */\n\nexport const createTextNode = text => doc.createTextNode(text);\n/* istanbul ignore next */\n\nexport const domParser =\n/** @type {DOMParser} */\ntypeof DOMParser !== 'undefined' ? new DOMParser() : null;\n/**\n * @param {HTMLElement} el\n * @param {string} name\n * @param {Object} opts\n */\n\n/* istanbul ignore next */\n\nexport const emitCustomEvent = (el, name, opts) => el.dispatchEvent(new CustomEvent(name, opts));\n/**\n * @param {Element} el\n * @param {Array<pair.Pair<string,string|boolean>>} attrs Array of key-value pairs\n * @return {Element}\n */\n\n/* istanbul ignore next */\n\nexport const setAttributes = (el, attrs) => {\n  pair.forEach(attrs, (key, value) => {\n    if (value === false) {\n      el.removeAttribute(key);\n    } else if (value === true) {\n      el.setAttribute(key, '');\n    } else {\n      // @ts-ignore\n      el.setAttribute(key, value);\n    }\n  });\n  return el;\n};\n/**\n * @param {Element} el\n * @param {Map<string, string>} attrs Array of key-value pairs\n * @return {Element}\n */\n\n/* istanbul ignore next */\n\nexport const setAttributesMap = (el, attrs) => {\n  map.map(attrs, (value, key) => el.setAttribute(key, value));\n  return el;\n};\n/**\n * @param {Array<Node>|HTMLCollection} children\n * @return {DocumentFragment}\n */\n\n/* istanbul ignore next */\n\nexport const fragment = children => {\n  const fragment = createDocumentFragment();\n\n  for (let i = 0; i < children.length; i++) {\n    appendChild(fragment, children[i]);\n  }\n\n  return fragment;\n};\n/**\n * @param {Element} parent\n * @param {Array<Node>} nodes\n * @return {Element}\n */\n\n/* istanbul ignore next */\n\nexport const append = (parent, nodes) => {\n  appendChild(parent, fragment(nodes));\n  return parent;\n};\n/**\n * @param {HTMLElement} el\n */\n\n/* istanbul ignore next */\n\nexport const remove = el => el.remove();\n/**\n * @param {EventTarget} el\n * @param {string} name\n * @param {EventListener} f\n */\n\n/* istanbul ignore next */\n\nexport const addEventListener = (el, name, f) => el.addEventListener(name, f);\n/**\n * @param {EventTarget} el\n * @param {string} name\n * @param {EventListener} f\n */\n\n/* istanbul ignore next */\n\nexport const removeEventListener = (el, name, f) => el.removeEventListener(name, f);\n/**\n * @param {Node} node\n * @param {Array<pair.Pair<string,EventListener>>} listeners\n * @return {Node}\n */\n\n/* istanbul ignore next */\n\nexport const addEventListeners = (node, listeners) => {\n  pair.forEach(listeners, (name, f) => addEventListener(node, name, f));\n  return node;\n};\n/**\n * @param {Node} node\n * @param {Array<pair.Pair<string,EventListener>>} listeners\n * @return {Node}\n */\n\n/* istanbul ignore next */\n\nexport const removeEventListeners = (node, listeners) => {\n  pair.forEach(listeners, (name, f) => removeEventListener(node, name, f));\n  return node;\n};\n/**\n * @param {string} name\n * @param {Array<pair.Pair<string,string>|pair.Pair<string,boolean>>} attrs Array of key-value pairs\n * @param {Array<Node>} children\n * @return {Element}\n */\n\n/* istanbul ignore next */\n\nexport const element = (name, attrs = [], children = []) => append(setAttributes(createElement(name), attrs), children);\n/**\n * @param {number} width\n * @param {number} height\n */\n\n/* istanbul ignore next */\n\nexport const canvas = (width, height) => {\n  const c =\n  /** @type {HTMLCanvasElement} */\n  createElement('canvas');\n  c.height = height;\n  c.width = width;\n  return c;\n};\n/**\n * @param {string} t\n * @return {Text}\n */\n\n/* istanbul ignore next */\n\nexport const text = createTextNode;\n/**\n * @param {pair.Pair<string,string>} pair\n */\n\n/* istanbul ignore next */\n\nexport const pairToStyleString = pair => `${pair.left}:${pair.right};`;\n/**\n * @param {Array<pair.Pair<string,string>>} pairs\n * @return {string}\n */\n\n/* istanbul ignore next */\n\nexport const pairsToStyleString = pairs => pairs.map(pairToStyleString).join('');\n/**\n * @param {Map<string,string>} m\n * @return {string}\n */\n\n/* istanbul ignore next */\n\nexport const mapToStyleString = m => map.map(m, (value, key) => `${key}:${value};`).join('');\n/**\n * @todo should always query on a dom element\n *\n * @param {HTMLElement|ShadowRoot} el\n * @param {string} query\n * @return {HTMLElement | null}\n */\n\n/* istanbul ignore next */\n\nexport const querySelector = (el, query) => el.querySelector(query);\n/**\n * @param {HTMLElement|ShadowRoot} el\n * @param {string} query\n * @return {NodeListOf<HTMLElement>}\n */\n\n/* istanbul ignore next */\n\nexport const querySelectorAll = (el, query) => el.querySelectorAll(query);\n/**\n * @param {string} id\n * @return {HTMLElement}\n */\n\n/* istanbul ignore next */\n\nexport const getElementById = id =>\n/** @type {HTMLElement} */\ndoc.getElementById(id);\n/**\n * @param {string} html\n * @return {HTMLElement}\n */\n\n/* istanbul ignore next */\n\nconst _parse = html => domParser.parseFromString(`<html><body>${html}</body></html>`, 'text/html').body;\n/**\n * @param {string} html\n * @return {DocumentFragment}\n */\n\n/* istanbul ignore next */\n\n\nexport const parseFragment = html => fragment(\n/** @type {any} */\n_parse(html).childNodes);\n/**\n * @param {string} html\n * @return {HTMLElement}\n */\n\n/* istanbul ignore next */\n\nexport const parseElement = html =>\n/** @type HTMLElement */\n_parse(html).firstElementChild;\n/**\n * @param {HTMLElement} oldEl\n * @param {HTMLElement|DocumentFragment} newEl\n */\n\n/* istanbul ignore next */\n\nexport const replaceWith = (oldEl, newEl) => oldEl.replaceWith(newEl);\n/**\n * @param {HTMLElement} parent\n * @param {HTMLElement} el\n * @param {Node|null} ref\n * @return {HTMLElement}\n */\n\n/* istanbul ignore next */\n\nexport const insertBefore = (parent, el, ref) => parent.insertBefore(el, ref);\n/**\n * @param {Node} parent\n * @param {Node} child\n * @return {Node}\n */\n\n/* istanbul ignore next */\n\nexport const appendChild = (parent, child) => parent.appendChild(child);\nexport const ELEMENT_NODE = doc.ELEMENT_NODE;\nexport const TEXT_NODE = doc.TEXT_NODE;\nexport const CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE;\nexport const COMMENT_NODE = doc.COMMENT_NODE;\nexport const DOCUMENT_NODE = doc.DOCUMENT_NODE;\nexport const DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE;\nexport const DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE;\n/**\n * @param {any} node\n * @param {number} type\n */\n\nexport const checkNodeType = (node, type) => node.nodeType === type;\n/**\n * @param {Node} parent\n * @param {HTMLElement} child\n */\n\nexport const isParentOf = (parent, child) => {\n  let p = child.parentNode;\n\n  while (p && p !== parent) {\n    p = p.parentNode;\n  }\n\n  return p === parent;\n};","map":{"version":3,"sources":["/Users/meeopp/Development/Others/editor-yjs/client/node_modules/lib0/dom.js"],"names":["pair","map","doc","document","createElement","name","createDocumentFragment","createTextNode","text","domParser","DOMParser","emitCustomEvent","el","opts","dispatchEvent","CustomEvent","setAttributes","attrs","forEach","key","value","removeAttribute","setAttribute","setAttributesMap","fragment","children","i","length","appendChild","append","parent","nodes","remove","addEventListener","f","removeEventListener","addEventListeners","node","listeners","removeEventListeners","element","canvas","width","height","c","pairToStyleString","left","right","pairsToStyleString","pairs","join","mapToStyleString","m","querySelector","query","querySelectorAll","getElementById","id","_parse","html","parseFromString","body","parseFragment","childNodes","parseElement","firstElementChild","replaceWith","oldEl","newEl","insertBefore","ref","child","ELEMENT_NODE","TEXT_NODE","CDATA_SECTION_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_TYPE_NODE","DOCUMENT_FRAGMENT_NODE","checkNodeType","type","nodeType","isParentOf","p","parentNode"],"mappings":"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","sourcesContent":["/* eslint-env browser */\n\n/**\n * Utility module to work with the DOM.\n *\n * @module dom\n */\n\nimport * as pair from './pair.js'\nimport * as map from './map.js'\n\n/* istanbul ignore next */\n/**\n * @type {Document}\n */\nexport const doc = /** @type {Document} */ (typeof document !== 'undefined' ? document : {})\n\n/**\n * @param {string} name\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nexport const createElement = name => doc.createElement(name)\n\n/**\n * @return {DocumentFragment}\n */\n/* istanbul ignore next */\nexport const createDocumentFragment = () => doc.createDocumentFragment()\n\n/**\n * @param {string} text\n * @return {Text}\n */\n/* istanbul ignore next */\nexport const createTextNode = text => doc.createTextNode(text)\n\n/* istanbul ignore next */\nexport const domParser = /** @type {DOMParser} */ (typeof DOMParser !== 'undefined' ? new DOMParser() : null)\n\n/**\n * @param {HTMLElement} el\n * @param {string} name\n * @param {Object} opts\n */\n/* istanbul ignore next */\nexport const emitCustomEvent = (el, name, opts) => el.dispatchEvent(new CustomEvent(name, opts))\n\n/**\n * @param {Element} el\n * @param {Array<pair.Pair<string,string|boolean>>} attrs Array of key-value pairs\n * @return {Element}\n */\n/* istanbul ignore next */\nexport const setAttributes = (el, attrs) => {\n  pair.forEach(attrs, (key, value) => {\n    if (value === false) {\n      el.removeAttribute(key)\n    } else if (value === true) {\n      el.setAttribute(key, '')\n    } else {\n      // @ts-ignore\n      el.setAttribute(key, value)\n    }\n  })\n  return el\n}\n\n/**\n * @param {Element} el\n * @param {Map<string, string>} attrs Array of key-value pairs\n * @return {Element}\n */\n/* istanbul ignore next */\nexport const setAttributesMap = (el, attrs) => {\n  map.map(attrs, (value, key) => el.setAttribute(key, value))\n  return el\n}\n\n/**\n * @param {Array<Node>|HTMLCollection} children\n * @return {DocumentFragment}\n */\n/* istanbul ignore next */\nexport const fragment = children => {\n  const fragment = createDocumentFragment()\n  for (let i = 0; i < children.length; i++) {\n    appendChild(fragment, children[i])\n  }\n  return fragment\n}\n\n/**\n * @param {Element} parent\n * @param {Array<Node>} nodes\n * @return {Element}\n */\n/* istanbul ignore next */\nexport const append = (parent, nodes) => {\n  appendChild(parent, fragment(nodes))\n  return parent\n}\n\n/**\n * @param {HTMLElement} el\n */\n/* istanbul ignore next */\nexport const remove = el => el.remove()\n\n/**\n * @param {EventTarget} el\n * @param {string} name\n * @param {EventListener} f\n */\n/* istanbul ignore next */\nexport const addEventListener = (el, name, f) => el.addEventListener(name, f)\n\n/**\n * @param {EventTarget} el\n * @param {string} name\n * @param {EventListener} f\n */\n/* istanbul ignore next */\nexport const removeEventListener = (el, name, f) => el.removeEventListener(name, f)\n\n/**\n * @param {Node} node\n * @param {Array<pair.Pair<string,EventListener>>} listeners\n * @return {Node}\n */\n/* istanbul ignore next */\nexport const addEventListeners = (node, listeners) => {\n  pair.forEach(listeners, (name, f) => addEventListener(node, name, f))\n  return node\n}\n\n/**\n * @param {Node} node\n * @param {Array<pair.Pair<string,EventListener>>} listeners\n * @return {Node}\n */\n/* istanbul ignore next */\nexport const removeEventListeners = (node, listeners) => {\n  pair.forEach(listeners, (name, f) => removeEventListener(node, name, f))\n  return node\n}\n\n/**\n * @param {string} name\n * @param {Array<pair.Pair<string,string>|pair.Pair<string,boolean>>} attrs Array of key-value pairs\n * @param {Array<Node>} children\n * @return {Element}\n */\n/* istanbul ignore next */\nexport const element = (name, attrs = [], children = []) =>\n  append(setAttributes(createElement(name), attrs), children)\n\n/**\n * @param {number} width\n * @param {number} height\n */\n/* istanbul ignore next */\nexport const canvas = (width, height) => {\n  const c = /** @type {HTMLCanvasElement} */ (createElement('canvas'))\n  c.height = height\n  c.width = width\n  return c\n}\n\n/**\n * @param {string} t\n * @return {Text}\n */\n/* istanbul ignore next */\nexport const text = createTextNode\n\n/**\n * @param {pair.Pair<string,string>} pair\n */\n/* istanbul ignore next */\nexport const pairToStyleString = pair => `${pair.left}:${pair.right};`\n\n/**\n * @param {Array<pair.Pair<string,string>>} pairs\n * @return {string}\n */\n/* istanbul ignore next */\nexport const pairsToStyleString = pairs => pairs.map(pairToStyleString).join('')\n\n/**\n * @param {Map<string,string>} m\n * @return {string}\n */\n/* istanbul ignore next */\nexport const mapToStyleString = m => map.map(m, (value, key) => `${key}:${value};`).join('')\n\n/**\n * @todo should always query on a dom element\n *\n * @param {HTMLElement|ShadowRoot} el\n * @param {string} query\n * @return {HTMLElement | null}\n */\n/* istanbul ignore next */\nexport const querySelector = (el, query) => el.querySelector(query)\n\n/**\n * @param {HTMLElement|ShadowRoot} el\n * @param {string} query\n * @return {NodeListOf<HTMLElement>}\n */\n/* istanbul ignore next */\nexport const querySelectorAll = (el, query) => el.querySelectorAll(query)\n\n/**\n * @param {string} id\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nexport const getElementById = id => /** @type {HTMLElement} */ (doc.getElementById(id))\n\n/**\n * @param {string} html\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst _parse = html => domParser.parseFromString(`<html><body>${html}</body></html>`, 'text/html').body\n\n/**\n * @param {string} html\n * @return {DocumentFragment}\n */\n/* istanbul ignore next */\nexport const parseFragment = html => fragment(/** @type {any} */ (_parse(html).childNodes))\n\n/**\n * @param {string} html\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nexport const parseElement = html => /** @type HTMLElement */ (_parse(html).firstElementChild)\n\n/**\n * @param {HTMLElement} oldEl\n * @param {HTMLElement|DocumentFragment} newEl\n */\n/* istanbul ignore next */\nexport const replaceWith = (oldEl, newEl) => oldEl.replaceWith(newEl)\n\n/**\n * @param {HTMLElement} parent\n * @param {HTMLElement} el\n * @param {Node|null} ref\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nexport const insertBefore = (parent, el, ref) => parent.insertBefore(el, ref)\n\n/**\n * @param {Node} parent\n * @param {Node} child\n * @return {Node}\n */\n/* istanbul ignore next */\nexport const appendChild = (parent, child) => parent.appendChild(child)\n\nexport const ELEMENT_NODE = doc.ELEMENT_NODE\nexport const TEXT_NODE = doc.TEXT_NODE\nexport const CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE\nexport const COMMENT_NODE = doc.COMMENT_NODE\nexport const DOCUMENT_NODE = doc.DOCUMENT_NODE\nexport const DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE\nexport const DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE\n\n/**\n * @param {any} node\n * @param {number} type\n */\nexport const checkNodeType = (node, type) => node.nodeType === type\n\n/**\n * @param {Node} parent\n * @param {HTMLElement} child\n */\nexport const isParentOf = (parent, child) => {\n  let p = child.parentNode\n  while (p && p !== parent) {\n    p = p.parentNode\n  }\n  return p === parent\n}\n"]},"metadata":{},"sourceType":"module"}