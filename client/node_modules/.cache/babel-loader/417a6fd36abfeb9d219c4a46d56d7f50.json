{"ast":null,"code":"import OrderedMap from 'orderedmap';\n\nfunction findDiffStart(a, b, pos) {\n  for (var i = 0;; i++) {\n    if (i == a.childCount || i == b.childCount) {\n      return a.childCount == b.childCount ? null : pos;\n    }\n\n    var childA = a.child(i),\n        childB = b.child(i);\n\n    if (childA == childB) {\n      pos += childA.nodeSize;\n      continue;\n    }\n\n    if (!childA.sameMarkup(childB)) {\n      return pos;\n    }\n\n    if (childA.isText && childA.text != childB.text) {\n      for (var j = 0; childA.text[j] == childB.text[j]; j++) {\n        pos++;\n      }\n\n      return pos;\n    }\n\n    if (childA.content.size || childB.content.size) {\n      var inner = findDiffStart(childA.content, childB.content, pos + 1);\n\n      if (inner != null) {\n        return inner;\n      }\n    }\n\n    pos += childA.nodeSize;\n  }\n}\n\nfunction findDiffEnd(a, b, posA, posB) {\n  for (var iA = a.childCount, iB = b.childCount;;) {\n    if (iA == 0 || iB == 0) {\n      return iA == iB ? null : {\n        a: posA,\n        b: posB\n      };\n    }\n\n    var childA = a.child(--iA),\n        childB = b.child(--iB),\n        size = childA.nodeSize;\n\n    if (childA == childB) {\n      posA -= size;\n      posB -= size;\n      continue;\n    }\n\n    if (!childA.sameMarkup(childB)) {\n      return {\n        a: posA,\n        b: posB\n      };\n    }\n\n    if (childA.isText && childA.text != childB.text) {\n      var same = 0,\n          minSize = Math.min(childA.text.length, childB.text.length);\n\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++;\n        posA--;\n        posB--;\n      }\n\n      return {\n        a: posA,\n        b: posB\n      };\n    }\n\n    if (childA.content.size || childB.content.size) {\n      var inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);\n\n      if (inner) {\n        return inner;\n      }\n    }\n\n    posA -= size;\n    posB -= size;\n  }\n} // ::- A fragment represents a node's collection of child nodes.\n//\n// Like nodes, fragments are persistent data structures, and you\n// should not mutate them or their content. Rather, you create new\n// instances whenever needed. The API tries to make this easy.\n\n\nvar Fragment = function Fragment(content, size) {\n  this.content = content; // :: number\n  // The size of the fragment, which is the total of the size of its\n  // content nodes.\n\n  this.size = size || 0;\n\n  if (size == null) {\n    for (var i = 0; i < content.length; i++) {\n      this.size += content[i].nodeSize;\n    }\n  }\n};\n\nvar prototypeAccessors = {\n  firstChild: {\n    configurable: true\n  },\n  lastChild: {\n    configurable: true\n  },\n  childCount: {\n    configurable: true\n  }\n}; // :: (number, number, (node: Node, start: number, parent: Node, index: number) → ?bool, ?number)\n// Invoke a callback for all descendant nodes between the given two\n// positions (relative to start of this fragment). Doesn't descend\n// into a node when the callback returns `false`.\n\nFragment.prototype.nodesBetween = function nodesBetween(from, to, f, nodeStart, parent) {\n  if (nodeStart === void 0) nodeStart = 0;\n\n  for (var i = 0, pos = 0; pos < to; i++) {\n    var child = this.content[i],\n        end = pos + child.nodeSize;\n\n    if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {\n      var start = pos + 1;\n      child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);\n    }\n\n    pos = end;\n  }\n}; // :: ((node: Node, pos: number, parent: Node) → ?bool)\n// Call the given callback for every descendant node. The callback\n// may return `false` to prevent traversal of a given node's children.\n\n\nFragment.prototype.descendants = function descendants(f) {\n  this.nodesBetween(0, this.size, f);\n}; // : (number, number, ?string, ?string) → string\n\n\nFragment.prototype.textBetween = function textBetween(from, to, blockSeparator, leafText) {\n  var text = \"\",\n      separated = true;\n  this.nodesBetween(from, to, function (node, pos) {\n    if (node.isText) {\n      text += node.text.slice(Math.max(from, pos) - pos, to - pos);\n      separated = !blockSeparator;\n    } else if (node.isLeaf && leafText) {\n      text += leafText;\n      separated = !blockSeparator;\n    } else if (!separated && node.isBlock) {\n      text += blockSeparator;\n      separated = true;\n    }\n  }, 0);\n  return text;\n}; // :: (Fragment) → Fragment\n// Create a new fragment containing the combined content of this\n// fragment and the other.\n\n\nFragment.prototype.append = function append(other) {\n  if (!other.size) {\n    return this;\n  }\n\n  if (!this.size) {\n    return other;\n  }\n\n  var last = this.lastChild,\n      first = other.firstChild,\n      content = this.content.slice(),\n      i = 0;\n\n  if (last.isText && last.sameMarkup(first)) {\n    content[content.length - 1] = last.withText(last.text + first.text);\n    i = 1;\n  }\n\n  for (; i < other.content.length; i++) {\n    content.push(other.content[i]);\n  }\n\n  return new Fragment(content, this.size + other.size);\n}; // :: (number, ?number) → Fragment\n// Cut out the sub-fragment between the two given positions.\n\n\nFragment.prototype.cut = function cut(from, to) {\n  if (to == null) {\n    to = this.size;\n  }\n\n  if (from == 0 && to == this.size) {\n    return this;\n  }\n\n  var result = [],\n      size = 0;\n\n  if (to > from) {\n    for (var i = 0, pos = 0; pos < to; i++) {\n      var child = this.content[i],\n          end = pos + child.nodeSize;\n\n      if (end > from) {\n        if (pos < from || end > to) {\n          if (child.isText) {\n            child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));\n          } else {\n            child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));\n          }\n        }\n\n        result.push(child);\n        size += child.nodeSize;\n      }\n\n      pos = end;\n    }\n  }\n\n  return new Fragment(result, size);\n};\n\nFragment.prototype.cutByIndex = function cutByIndex(from, to) {\n  if (from == to) {\n    return Fragment.empty;\n  }\n\n  if (from == 0 && to == this.content.length) {\n    return this;\n  }\n\n  return new Fragment(this.content.slice(from, to));\n}; // :: (number, Node) → Fragment\n// Create a new fragment in which the node at the given index is\n// replaced by the given node.\n\n\nFragment.prototype.replaceChild = function replaceChild(index, node) {\n  var current = this.content[index];\n\n  if (current == node) {\n    return this;\n  }\n\n  var copy = this.content.slice();\n  var size = this.size + node.nodeSize - current.nodeSize;\n  copy[index] = node;\n  return new Fragment(copy, size);\n}; // : (Node) → Fragment\n// Create a new fragment by prepending the given node to this\n// fragment.\n\n\nFragment.prototype.addToStart = function addToStart(node) {\n  return new Fragment([node].concat(this.content), this.size + node.nodeSize);\n}; // : (Node) → Fragment\n// Create a new fragment by appending the given node to this\n// fragment.\n\n\nFragment.prototype.addToEnd = function addToEnd(node) {\n  return new Fragment(this.content.concat(node), this.size + node.nodeSize);\n}; // :: (Fragment) → bool\n// Compare this fragment to another one.\n\n\nFragment.prototype.eq = function eq(other) {\n  if (this.content.length != other.content.length) {\n    return false;\n  }\n\n  for (var i = 0; i < this.content.length; i++) {\n    if (!this.content[i].eq(other.content[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}; // :: ?Node\n// The first child of the fragment, or `null` if it is empty.\n\n\nprototypeAccessors.firstChild.get = function () {\n  return this.content.length ? this.content[0] : null;\n}; // :: ?Node\n// The last child of the fragment, or `null` if it is empty.\n\n\nprototypeAccessors.lastChild.get = function () {\n  return this.content.length ? this.content[this.content.length - 1] : null;\n}; // :: number\n// The number of child nodes in this fragment.\n\n\nprototypeAccessors.childCount.get = function () {\n  return this.content.length;\n}; // :: (number) → Node\n// Get the child node at the given index. Raise an error when the\n// index is out of range.\n\n\nFragment.prototype.child = function child(index) {\n  var found = this.content[index];\n\n  if (!found) {\n    throw new RangeError(\"Index \" + index + \" out of range for \" + this);\n  }\n\n  return found;\n}; // :: (number) → ?Node\n// Get the child node at the given index, if it exists.\n\n\nFragment.prototype.maybeChild = function maybeChild(index) {\n  return this.content[index];\n}; // :: ((node: Node, offset: number, index: number))\n// Call `f` for every child node, passing the node, its offset\n// into this parent node, and its index.\n\n\nFragment.prototype.forEach = function forEach(f) {\n  for (var i = 0, p = 0; i < this.content.length; i++) {\n    var child = this.content[i];\n    f(child, p, i);\n    p += child.nodeSize;\n  }\n}; // :: (Fragment) → ?number\n// Find the first position at which this fragment and another\n// fragment differ, or `null` if they are the same.\n\n\nFragment.prototype.findDiffStart = function findDiffStart$1(other, pos) {\n  if (pos === void 0) pos = 0;\n  return findDiffStart(this, other, pos);\n}; // :: (Fragment) → ?{a: number, b: number}\n// Find the first position, searching from the end, at which this\n// fragment and the given fragment differ, or `null` if they are the\n// same. Since this position will not be the same in both nodes, an\n// object with two separate positions is returned.\n\n\nFragment.prototype.findDiffEnd = function findDiffEnd$1(other, pos, otherPos) {\n  if (pos === void 0) pos = this.size;\n  if (otherPos === void 0) otherPos = other.size;\n  return findDiffEnd(this, other, pos, otherPos);\n}; // : (number, ?number) → {index: number, offset: number}\n// Find the index and inner offset corresponding to a given relative\n// position in this fragment. The result object will be reused\n// (overwritten) the next time the function is called. (Not public.)\n\n\nFragment.prototype.findIndex = function findIndex(pos, round) {\n  if (round === void 0) round = -1;\n\n  if (pos == 0) {\n    return retIndex(0, pos);\n  }\n\n  if (pos == this.size) {\n    return retIndex(this.content.length, pos);\n  }\n\n  if (pos > this.size || pos < 0) {\n    throw new RangeError(\"Position \" + pos + \" outside of fragment (\" + this + \")\");\n  }\n\n  for (var i = 0, curPos = 0;; i++) {\n    var cur = this.child(i),\n        end = curPos + cur.nodeSize;\n\n    if (end >= pos) {\n      if (end == pos || round > 0) {\n        return retIndex(i + 1, end);\n      }\n\n      return retIndex(i, curPos);\n    }\n\n    curPos = end;\n  }\n}; // :: () → string\n// Return a debugging string that describes this fragment.\n\n\nFragment.prototype.toString = function toString() {\n  return \"<\" + this.toStringInner() + \">\";\n};\n\nFragment.prototype.toStringInner = function toStringInner() {\n  return this.content.join(\", \");\n}; // :: () → ?Object\n// Create a JSON-serializeable representation of this fragment.\n\n\nFragment.prototype.toJSON = function toJSON() {\n  return this.content.length ? this.content.map(function (n) {\n    return n.toJSON();\n  }) : null;\n}; // :: (Schema, ?Object) → Fragment\n// Deserialize a fragment from its JSON representation.\n\n\nFragment.fromJSON = function fromJSON(schema, value) {\n  if (!value) {\n    return Fragment.empty;\n  }\n\n  if (!Array.isArray(value)) {\n    throw new RangeError(\"Invalid input for Fragment.fromJSON\");\n  }\n\n  return new Fragment(value.map(schema.nodeFromJSON));\n}; // :: ([Node]) → Fragment\n// Build a fragment from an array of nodes. Ensures that adjacent\n// text nodes with the same marks are joined together.\n\n\nFragment.fromArray = function fromArray(array) {\n  if (!array.length) {\n    return Fragment.empty;\n  }\n\n  var joined,\n      size = 0;\n\n  for (var i = 0; i < array.length; i++) {\n    var node = array[i];\n    size += node.nodeSize;\n\n    if (i && node.isText && array[i - 1].sameMarkup(node)) {\n      if (!joined) {\n        joined = array.slice(0, i);\n      }\n\n      joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);\n    } else if (joined) {\n      joined.push(node);\n    }\n  }\n\n  return new Fragment(joined || array, size);\n}; // :: (?union<Fragment, Node, [Node]>) → Fragment\n// Create a fragment from something that can be interpreted as a set\n// of nodes. For `null`, it returns the empty fragment. For a\n// fragment, the fragment itself. For a node or array of nodes, a\n// fragment containing those nodes.\n\n\nFragment.from = function from(nodes) {\n  if (!nodes) {\n    return Fragment.empty;\n  }\n\n  if (nodes instanceof Fragment) {\n    return nodes;\n  }\n\n  if (Array.isArray(nodes)) {\n    return this.fromArray(nodes);\n  }\n\n  if (nodes.attrs) {\n    return new Fragment([nodes], nodes.nodeSize);\n  }\n\n  throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" + (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"));\n};\n\nObject.defineProperties(Fragment.prototype, prototypeAccessors);\nvar found = {\n  index: 0,\n  offset: 0\n};\n\nfunction retIndex(index, offset) {\n  found.index = index;\n  found.offset = offset;\n  return found;\n} // :: Fragment\n// An empty fragment. Intended to be reused whenever a node doesn't\n// contain anything (rather than allocating a new empty fragment for\n// each leaf node).\n\n\nFragment.empty = new Fragment([], 0);\n\nfunction compareDeep(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (!(a && typeof a == \"object\") || !(b && typeof b == \"object\")) {\n    return false;\n  }\n\n  var array = Array.isArray(a);\n\n  if (Array.isArray(b) != array) {\n    return false;\n  }\n\n  if (array) {\n    if (a.length != b.length) {\n      return false;\n    }\n\n    for (var i = 0; i < a.length; i++) {\n      if (!compareDeep(a[i], b[i])) {\n        return false;\n      }\n    }\n  } else {\n    for (var p in a) {\n      if (!(p in b) || !compareDeep(a[p], b[p])) {\n        return false;\n      }\n    }\n\n    for (var p$1 in b) {\n      if (!(p$1 in a)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n} // ::- A mark is a piece of information that can be attached to a node,\n// such as it being emphasized, in code font, or a link. It has a type\n// and optionally a set of attributes that provide further information\n// (such as the target of the link). Marks are created through a\n// `Schema`, which controls which types exist and which\n// attributes they have.\n\n\nvar Mark = function Mark(type, attrs) {\n  // :: MarkType\n  // The type of this mark.\n  this.type = type; // :: Object\n  // The attributes associated with this mark.\n\n  this.attrs = attrs;\n}; // :: ([Mark]) → [Mark]\n// Given a set of marks, create a new set which contains this one as\n// well, in the right position. If this mark is already in the set,\n// the set itself is returned. If any marks that are set to be\n// [exclusive](#model.MarkSpec.excludes) with this mark are present,\n// those are replaced by this one.\n\n\nMark.prototype.addToSet = function addToSet(set) {\n  var copy,\n      placed = false;\n\n  for (var i = 0; i < set.length; i++) {\n    var other = set[i];\n\n    if (this.eq(other)) {\n      return set;\n    }\n\n    if (this.type.excludes(other.type)) {\n      if (!copy) {\n        copy = set.slice(0, i);\n      }\n    } else if (other.type.excludes(this.type)) {\n      return set;\n    } else {\n      if (!placed && other.type.rank > this.type.rank) {\n        if (!copy) {\n          copy = set.slice(0, i);\n        }\n\n        copy.push(this);\n        placed = true;\n      }\n\n      if (copy) {\n        copy.push(other);\n      }\n    }\n  }\n\n  if (!copy) {\n    copy = set.slice();\n  }\n\n  if (!placed) {\n    copy.push(this);\n  }\n\n  return copy;\n}; // :: ([Mark]) → [Mark]\n// Remove this mark from the given set, returning a new set. If this\n// mark is not in the set, the set itself is returned.\n\n\nMark.prototype.removeFromSet = function removeFromSet(set) {\n  for (var i = 0; i < set.length; i++) {\n    if (this.eq(set[i])) {\n      return set.slice(0, i).concat(set.slice(i + 1));\n    }\n  }\n\n  return set;\n}; // :: ([Mark]) → bool\n// Test whether this mark is in the given set of marks.\n\n\nMark.prototype.isInSet = function isInSet(set) {\n  for (var i = 0; i < set.length; i++) {\n    if (this.eq(set[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}; // :: (Mark) → bool\n// Test whether this mark has the same type and attributes as\n// another mark.\n\n\nMark.prototype.eq = function eq(other) {\n  return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);\n}; // :: () → Object\n// Convert this mark to a JSON-serializeable representation.\n\n\nMark.prototype.toJSON = function toJSON() {\n  var obj = {\n    type: this.type.name\n  };\n\n  for (var _ in this.attrs) {\n    obj.attrs = this.attrs;\n    break;\n  }\n\n  return obj;\n}; // :: (Schema, Object) → Mark\n\n\nMark.fromJSON = function fromJSON(schema, json) {\n  if (!json) {\n    throw new RangeError(\"Invalid input for Mark.fromJSON\");\n  }\n\n  var type = schema.marks[json.type];\n\n  if (!type) {\n    throw new RangeError(\"There is no mark type \" + json.type + \" in this schema\");\n  }\n\n  return type.create(json.attrs);\n}; // :: ([Mark], [Mark]) → bool\n// Test whether two sets of marks are identical.\n\n\nMark.sameSet = function sameSet(a, b) {\n  if (a == b) {\n    return true;\n  }\n\n  if (a.length != b.length) {\n    return false;\n  }\n\n  for (var i = 0; i < a.length; i++) {\n    if (!a[i].eq(b[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}; // :: (?union<Mark, [Mark]>) → [Mark]\n// Create a properly sorted mark set from null, a single mark, or an\n// unsorted array of marks.\n\n\nMark.setFrom = function setFrom(marks) {\n  if (!marks || marks.length == 0) {\n    return Mark.none;\n  }\n\n  if (marks instanceof Mark) {\n    return [marks];\n  }\n\n  var copy = marks.slice();\n  copy.sort(function (a, b) {\n    return a.type.rank - b.type.rank;\n  });\n  return copy;\n}; // :: [Mark] The empty set of marks.\n\n\nMark.none = []; // ReplaceError:: class extends Error\n// Error type raised by [`Node.replace`](#model.Node.replace) when\n// given an invalid replacement.\n\nfunction ReplaceError(message) {\n  var err = Error.call(this, message);\n  err.__proto__ = ReplaceError.prototype;\n  return err;\n}\n\nReplaceError.prototype = Object.create(Error.prototype);\nReplaceError.prototype.constructor = ReplaceError;\nReplaceError.prototype.name = \"ReplaceError\"; // ::- A slice represents a piece cut out of a larger document. It\n// stores not only a fragment, but also the depth up to which nodes on\n// both side are ‘open’ (cut through).\n\nvar Slice = function Slice(content, openStart, openEnd) {\n  // :: Fragment The slice's content.\n  this.content = content; // :: number The open depth at the start.\n\n  this.openStart = openStart; // :: number The open depth at the end.\n\n  this.openEnd = openEnd;\n};\n\nvar prototypeAccessors$1 = {\n  size: {\n    configurable: true\n  }\n}; // :: number\n// The size this slice would add when inserted into a document.\n\nprototypeAccessors$1.size.get = function () {\n  return this.content.size - this.openStart - this.openEnd;\n};\n\nSlice.prototype.insertAt = function insertAt(pos, fragment) {\n  var content = insertInto(this.content, pos + this.openStart, fragment, null);\n  return content && new Slice(content, this.openStart, this.openEnd);\n};\n\nSlice.prototype.removeBetween = function removeBetween(from, to) {\n  return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);\n}; // :: (Slice) → bool\n// Tests whether this slice is equal to another slice.\n\n\nSlice.prototype.eq = function eq(other) {\n  return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;\n};\n\nSlice.prototype.toString = function toString() {\n  return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\";\n}; // :: () → ?Object\n// Convert a slice to a JSON-serializable representation.\n\n\nSlice.prototype.toJSON = function toJSON() {\n  if (!this.content.size) {\n    return null;\n  }\n\n  var json = {\n    content: this.content.toJSON()\n  };\n\n  if (this.openStart > 0) {\n    json.openStart = this.openStart;\n  }\n\n  if (this.openEnd > 0) {\n    json.openEnd = this.openEnd;\n  }\n\n  return json;\n}; // :: (Schema, ?Object) → Slice\n// Deserialize a slice from its JSON representation.\n\n\nSlice.fromJSON = function fromJSON(schema, json) {\n  if (!json) {\n    return Slice.empty;\n  }\n\n  var openStart = json.openStart || 0,\n      openEnd = json.openEnd || 0;\n\n  if (typeof openStart != \"number\" || typeof openEnd != \"number\") {\n    throw new RangeError(\"Invalid input for Slice.fromJSON\");\n  }\n\n  return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);\n}; // :: (Fragment, ?bool) → Slice\n// Create a slice from a fragment by taking the maximum possible\n// open value on both side of the fragment.\n\n\nSlice.maxOpen = function maxOpen(fragment, openIsolating) {\n  if (openIsolating === void 0) openIsolating = true;\n  var openStart = 0,\n      openEnd = 0;\n\n  for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) {\n    openStart++;\n  }\n\n  for (var n$1 = fragment.lastChild; n$1 && !n$1.isLeaf && (openIsolating || !n$1.type.spec.isolating); n$1 = n$1.lastChild) {\n    openEnd++;\n  }\n\n  return new Slice(fragment, openStart, openEnd);\n};\n\nObject.defineProperties(Slice.prototype, prototypeAccessors$1);\n\nfunction removeRange(content, from, to) {\n  var ref = content.findIndex(from);\n  var index = ref.index;\n  var offset = ref.offset;\n  var child = content.maybeChild(index);\n  var ref$1 = content.findIndex(to);\n  var indexTo = ref$1.index;\n  var offsetTo = ref$1.offset;\n\n  if (offset == from || child.isText) {\n    if (offsetTo != to && !content.child(indexTo).isText) {\n      throw new RangeError(\"Removing non-flat range\");\n    }\n\n    return content.cut(0, from).append(content.cut(to));\n  }\n\n  if (index != indexTo) {\n    throw new RangeError(\"Removing non-flat range\");\n  }\n\n  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));\n}\n\nfunction insertInto(content, dist, insert, parent) {\n  var ref = content.findIndex(dist);\n  var index = ref.index;\n  var offset = ref.offset;\n  var child = content.maybeChild(index);\n\n  if (offset == dist || child.isText) {\n    if (parent && !parent.canReplace(index, index, insert)) {\n      return null;\n    }\n\n    return content.cut(0, dist).append(insert).append(content.cut(dist));\n  }\n\n  var inner = insertInto(child.content, dist - offset - 1, insert);\n  return inner && content.replaceChild(index, child.copy(inner));\n} // :: Slice\n// The empty slice.\n\n\nSlice.empty = new Slice(Fragment.empty, 0, 0);\n\nfunction replace($from, $to, slice) {\n  if (slice.openStart > $from.depth) {\n    throw new ReplaceError(\"Inserted content deeper than insertion position\");\n  }\n\n  if ($from.depth - slice.openStart != $to.depth - slice.openEnd) {\n    throw new ReplaceError(\"Inconsistent open depths\");\n  }\n\n  return replaceOuter($from, $to, slice, 0);\n}\n\nfunction replaceOuter($from, $to, slice, depth) {\n  var index = $from.index(depth),\n      node = $from.node(depth);\n\n  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n    var inner = replaceOuter($from, $to, slice, depth + 1);\n    return node.copy(node.content.replaceChild(index, inner));\n  } else if (!slice.content.size) {\n    return close(node, replaceTwoWay($from, $to, depth));\n  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {\n    // Simple, flat case\n    var parent = $from.parent,\n        content = parent.content;\n    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));\n  } else {\n    var ref = prepareSliceForReplace(slice, $from);\n    var start = ref.start;\n    var end = ref.end;\n    return close(node, replaceThreeWay($from, start, end, $to, depth));\n  }\n}\n\nfunction checkJoin(main, sub) {\n  if (!sub.type.compatibleContent(main.type)) {\n    throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name);\n  }\n}\n\nfunction joinable($before, $after, depth) {\n  var node = $before.node(depth);\n  checkJoin(node, $after.node(depth));\n  return node;\n}\n\nfunction addNode(child, target) {\n  var last = target.length - 1;\n\n  if (last >= 0 && child.isText && child.sameMarkup(target[last])) {\n    target[last] = child.withText(target[last].text + child.text);\n  } else {\n    target.push(child);\n  }\n}\n\nfunction addRange($start, $end, depth, target) {\n  var node = ($end || $start).node(depth);\n  var startIndex = 0,\n      endIndex = $end ? $end.index(depth) : node.childCount;\n\n  if ($start) {\n    startIndex = $start.index(depth);\n\n    if ($start.depth > depth) {\n      startIndex++;\n    } else if ($start.textOffset) {\n      addNode($start.nodeAfter, target);\n      startIndex++;\n    }\n  }\n\n  for (var i = startIndex; i < endIndex; i++) {\n    addNode(node.child(i), target);\n  }\n\n  if ($end && $end.depth == depth && $end.textOffset) {\n    addNode($end.nodeBefore, target);\n  }\n}\n\nfunction close(node, content) {\n  if (!node.type.validContent(content)) {\n    throw new ReplaceError(\"Invalid content for node \" + node.type.name);\n  }\n\n  return node.copy(content);\n}\n\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n  var openStart = $from.depth > depth && joinable($from, $start, depth + 1);\n  var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);\n  var content = [];\n  addRange(null, $from, depth, content);\n\n  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n    checkJoin(openStart, openEnd);\n    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);\n  } else {\n    if (openStart) {\n      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);\n    }\n\n    addRange($start, $end, depth, content);\n\n    if (openEnd) {\n      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);\n    }\n  }\n\n  addRange($to, null, depth, content);\n  return new Fragment(content);\n}\n\nfunction replaceTwoWay($from, $to, depth) {\n  var content = [];\n  addRange(null, $from, depth, content);\n\n  if ($from.depth > depth) {\n    var type = joinable($from, $to, depth + 1);\n    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);\n  }\n\n  addRange($to, null, depth, content);\n  return new Fragment(content);\n}\n\nfunction prepareSliceForReplace(slice, $along) {\n  var extra = $along.depth - slice.openStart,\n      parent = $along.node(extra);\n  var node = parent.copy(slice.content);\n\n  for (var i = extra - 1; i >= 0; i--) {\n    node = $along.node(i).copy(Fragment.from(node));\n  }\n\n  return {\n    start: node.resolveNoCache(slice.openStart + extra),\n    end: node.resolveNoCache(node.content.size - slice.openEnd - extra)\n  };\n} // ::- You can [_resolve_](#model.Node.resolve) a position to get more\n// information about it. Objects of this class represent such a\n// resolved position, providing various pieces of context information,\n// and some helper methods.\n//\n// Throughout this interface, methods that take an optional `depth`\n// parameter will interpret undefined as `this.depth` and negative\n// numbers as `this.depth + value`.\n\n\nvar ResolvedPos = function ResolvedPos(pos, path, parentOffset) {\n  // :: number The position that was resolved.\n  this.pos = pos;\n  this.path = path; // :: number\n  // The number of levels the parent node is from the root. If this\n  // position points directly into the root node, it is 0. If it\n  // points into a top-level paragraph, 1, and so on.\n\n  this.depth = path.length / 3 - 1; // :: number The offset this position has into its parent node.\n\n  this.parentOffset = parentOffset;\n};\n\nvar prototypeAccessors$2 = {\n  parent: {\n    configurable: true\n  },\n  doc: {\n    configurable: true\n  },\n  textOffset: {\n    configurable: true\n  },\n  nodeAfter: {\n    configurable: true\n  },\n  nodeBefore: {\n    configurable: true\n  }\n};\n\nResolvedPos.prototype.resolveDepth = function resolveDepth(val) {\n  if (val == null) {\n    return this.depth;\n  }\n\n  if (val < 0) {\n    return this.depth + val;\n  }\n\n  return val;\n}; // :: Node\n// The parent node that the position points into. Note that even if\n// a position points into a text node, that node is not considered\n// the parent—text nodes are ‘flat’ in this model, and have no content.\n\n\nprototypeAccessors$2.parent.get = function () {\n  return this.node(this.depth);\n}; // :: Node\n// The root node in which the position was resolved.\n\n\nprototypeAccessors$2.doc.get = function () {\n  return this.node(0);\n}; // :: (?number) → Node\n// The ancestor node at the given level. `p.node(p.depth)` is the\n// same as `p.parent`.\n\n\nResolvedPos.prototype.node = function node(depth) {\n  return this.path[this.resolveDepth(depth) * 3];\n}; // :: (?number) → number\n// The index into the ancestor at the given level. If this points at\n// the 3rd node in the 2nd paragraph on the top level, for example,\n// `p.index(0)` is 1 and `p.index(1)` is 2.\n\n\nResolvedPos.prototype.index = function index(depth) {\n  return this.path[this.resolveDepth(depth) * 3 + 1];\n}; // :: (?number) → number\n// The index pointing after this position into the ancestor at the\n// given level.\n\n\nResolvedPos.prototype.indexAfter = function indexAfter(depth) {\n  depth = this.resolveDepth(depth);\n  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);\n}; // :: (?number) → number\n// The (absolute) position at the start of the node at the given\n// level.\n\n\nResolvedPos.prototype.start = function start(depth) {\n  depth = this.resolveDepth(depth);\n  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n}; // :: (?number) → number\n// The (absolute) position at the end of the node at the given\n// level.\n\n\nResolvedPos.prototype.end = function end(depth) {\n  depth = this.resolveDepth(depth);\n  return this.start(depth) + this.node(depth).content.size;\n}; // :: (?number) → number\n// The (absolute) position directly before the wrapping node at the\n// given level, or, when `depth` is `this.depth + 1`, the original\n// position.\n\n\nResolvedPos.prototype.before = function before(depth) {\n  depth = this.resolveDepth(depth);\n\n  if (!depth) {\n    throw new RangeError(\"There is no position before the top-level node\");\n  }\n\n  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];\n}; // :: (?number) → number\n// The (absolute) position directly after the wrapping node at the\n// given level, or the original position when `depth` is `this.depth + 1`.\n\n\nResolvedPos.prototype.after = function after(depth) {\n  depth = this.resolveDepth(depth);\n\n  if (!depth) {\n    throw new RangeError(\"There is no position after the top-level node\");\n  }\n\n  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;\n}; // :: number\n// When this position points into a text node, this returns the\n// distance between the position and the start of the text node.\n// Will be zero for positions that point between nodes.\n\n\nprototypeAccessors$2.textOffset.get = function () {\n  return this.pos - this.path[this.path.length - 1];\n}; // :: ?Node\n// Get the node directly after the position, if any. If the position\n// points into a text node, only the part of that node after the\n// position is returned.\n\n\nprototypeAccessors$2.nodeAfter.get = function () {\n  var parent = this.parent,\n      index = this.index(this.depth);\n\n  if (index == parent.childCount) {\n    return null;\n  }\n\n  var dOff = this.pos - this.path[this.path.length - 1],\n      child = parent.child(index);\n  return dOff ? parent.child(index).cut(dOff) : child;\n}; // :: ?Node\n// Get the node directly before the position, if any. If the\n// position points into a text node, only the part of that node\n// before the position is returned.\n\n\nprototypeAccessors$2.nodeBefore.get = function () {\n  var index = this.index(this.depth);\n  var dOff = this.pos - this.path[this.path.length - 1];\n\n  if (dOff) {\n    return this.parent.child(index).cut(0, dOff);\n  }\n\n  return index == 0 ? null : this.parent.child(index - 1);\n}; // :: (number, ?number) → number\n// Get the position at the given index in the parent node at the\n// given depth (which defaults to `this.depth`).\n\n\nResolvedPos.prototype.posAtIndex = function posAtIndex(index, depth) {\n  depth = this.resolveDepth(depth);\n  var node = this.path[depth * 3],\n      pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n\n  for (var i = 0; i < index; i++) {\n    pos += node.child(i).nodeSize;\n  }\n\n  return pos;\n}; // :: () → [Mark]\n// Get the marks at this position, factoring in the surrounding\n// marks' [`inclusive`](#model.MarkSpec.inclusive) property. If the\n// position is at the start of a non-empty node, the marks of the\n// node after it (if any) are returned.\n\n\nResolvedPos.prototype.marks = function marks() {\n  var parent = this.parent,\n      index = this.index(); // In an empty parent, return the empty array\n\n  if (parent.content.size == 0) {\n    return Mark.none;\n  } // When inside a text node, just return the text node's marks\n\n\n  if (this.textOffset) {\n    return parent.child(index).marks;\n  }\n\n  var main = parent.maybeChild(index - 1),\n      other = parent.maybeChild(index); // If the `after` flag is true of there is no node before, make\n  // the node after this position the main reference.\n\n  if (!main) {\n    var tmp = main;\n    main = other;\n    other = tmp;\n  } // Use all marks in the main node, except those that have\n  // `inclusive` set to false and are not present in the other node.\n\n\n  var marks = main.marks;\n\n  for (var i = 0; i < marks.length; i++) {\n    if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks))) {\n      marks = marks[i--].removeFromSet(marks);\n    }\n  }\n\n  return marks;\n}; // :: (ResolvedPos) → ?[Mark]\n// Get the marks after the current position, if any, except those\n// that are non-inclusive and not present at position `$end`. This\n// is mostly useful for getting the set of marks to preserve after a\n// deletion. Will return `null` if this position is at the end of\n// its parent node or its parent node isn't a textblock (in which\n// case no marks should be preserved).\n\n\nResolvedPos.prototype.marksAcross = function marksAcross($end) {\n  var after = this.parent.maybeChild(this.index());\n\n  if (!after || !after.isInline) {\n    return null;\n  }\n\n  var marks = after.marks,\n      next = $end.parent.maybeChild($end.index());\n\n  for (var i = 0; i < marks.length; i++) {\n    if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks))) {\n      marks = marks[i--].removeFromSet(marks);\n    }\n  }\n\n  return marks;\n}; // :: (number) → number\n// The depth up to which this position and the given (non-resolved)\n// position share the same parent nodes.\n\n\nResolvedPos.prototype.sharedDepth = function sharedDepth(pos) {\n  for (var depth = this.depth; depth > 0; depth--) {\n    if (this.start(depth) <= pos && this.end(depth) >= pos) {\n      return depth;\n    }\n  }\n\n  return 0;\n}; // :: (?ResolvedPos, ?(Node) → bool) → ?NodeRange\n// Returns a range based on the place where this position and the\n// given position diverge around block content. If both point into\n// the same textblock, for example, a range around that textblock\n// will be returned. If they point into different blocks, the range\n// around those blocks in their shared ancestor is returned. You can\n// pass in an optional predicate that will be called with a parent\n// node to see if a range into that parent is acceptable.\n\n\nResolvedPos.prototype.blockRange = function blockRange(other, pred) {\n  if (other === void 0) other = this;\n\n  if (other.pos < this.pos) {\n    return other.blockRange(this);\n  }\n\n  for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) {\n    if (other.pos <= this.end(d) && (!pred || pred(this.node(d)))) {\n      return new NodeRange(this, other, d);\n    }\n  }\n}; // :: (ResolvedPos) → bool\n// Query whether the given position shares the same parent node.\n\n\nResolvedPos.prototype.sameParent = function sameParent(other) {\n  return this.pos - this.parentOffset == other.pos - other.parentOffset;\n}; // :: (ResolvedPos) → ResolvedPos\n// Return the greater of this and the given position.\n\n\nResolvedPos.prototype.max = function max(other) {\n  return other.pos > this.pos ? other : this;\n}; // :: (ResolvedPos) → ResolvedPos\n// Return the smaller of this and the given position.\n\n\nResolvedPos.prototype.min = function min(other) {\n  return other.pos < this.pos ? other : this;\n};\n\nResolvedPos.prototype.toString = function toString() {\n  var str = \"\";\n\n  for (var i = 1; i <= this.depth; i++) {\n    str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1);\n  }\n\n  return str + \":\" + this.parentOffset;\n};\n\nResolvedPos.resolve = function resolve(doc, pos) {\n  if (!(pos >= 0 && pos <= doc.content.size)) {\n    throw new RangeError(\"Position \" + pos + \" out of range\");\n  }\n\n  var path = [];\n  var start = 0,\n      parentOffset = pos;\n\n  for (var node = doc;;) {\n    var ref = node.content.findIndex(parentOffset);\n    var index = ref.index;\n    var offset = ref.offset;\n    var rem = parentOffset - offset;\n    path.push(node, index, start + offset);\n\n    if (!rem) {\n      break;\n    }\n\n    node = node.child(index);\n\n    if (node.isText) {\n      break;\n    }\n\n    parentOffset = rem - 1;\n    start += offset + 1;\n  }\n\n  return new ResolvedPos(pos, path, parentOffset);\n};\n\nResolvedPos.resolveCached = function resolveCached(doc, pos) {\n  for (var i = 0; i < resolveCache.length; i++) {\n    var cached = resolveCache[i];\n\n    if (cached.pos == pos && cached.doc == doc) {\n      return cached;\n    }\n  }\n\n  var result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos);\n  resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;\n  return result;\n};\n\nObject.defineProperties(ResolvedPos.prototype, prototypeAccessors$2);\nvar resolveCache = [],\n    resolveCachePos = 0,\n    resolveCacheSize = 12; // ::- Represents a flat range of content, i.e. one that starts and\n// ends in the same node.\n\nvar NodeRange = function NodeRange($from, $to, depth) {\n  // :: ResolvedPos A resolved position along the start of the\n  // content. May have a `depth` greater than this object's `depth`\n  // property, since these are the positions that were used to\n  // compute the range, not re-resolved positions directly at its\n  // boundaries.\n  this.$from = $from; // :: ResolvedPos A position along the end of the content. See\n  // caveat for [`$from`](#model.NodeRange.$from).\n\n  this.$to = $to; // :: number The depth of the node that this range points into.\n\n  this.depth = depth;\n};\n\nvar prototypeAccessors$1$1 = {\n  start: {\n    configurable: true\n  },\n  end: {\n    configurable: true\n  },\n  parent: {\n    configurable: true\n  },\n  startIndex: {\n    configurable: true\n  },\n  endIndex: {\n    configurable: true\n  }\n}; // :: number The position at the start of the range.\n\nprototypeAccessors$1$1.start.get = function () {\n  return this.$from.before(this.depth + 1);\n}; // :: number The position at the end of the range.\n\n\nprototypeAccessors$1$1.end.get = function () {\n  return this.$to.after(this.depth + 1);\n}; // :: Node The parent node that the range points into.\n\n\nprototypeAccessors$1$1.parent.get = function () {\n  return this.$from.node(this.depth);\n}; // :: number The start index of the range in the parent node.\n\n\nprototypeAccessors$1$1.startIndex.get = function () {\n  return this.$from.index(this.depth);\n}; // :: number The end index of the range in the parent node.\n\n\nprototypeAccessors$1$1.endIndex.get = function () {\n  return this.$to.indexAfter(this.depth);\n};\n\nObject.defineProperties(NodeRange.prototype, prototypeAccessors$1$1);\nvar emptyAttrs = Object.create(null); // ::- This class represents a node in the tree that makes up a\n// ProseMirror document. So a document is an instance of `Node`, with\n// children that are also instances of `Node`.\n//\n// Nodes are persistent data structures. Instead of changing them, you\n// create new ones with the content you want. Old ones keep pointing\n// at the old document shape. This is made cheaper by sharing\n// structure between the old and new data as much as possible, which a\n// tree shape like this (without back pointers) makes easy.\n//\n// **Do not** directly mutate the properties of a `Node` object. See\n// [the guide](/docs/guide/#doc) for more information.\n\nvar Node = function Node(type, attrs, content, marks) {\n  // :: NodeType\n  // The type of node that this is.\n  this.type = type; // :: Object\n  // An object mapping attribute names to values. The kind of\n  // attributes allowed and required are\n  // [determined](#model.NodeSpec.attrs) by the node type.\n\n  this.attrs = attrs; // :: Fragment\n  // A container holding the node's children.\n\n  this.content = content || Fragment.empty; // :: [Mark]\n  // The marks (things like whether it is emphasized or part of a\n  // link) applied to this node.\n\n  this.marks = marks || Mark.none;\n};\n\nvar prototypeAccessors$3 = {\n  nodeSize: {\n    configurable: true\n  },\n  childCount: {\n    configurable: true\n  },\n  textContent: {\n    configurable: true\n  },\n  firstChild: {\n    configurable: true\n  },\n  lastChild: {\n    configurable: true\n  },\n  isBlock: {\n    configurable: true\n  },\n  isTextblock: {\n    configurable: true\n  },\n  inlineContent: {\n    configurable: true\n  },\n  isInline: {\n    configurable: true\n  },\n  isText: {\n    configurable: true\n  },\n  isLeaf: {\n    configurable: true\n  },\n  isAtom: {\n    configurable: true\n  }\n}; // text:: ?string\n// For text nodes, this contains the node's text content.\n// :: number\n// The size of this node, as defined by the integer-based [indexing\n// scheme](/docs/guide/#doc.indexing). For text nodes, this is the\n// amount of characters. For other leaf nodes, it is one. For\n// non-leaf nodes, it is the size of the content plus two (the start\n// and end token).\n\nprototypeAccessors$3.nodeSize.get = function () {\n  return this.isLeaf ? 1 : 2 + this.content.size;\n}; // :: number\n// The number of children that the node has.\n\n\nprototypeAccessors$3.childCount.get = function () {\n  return this.content.childCount;\n}; // :: (number) → Node\n// Get the child node at the given index. Raises an error when the\n// index is out of range.\n\n\nNode.prototype.child = function child(index) {\n  return this.content.child(index);\n}; // :: (number) → ?Node\n// Get the child node at the given index, if it exists.\n\n\nNode.prototype.maybeChild = function maybeChild(index) {\n  return this.content.maybeChild(index);\n}; // :: ((node: Node, offset: number, index: number))\n// Call `f` for every child node, passing the node, its offset\n// into this parent node, and its index.\n\n\nNode.prototype.forEach = function forEach(f) {\n  this.content.forEach(f);\n}; // :: (number, number, (node: Node, pos: number, parent: Node, index: number) → ?bool, ?number)\n// Invoke a callback for all descendant nodes recursively between\n// the given two positions that are relative to start of this node's\n// content. The callback is invoked with the node, its\n// parent-relative position, its parent node, and its child index.\n// When the callback returns false for a given node, that node's\n// children will not be recursed over. The last parameter can be\n// used to specify a starting position to count from.\n\n\nNode.prototype.nodesBetween = function nodesBetween(from, to, f, startPos) {\n  if (startPos === void 0) startPos = 0;\n  this.content.nodesBetween(from, to, f, startPos, this);\n}; // :: ((node: Node, pos: number, parent: Node) → ?bool)\n// Call the given callback for every descendant node. Doesn't\n// descend into a node when the callback returns `false`.\n\n\nNode.prototype.descendants = function descendants(f) {\n  this.nodesBetween(0, this.content.size, f);\n}; // :: string\n// Concatenates all the text nodes found in this fragment and its\n// children.\n\n\nprototypeAccessors$3.textContent.get = function () {\n  return this.textBetween(0, this.content.size, \"\");\n}; // :: (number, number, ?string, ?string) → string\n// Get all text between positions `from` and `to`. When\n// `blockSeparator` is given, it will be inserted whenever a new\n// block node is started. When `leafText` is given, it'll be\n// inserted for every non-text leaf node encountered.\n\n\nNode.prototype.textBetween = function textBetween(from, to, blockSeparator, leafText) {\n  return this.content.textBetween(from, to, blockSeparator, leafText);\n}; // :: ?Node\n// Returns this node's first child, or `null` if there are no\n// children.\n\n\nprototypeAccessors$3.firstChild.get = function () {\n  return this.content.firstChild;\n}; // :: ?Node\n// Returns this node's last child, or `null` if there are no\n// children.\n\n\nprototypeAccessors$3.lastChild.get = function () {\n  return this.content.lastChild;\n}; // :: (Node) → bool\n// Test whether two nodes represent the same piece of document.\n\n\nNode.prototype.eq = function eq(other) {\n  return this == other || this.sameMarkup(other) && this.content.eq(other.content);\n}; // :: (Node) → bool\n// Compare the markup (type, attributes, and marks) of this node to\n// those of another. Returns `true` if both have the same markup.\n\n\nNode.prototype.sameMarkup = function sameMarkup(other) {\n  return this.hasMarkup(other.type, other.attrs, other.marks);\n}; // :: (NodeType, ?Object, ?[Mark]) → bool\n// Check whether this node's markup correspond to the given type,\n// attributes, and marks.\n\n\nNode.prototype.hasMarkup = function hasMarkup(type, attrs, marks) {\n  return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);\n}; // :: (?Fragment) → Node\n// Create a new node with the same markup as this node, containing\n// the given content (or empty, if no content is given).\n\n\nNode.prototype.copy = function copy(content) {\n  if (content === void 0) content = null;\n\n  if (content == this.content) {\n    return this;\n  }\n\n  return new this.constructor(this.type, this.attrs, content, this.marks);\n}; // :: ([Mark]) → Node\n// Create a copy of this node, with the given set of marks instead\n// of the node's own marks.\n\n\nNode.prototype.mark = function mark(marks) {\n  return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks);\n}; // :: (number, ?number) → Node\n// Create a copy of this node with only the content between the\n// given positions. If `to` is not given, it defaults to the end of\n// the node.\n\n\nNode.prototype.cut = function cut(from, to) {\n  if (from == 0 && to == this.content.size) {\n    return this;\n  }\n\n  return this.copy(this.content.cut(from, to));\n}; // :: (number, ?number) → Slice\n// Cut out the part of the document between the given positions, and\n// return it as a `Slice` object.\n\n\nNode.prototype.slice = function slice(from, to, includeParents) {\n  if (to === void 0) to = this.content.size;\n  if (includeParents === void 0) includeParents = false;\n\n  if (from == to) {\n    return Slice.empty;\n  }\n\n  var $from = this.resolve(from),\n      $to = this.resolve(to);\n  var depth = includeParents ? 0 : $from.sharedDepth(to);\n  var start = $from.start(depth),\n      node = $from.node(depth);\n  var content = node.content.cut($from.pos - start, $to.pos - start);\n  return new Slice(content, $from.depth - depth, $to.depth - depth);\n}; // :: (number, number, Slice) → Node\n// Replace the part of the document between the given positions with\n// the given slice. The slice must 'fit', meaning its open sides\n// must be able to connect to the surrounding content, and its\n// content nodes must be valid children for the node they are placed\n// into. If any of this is violated, an error of type\n// [`ReplaceError`](#model.ReplaceError) is thrown.\n\n\nNode.prototype.replace = function replace$1(from, to, slice) {\n  return replace(this.resolve(from), this.resolve(to), slice);\n}; // :: (number) → ?Node\n// Find the node directly after the given position.\n\n\nNode.prototype.nodeAt = function nodeAt(pos) {\n  for (var node = this;;) {\n    var ref = node.content.findIndex(pos);\n    var index = ref.index;\n    var offset = ref.offset;\n    node = node.maybeChild(index);\n\n    if (!node) {\n      return null;\n    }\n\n    if (offset == pos || node.isText) {\n      return node;\n    }\n\n    pos -= offset + 1;\n  }\n}; // :: (number) → {node: ?Node, index: number, offset: number}\n// Find the (direct) child node after the given offset, if any,\n// and return it along with its index and offset relative to this\n// node.\n\n\nNode.prototype.childAfter = function childAfter(pos) {\n  var ref = this.content.findIndex(pos);\n  var index = ref.index;\n  var offset = ref.offset;\n  return {\n    node: this.content.maybeChild(index),\n    index: index,\n    offset: offset\n  };\n}; // :: (number) → {node: ?Node, index: number, offset: number}\n// Find the (direct) child node before the given offset, if any,\n// and return it along with its index and offset relative to this\n// node.\n\n\nNode.prototype.childBefore = function childBefore(pos) {\n  if (pos == 0) {\n    return {\n      node: null,\n      index: 0,\n      offset: 0\n    };\n  }\n\n  var ref = this.content.findIndex(pos);\n  var index = ref.index;\n  var offset = ref.offset;\n\n  if (offset < pos) {\n    return {\n      node: this.content.child(index),\n      index: index,\n      offset: offset\n    };\n  }\n\n  var node = this.content.child(index - 1);\n  return {\n    node: node,\n    index: index - 1,\n    offset: offset - node.nodeSize\n  };\n}; // :: (number) → ResolvedPos\n// Resolve the given position in the document, returning an\n// [object](#model.ResolvedPos) with information about its context.\n\n\nNode.prototype.resolve = function resolve(pos) {\n  return ResolvedPos.resolveCached(this, pos);\n};\n\nNode.prototype.resolveNoCache = function resolveNoCache(pos) {\n  return ResolvedPos.resolve(this, pos);\n}; // :: (number, number, union<Mark, MarkType>) → bool\n// Test whether a given mark or mark type occurs in this document\n// between the two given positions.\n\n\nNode.prototype.rangeHasMark = function rangeHasMark(from, to, type) {\n  var found = false;\n\n  if (to > from) {\n    this.nodesBetween(from, to, function (node) {\n      if (type.isInSet(node.marks)) {\n        found = true;\n      }\n\n      return !found;\n    });\n  }\n\n  return found;\n}; // :: bool\n// True when this is a block (non-inline node)\n\n\nprototypeAccessors$3.isBlock.get = function () {\n  return this.type.isBlock;\n}; // :: bool\n// True when this is a textblock node, a block node with inline\n// content.\n\n\nprototypeAccessors$3.isTextblock.get = function () {\n  return this.type.isTextblock;\n}; // :: bool\n// True when this node allows inline content.\n\n\nprototypeAccessors$3.inlineContent.get = function () {\n  return this.type.inlineContent;\n}; // :: bool\n// True when this is an inline node (a text node or a node that can\n// appear among text).\n\n\nprototypeAccessors$3.isInline.get = function () {\n  return this.type.isInline;\n}; // :: bool\n// True when this is a text node.\n\n\nprototypeAccessors$3.isText.get = function () {\n  return this.type.isText;\n}; // :: bool\n// True when this is a leaf node.\n\n\nprototypeAccessors$3.isLeaf.get = function () {\n  return this.type.isLeaf;\n}; // :: bool\n// True when this is an atom, i.e. when it does not have directly\n// editable content. This is usually the same as `isLeaf`, but can\n// be configured with the [`atom` property](#model.NodeSpec.atom) on\n// a node's spec (typically used when the node is displayed as an\n// uneditable [node view](#view.NodeView)).\n\n\nprototypeAccessors$3.isAtom.get = function () {\n  return this.type.isAtom;\n}; // :: () → string\n// Return a string representation of this node for debugging\n// purposes.\n\n\nNode.prototype.toString = function toString() {\n  if (this.type.spec.toDebugString) {\n    return this.type.spec.toDebugString(this);\n  }\n\n  var name = this.type.name;\n\n  if (this.content.size) {\n    name += \"(\" + this.content.toStringInner() + \")\";\n  }\n\n  return wrapMarks(this.marks, name);\n}; // :: (number) → ContentMatch\n// Get the content match in this node at the given index.\n\n\nNode.prototype.contentMatchAt = function contentMatchAt(index) {\n  var match = this.type.contentMatch.matchFragment(this.content, 0, index);\n\n  if (!match) {\n    throw new Error(\"Called contentMatchAt on a node with invalid content\");\n  }\n\n  return match;\n}; // :: (number, number, ?Fragment, ?number, ?number) → bool\n// Test whether replacing the range between `from` and `to` (by\n// child index) with the given replacement fragment (which defaults\n// to the empty fragment) would leave the node's content valid. You\n// can optionally pass `start` and `end` indices into the\n// replacement fragment.\n\n\nNode.prototype.canReplace = function canReplace(from, to, replacement, start, end) {\n  if (replacement === void 0) replacement = Fragment.empty;\n  if (start === void 0) start = 0;\n  if (end === void 0) end = replacement.childCount;\n  var one = this.contentMatchAt(from).matchFragment(replacement, start, end);\n  var two = one && one.matchFragment(this.content, to);\n\n  if (!two || !two.validEnd) {\n    return false;\n  }\n\n  for (var i = start; i < end; i++) {\n    if (!this.type.allowsMarks(replacement.child(i).marks)) {\n      return false;\n    }\n  }\n\n  return true;\n}; // :: (number, number, NodeType, ?[Mark]) → bool\n// Test whether replacing the range `from` to `to` (by index) with a\n// node of the given type would leave the node's content valid.\n\n\nNode.prototype.canReplaceWith = function canReplaceWith(from, to, type, marks) {\n  if (marks && !this.type.allowsMarks(marks)) {\n    return false;\n  }\n\n  var start = this.contentMatchAt(from).matchType(type);\n  var end = start && start.matchFragment(this.content, to);\n  return end ? end.validEnd : false;\n}; // :: (Node) → bool\n// Test whether the given node's content could be appended to this\n// node. If that node is empty, this will only return true if there\n// is at least one node type that can appear in both nodes (to avoid\n// merging completely incompatible nodes).\n\n\nNode.prototype.canAppend = function canAppend(other) {\n  if (other.content.size) {\n    return this.canReplace(this.childCount, this.childCount, other.content);\n  } else {\n    return this.type.compatibleContent(other.type);\n  }\n}; // :: ()\n// Check whether this node and its descendants conform to the\n// schema, and raise error when they do not.\n\n\nNode.prototype.check = function check() {\n  if (!this.type.validContent(this.content)) {\n    throw new RangeError(\"Invalid content for node \" + this.type.name + \": \" + this.content.toString().slice(0, 50));\n  }\n\n  this.content.forEach(function (node) {\n    return node.check();\n  });\n}; // :: () → Object\n// Return a JSON-serializeable representation of this node.\n\n\nNode.prototype.toJSON = function toJSON() {\n  var obj = {\n    type: this.type.name\n  };\n\n  for (var _ in this.attrs) {\n    obj.attrs = this.attrs;\n    break;\n  }\n\n  if (this.content.size) {\n    obj.content = this.content.toJSON();\n  }\n\n  if (this.marks.length) {\n    obj.marks = this.marks.map(function (n) {\n      return n.toJSON();\n    });\n  }\n\n  return obj;\n}; // :: (Schema, Object) → Node\n// Deserialize a node from its JSON representation.\n\n\nNode.fromJSON = function fromJSON(schema, json) {\n  if (!json) {\n    throw new RangeError(\"Invalid input for Node.fromJSON\");\n  }\n\n  var marks = null;\n\n  if (json.marks) {\n    if (!Array.isArray(json.marks)) {\n      throw new RangeError(\"Invalid mark data for Node.fromJSON\");\n    }\n\n    marks = json.marks.map(schema.markFromJSON);\n  }\n\n  if (json.type == \"text\") {\n    if (typeof json.text != \"string\") {\n      throw new RangeError(\"Invalid text node in JSON\");\n    }\n\n    return schema.text(json.text, marks);\n  }\n\n  var content = Fragment.fromJSON(schema, json.content);\n  return schema.nodeType(json.type).create(json.attrs, content, marks);\n};\n\nObject.defineProperties(Node.prototype, prototypeAccessors$3);\n\nvar TextNode = /*@__PURE__*/function (Node) {\n  function TextNode(type, attrs, content, marks) {\n    Node.call(this, type, attrs, null, marks);\n\n    if (!content) {\n      throw new RangeError(\"Empty text nodes are not allowed\");\n    }\n\n    this.text = content;\n  }\n\n  if (Node) TextNode.__proto__ = Node;\n  TextNode.prototype = Object.create(Node && Node.prototype);\n  TextNode.prototype.constructor = TextNode;\n  var prototypeAccessors$1 = {\n    textContent: {\n      configurable: true\n    },\n    nodeSize: {\n      configurable: true\n    }\n  };\n\n  TextNode.prototype.toString = function toString() {\n    if (this.type.spec.toDebugString) {\n      return this.type.spec.toDebugString(this);\n    }\n\n    return wrapMarks(this.marks, JSON.stringify(this.text));\n  };\n\n  prototypeAccessors$1.textContent.get = function () {\n    return this.text;\n  };\n\n  TextNode.prototype.textBetween = function textBetween(from, to) {\n    return this.text.slice(from, to);\n  };\n\n  prototypeAccessors$1.nodeSize.get = function () {\n    return this.text.length;\n  };\n\n  TextNode.prototype.mark = function mark(marks) {\n    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);\n  };\n\n  TextNode.prototype.withText = function withText(text) {\n    if (text == this.text) {\n      return this;\n    }\n\n    return new TextNode(this.type, this.attrs, text, this.marks);\n  };\n\n  TextNode.prototype.cut = function cut(from, to) {\n    if (from === void 0) from = 0;\n    if (to === void 0) to = this.text.length;\n\n    if (from == 0 && to == this.text.length) {\n      return this;\n    }\n\n    return this.withText(this.text.slice(from, to));\n  };\n\n  TextNode.prototype.eq = function eq(other) {\n    return this.sameMarkup(other) && this.text == other.text;\n  };\n\n  TextNode.prototype.toJSON = function toJSON() {\n    var base = Node.prototype.toJSON.call(this);\n    base.text = this.text;\n    return base;\n  };\n\n  Object.defineProperties(TextNode.prototype, prototypeAccessors$1);\n  return TextNode;\n}(Node);\n\nfunction wrapMarks(marks, str) {\n  for (var i = marks.length - 1; i >= 0; i--) {\n    str = marks[i].type.name + \"(\" + str + \")\";\n  }\n\n  return str;\n} // ::- Instances of this class represent a match state of a node\n// type's [content expression](#model.NodeSpec.content), and can be\n// used to find out whether further content matches here, and whether\n// a given position is a valid end of the node.\n\n\nvar ContentMatch = function ContentMatch(validEnd) {\n  // :: bool\n  // True when this match state represents a valid end of the node.\n  this.validEnd = validEnd;\n  this.next = [];\n  this.wrapCache = [];\n};\n\nvar prototypeAccessors$4 = {\n  inlineContent: {\n    configurable: true\n  },\n  defaultType: {\n    configurable: true\n  },\n  edgeCount: {\n    configurable: true\n  }\n};\n\nContentMatch.parse = function parse(string, nodeTypes) {\n  var stream = new TokenStream(string, nodeTypes);\n\n  if (stream.next == null) {\n    return ContentMatch.empty;\n  }\n\n  var expr = parseExpr(stream);\n\n  if (stream.next) {\n    stream.err(\"Unexpected trailing text\");\n  }\n\n  var match = dfa(nfa(expr));\n  checkForDeadEnds(match, stream);\n  return match;\n}; // :: (NodeType) → ?ContentMatch\n// Match a node type, returning a match after that node if\n// successful.\n\n\nContentMatch.prototype.matchType = function matchType(type) {\n  for (var i = 0; i < this.next.length; i += 2) {\n    if (this.next[i] == type) {\n      return this.next[i + 1];\n    }\n  }\n\n  return null;\n}; // :: (Fragment, ?number, ?number) → ?ContentMatch\n// Try to match a fragment. Returns the resulting match when\n// successful.\n\n\nContentMatch.prototype.matchFragment = function matchFragment(frag, start, end) {\n  if (start === void 0) start = 0;\n  if (end === void 0) end = frag.childCount;\n  var cur = this;\n\n  for (var i = start; cur && i < end; i++) {\n    cur = cur.matchType(frag.child(i).type);\n  }\n\n  return cur;\n};\n\nprototypeAccessors$4.inlineContent.get = function () {\n  var first = this.next[0];\n  return first ? first.isInline : false;\n}; // :: ?NodeType\n// Get the first matching node type at this match position that can\n// be generated.\n\n\nprototypeAccessors$4.defaultType.get = function () {\n  for (var i = 0; i < this.next.length; i += 2) {\n    var type = this.next[i];\n\n    if (!(type.isText || type.hasRequiredAttrs())) {\n      return type;\n    }\n  }\n};\n\nContentMatch.prototype.compatible = function compatible(other) {\n  for (var i = 0; i < this.next.length; i += 2) {\n    for (var j = 0; j < other.next.length; j += 2) {\n      if (this.next[i] == other.next[j]) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}; // :: (Fragment, bool, ?number) → ?Fragment\n// Try to match the given fragment, and if that fails, see if it can\n// be made to match by inserting nodes in front of it. When\n// successful, return a fragment of inserted nodes (which may be\n// empty if nothing had to be inserted). When `toEnd` is true, only\n// return a fragment if the resulting match goes to the end of the\n// content expression.\n\n\nContentMatch.prototype.fillBefore = function fillBefore(after, toEnd, startIndex) {\n  if (toEnd === void 0) toEnd = false;\n  if (startIndex === void 0) startIndex = 0;\n  var seen = [this];\n\n  function search(match, types) {\n    var finished = match.matchFragment(after, startIndex);\n\n    if (finished && (!toEnd || finished.validEnd)) {\n      return Fragment.from(types.map(function (tp) {\n        return tp.createAndFill();\n      }));\n    }\n\n    for (var i = 0; i < match.next.length; i += 2) {\n      var type = match.next[i],\n          next = match.next[i + 1];\n\n      if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n        seen.push(next);\n        var found = search(next, types.concat(type));\n\n        if (found) {\n          return found;\n        }\n      }\n    }\n  }\n\n  return search(this, []);\n}; // :: (NodeType) → ?[NodeType]\n// Find a set of wrapping node types that would allow a node of the\n// given type to appear at this position. The result may be empty\n// (when it fits directly) and will be null when no such wrapping\n// exists.\n\n\nContentMatch.prototype.findWrapping = function findWrapping(target) {\n  for (var i = 0; i < this.wrapCache.length; i += 2) {\n    if (this.wrapCache[i] == target) {\n      return this.wrapCache[i + 1];\n    }\n  }\n\n  var computed = this.computeWrapping(target);\n  this.wrapCache.push(target, computed);\n  return computed;\n};\n\nContentMatch.prototype.computeWrapping = function computeWrapping(target) {\n  var seen = Object.create(null),\n      active = [{\n    match: this,\n    type: null,\n    via: null\n  }];\n\n  while (active.length) {\n    var current = active.shift(),\n        match = current.match;\n\n    if (match.matchType(target)) {\n      var result = [];\n\n      for (var obj = current; obj.type; obj = obj.via) {\n        result.push(obj.type);\n      }\n\n      return result.reverse();\n    }\n\n    for (var i = 0; i < match.next.length; i += 2) {\n      var type = match.next[i];\n\n      if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {\n        active.push({\n          match: type.contentMatch,\n          type: type,\n          via: current\n        });\n        seen[type.name] = true;\n      }\n    }\n  }\n}; // :: number\n// The number of outgoing edges this node has in the finite\n// automaton that describes the content expression.\n\n\nprototypeAccessors$4.edgeCount.get = function () {\n  return this.next.length >> 1;\n}; // :: (number) → {type: NodeType, next: ContentMatch}\n// Get the _n_​th outgoing edge from this node in the finite\n// automaton that describes the content expression.\n\n\nContentMatch.prototype.edge = function edge(n) {\n  var i = n << 1;\n\n  if (i >= this.next.length) {\n    throw new RangeError(\"There's no \" + n + \"th edge in this content match\");\n  }\n\n  return {\n    type: this.next[i],\n    next: this.next[i + 1]\n  };\n};\n\nContentMatch.prototype.toString = function toString() {\n  var seen = [];\n\n  function scan(m) {\n    seen.push(m);\n\n    for (var i = 1; i < m.next.length; i += 2) {\n      if (seen.indexOf(m.next[i]) == -1) {\n        scan(m.next[i]);\n      }\n    }\n  }\n\n  scan(this);\n  return seen.map(function (m, i) {\n    var out = i + (m.validEnd ? \"*\" : \" \") + \" \";\n\n    for (var i$1 = 0; i$1 < m.next.length; i$1 += 2) {\n      out += (i$1 ? \", \" : \"\") + m.next[i$1].name + \"->\" + seen.indexOf(m.next[i$1 + 1]);\n    }\n\n    return out;\n  }).join(\"\\n\");\n};\n\nObject.defineProperties(ContentMatch.prototype, prototypeAccessors$4);\nContentMatch.empty = new ContentMatch(true);\n\nvar TokenStream = function TokenStream(string, nodeTypes) {\n  this.string = string;\n  this.nodeTypes = nodeTypes;\n  this.inline = null;\n  this.pos = 0;\n  this.tokens = string.split(/\\s*(?=\\b|\\W|$)/);\n\n  if (this.tokens[this.tokens.length - 1] == \"\") {\n    this.tokens.pop();\n  }\n\n  if (this.tokens[0] == \"\") {\n    this.tokens.unshift();\n  }\n};\n\nvar prototypeAccessors$1$2 = {\n  next: {\n    configurable: true\n  }\n};\n\nprototypeAccessors$1$2.next.get = function () {\n  return this.tokens[this.pos];\n};\n\nTokenStream.prototype.eat = function eat(tok) {\n  return this.next == tok && (this.pos++ || true);\n};\n\nTokenStream.prototype.err = function err(str) {\n  throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\");\n};\n\nObject.defineProperties(TokenStream.prototype, prototypeAccessors$1$2);\n\nfunction parseExpr(stream) {\n  var exprs = [];\n\n  do {\n    exprs.push(parseExprSeq(stream));\n  } while (stream.eat(\"|\"));\n\n  return exprs.length == 1 ? exprs[0] : {\n    type: \"choice\",\n    exprs: exprs\n  };\n}\n\nfunction parseExprSeq(stream) {\n  var exprs = [];\n\n  do {\n    exprs.push(parseExprSubscript(stream));\n  } while (stream.next && stream.next != \")\" && stream.next != \"|\");\n\n  return exprs.length == 1 ? exprs[0] : {\n    type: \"seq\",\n    exprs: exprs\n  };\n}\n\nfunction parseExprSubscript(stream) {\n  var expr = parseExprAtom(stream);\n\n  for (;;) {\n    if (stream.eat(\"+\")) {\n      expr = {\n        type: \"plus\",\n        expr: expr\n      };\n    } else if (stream.eat(\"*\")) {\n      expr = {\n        type: \"star\",\n        expr: expr\n      };\n    } else if (stream.eat(\"?\")) {\n      expr = {\n        type: \"opt\",\n        expr: expr\n      };\n    } else if (stream.eat(\"{\")) {\n      expr = parseExprRange(stream, expr);\n    } else {\n      break;\n    }\n  }\n\n  return expr;\n}\n\nfunction parseNum(stream) {\n  if (/\\D/.test(stream.next)) {\n    stream.err(\"Expected number, got '\" + stream.next + \"'\");\n  }\n\n  var result = Number(stream.next);\n  stream.pos++;\n  return result;\n}\n\nfunction parseExprRange(stream, expr) {\n  var min = parseNum(stream),\n      max = min;\n\n  if (stream.eat(\",\")) {\n    if (stream.next != \"}\") {\n      max = parseNum(stream);\n    } else {\n      max = -1;\n    }\n  }\n\n  if (!stream.eat(\"}\")) {\n    stream.err(\"Unclosed braced range\");\n  }\n\n  return {\n    type: \"range\",\n    min: min,\n    max: max,\n    expr: expr\n  };\n}\n\nfunction resolveName(stream, name) {\n  var types = stream.nodeTypes,\n      type = types[name];\n\n  if (type) {\n    return [type];\n  }\n\n  var result = [];\n\n  for (var typeName in types) {\n    var type$1 = types[typeName];\n\n    if (type$1.groups.indexOf(name) > -1) {\n      result.push(type$1);\n    }\n  }\n\n  if (result.length == 0) {\n    stream.err(\"No node type or group '\" + name + \"' found\");\n  }\n\n  return result;\n}\n\nfunction parseExprAtom(stream) {\n  if (stream.eat(\"(\")) {\n    var expr = parseExpr(stream);\n\n    if (!stream.eat(\")\")) {\n      stream.err(\"Missing closing paren\");\n    }\n\n    return expr;\n  } else if (!/\\W/.test(stream.next)) {\n    var exprs = resolveName(stream, stream.next).map(function (type) {\n      if (stream.inline == null) {\n        stream.inline = type.isInline;\n      } else if (stream.inline != type.isInline) {\n        stream.err(\"Mixing inline and block content\");\n      }\n\n      return {\n        type: \"name\",\n        value: type\n      };\n    });\n    stream.pos++;\n    return exprs.length == 1 ? exprs[0] : {\n      type: \"choice\",\n      exprs: exprs\n    };\n  } else {\n    stream.err(\"Unexpected token '\" + stream.next + \"'\");\n  }\n} // The code below helps compile a regular-expression-like language\n// into a deterministic finite automaton. For a good introduction to\n// these concepts, see https://swtch.com/~rsc/regexp/regexp1.html\n// : (Object) → [[{term: ?any, to: number}]]\n// Construct an NFA from an expression as returned by the parser. The\n// NFA is represented as an array of states, which are themselves\n// arrays of edges, which are `{term, to}` objects. The first state is\n// the entry state and the last node is the success state.\n//\n// Note that unlike typical NFAs, the edge ordering in this one is\n// significant, in that it is used to contruct filler content when\n// necessary.\n\n\nfunction nfa(expr) {\n  var nfa = [[]];\n  connect(compile(expr, 0), node());\n  return nfa;\n\n  function node() {\n    return nfa.push([]) - 1;\n  }\n\n  function edge(from, to, term) {\n    var edge = {\n      term: term,\n      to: to\n    };\n    nfa[from].push(edge);\n    return edge;\n  }\n\n  function connect(edges, to) {\n    edges.forEach(function (edge) {\n      return edge.to = to;\n    });\n  }\n\n  function compile(expr, from) {\n    if (expr.type == \"choice\") {\n      return expr.exprs.reduce(function (out, expr) {\n        return out.concat(compile(expr, from));\n      }, []);\n    } else if (expr.type == \"seq\") {\n      for (var i = 0;; i++) {\n        var next = compile(expr.exprs[i], from);\n\n        if (i == expr.exprs.length - 1) {\n          return next;\n        }\n\n        connect(next, from = node());\n      }\n    } else if (expr.type == \"star\") {\n      var loop = node();\n      edge(from, loop);\n      connect(compile(expr.expr, loop), loop);\n      return [edge(loop)];\n    } else if (expr.type == \"plus\") {\n      var loop$1 = node();\n      connect(compile(expr.expr, from), loop$1);\n      connect(compile(expr.expr, loop$1), loop$1);\n      return [edge(loop$1)];\n    } else if (expr.type == \"opt\") {\n      return [edge(from)].concat(compile(expr.expr, from));\n    } else if (expr.type == \"range\") {\n      var cur = from;\n\n      for (var i$1 = 0; i$1 < expr.min; i$1++) {\n        var next$1 = node();\n        connect(compile(expr.expr, cur), next$1);\n        cur = next$1;\n      }\n\n      if (expr.max == -1) {\n        connect(compile(expr.expr, cur), cur);\n      } else {\n        for (var i$2 = expr.min; i$2 < expr.max; i$2++) {\n          var next$2 = node();\n          edge(cur, next$2);\n          connect(compile(expr.expr, cur), next$2);\n          cur = next$2;\n        }\n      }\n\n      return [edge(cur)];\n    } else if (expr.type == \"name\") {\n      return [edge(from, null, expr.value)];\n    }\n  }\n}\n\nfunction cmp(a, b) {\n  return b - a;\n} // Get the set of nodes reachable by null edges from `node`. Omit\n// nodes with only a single null-out-edge, since they may lead to\n// needless duplicated nodes.\n\n\nfunction nullFrom(nfa, node) {\n  var result = [];\n  scan(node);\n  return result.sort(cmp);\n\n  function scan(node) {\n    var edges = nfa[node];\n\n    if (edges.length == 1 && !edges[0].term) {\n      return scan(edges[0].to);\n    }\n\n    result.push(node);\n\n    for (var i = 0; i < edges.length; i++) {\n      var ref = edges[i];\n      var term = ref.term;\n      var to = ref.to;\n\n      if (!term && result.indexOf(to) == -1) {\n        scan(to);\n      }\n    }\n  }\n} // : ([[{term: ?any, to: number}]]) → ContentMatch\n// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set\n// of state objects (`ContentMatch` instances) with transitions\n// between them.\n\n\nfunction dfa(nfa) {\n  var labeled = Object.create(null);\n  return explore(nullFrom(nfa, 0));\n\n  function explore(states) {\n    var out = [];\n    states.forEach(function (node) {\n      nfa[node].forEach(function (ref) {\n        var term = ref.term;\n        var to = ref.to;\n\n        if (!term) {\n          return;\n        }\n\n        var known = out.indexOf(term),\n            set = known > -1 && out[known + 1];\n        nullFrom(nfa, to).forEach(function (node) {\n          if (!set) {\n            out.push(term, set = []);\n          }\n\n          if (set.indexOf(node) == -1) {\n            set.push(node);\n          }\n        });\n      });\n    });\n    var state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);\n\n    for (var i = 0; i < out.length; i += 2) {\n      var states$1 = out[i + 1].sort(cmp);\n      state.next.push(out[i], labeled[states$1.join(\",\")] || explore(states$1));\n    }\n\n    return state;\n  }\n}\n\nfunction checkForDeadEnds(match, stream) {\n  for (var i = 0, work = [match]; i < work.length; i++) {\n    var state = work[i],\n        dead = !state.validEnd,\n        nodes = [];\n\n    for (var j = 0; j < state.next.length; j += 2) {\n      var node = state.next[j],\n          next = state.next[j + 1];\n      nodes.push(node.name);\n\n      if (dead && !(node.isText || node.hasRequiredAttrs())) {\n        dead = false;\n      }\n\n      if (work.indexOf(next) == -1) {\n        work.push(next);\n      }\n    }\n\n    if (dead) {\n      stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\");\n    }\n  }\n} // For node types where all attrs have a default value (or which don't\n// have any attributes), build up a single reusable default attribute\n// object, and use it for all nodes that don't specify specific\n// attributes.\n\n\nfunction defaultAttrs(attrs) {\n  var defaults = Object.create(null);\n\n  for (var attrName in attrs) {\n    var attr = attrs[attrName];\n\n    if (!attr.hasDefault) {\n      return null;\n    }\n\n    defaults[attrName] = attr.default;\n  }\n\n  return defaults;\n}\n\nfunction computeAttrs(attrs, value) {\n  var built = Object.create(null);\n\n  for (var name in attrs) {\n    var given = value && value[name];\n\n    if (given === undefined) {\n      var attr = attrs[name];\n\n      if (attr.hasDefault) {\n        given = attr.default;\n      } else {\n        throw new RangeError(\"No value supplied for attribute \" + name);\n      }\n    }\n\n    built[name] = given;\n  }\n\n  return built;\n}\n\nfunction initAttrs(attrs) {\n  var result = Object.create(null);\n\n  if (attrs) {\n    for (var name in attrs) {\n      result[name] = new Attribute(attrs[name]);\n    }\n  }\n\n  return result;\n} // ::- Node types are objects allocated once per `Schema` and used to\n// [tag](#model.Node.type) `Node` instances. They contain information\n// about the node type, such as its name and what kind of node it\n// represents.\n\n\nvar NodeType = function NodeType(name, schema, spec) {\n  // :: string\n  // The name the node type has in this schema.\n  this.name = name; // :: Schema\n  // A link back to the `Schema` the node type belongs to.\n\n  this.schema = schema; // :: NodeSpec\n  // The spec that this type is based on\n\n  this.spec = spec;\n  this.groups = spec.group ? spec.group.split(\" \") : [];\n  this.attrs = initAttrs(spec.attrs);\n  this.defaultAttrs = defaultAttrs(this.attrs); // :: ContentMatch\n  // The starting match of the node type's content expression.\n\n  this.contentMatch = null; // : ?[MarkType]\n  // The set of marks allowed in this node. `null` means all marks\n  // are allowed.\n\n  this.markSet = null; // :: bool\n  // True if this node type has inline content.\n\n  this.inlineContent = null; // :: bool\n  // True if this is a block type\n\n  this.isBlock = !(spec.inline || name == \"text\"); // :: bool\n  // True if this is the text node type.\n\n  this.isText = name == \"text\";\n};\n\nvar prototypeAccessors$5 = {\n  isInline: {\n    configurable: true\n  },\n  isTextblock: {\n    configurable: true\n  },\n  isLeaf: {\n    configurable: true\n  },\n  isAtom: {\n    configurable: true\n  }\n}; // :: bool\n// True if this is an inline type.\n\nprototypeAccessors$5.isInline.get = function () {\n  return !this.isBlock;\n}; // :: bool\n// True if this is a textblock type, a block that contains inline\n// content.\n\n\nprototypeAccessors$5.isTextblock.get = function () {\n  return this.isBlock && this.inlineContent;\n}; // :: bool\n// True for node types that allow no content.\n\n\nprototypeAccessors$5.isLeaf.get = function () {\n  return this.contentMatch == ContentMatch.empty;\n}; // :: bool\n// True when this node is an atom, i.e. when it does not have\n// directly editable content.\n\n\nprototypeAccessors$5.isAtom.get = function () {\n  return this.isLeaf || this.spec.atom;\n}; // :: () → bool\n// Tells you whether this node type has any required attributes.\n\n\nNodeType.prototype.hasRequiredAttrs = function hasRequiredAttrs() {\n  for (var n in this.attrs) {\n    if (this.attrs[n].isRequired) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nNodeType.prototype.compatibleContent = function compatibleContent(other) {\n  return this == other || this.contentMatch.compatible(other.contentMatch);\n};\n\nNodeType.prototype.computeAttrs = function computeAttrs$1(attrs) {\n  if (!attrs && this.defaultAttrs) {\n    return this.defaultAttrs;\n  } else {\n    return computeAttrs(this.attrs, attrs);\n  }\n}; // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n// Create a `Node` of this type. The given attributes are\n// checked and defaulted (you can pass `null` to use the type's\n// defaults entirely, if no required attributes exist). `content`\n// may be a `Fragment`, a node, an array of nodes, or\n// `null`. Similarly `marks` may be `null` to default to the empty\n// set of marks.\n\n\nNodeType.prototype.create = function create(attrs, content, marks) {\n  if (this.isText) {\n    throw new Error(\"NodeType.create can't construct text nodes\");\n  }\n\n  return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));\n}; // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n// Like [`create`](#model.NodeType.create), but check the given content\n// against the node type's content restrictions, and throw an error\n// if it doesn't match.\n\n\nNodeType.prototype.createChecked = function createChecked(attrs, content, marks) {\n  content = Fragment.from(content);\n\n  if (!this.validContent(content)) {\n    throw new RangeError(\"Invalid content for node \" + this.name);\n  }\n\n  return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));\n}; // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → ?Node\n// Like [`create`](#model.NodeType.create), but see if it is necessary to\n// add nodes to the start or end of the given fragment to make it\n// fit the node. If no fitting wrapping can be found, return null.\n// Note that, due to the fact that required nodes can always be\n// created, this will always succeed if you pass null or\n// `Fragment.empty` as content.\n\n\nNodeType.prototype.createAndFill = function createAndFill(attrs, content, marks) {\n  attrs = this.computeAttrs(attrs);\n  content = Fragment.from(content);\n\n  if (content.size) {\n    var before = this.contentMatch.fillBefore(content);\n\n    if (!before) {\n      return null;\n    }\n\n    content = before.append(content);\n  }\n\n  var after = this.contentMatch.matchFragment(content).fillBefore(Fragment.empty, true);\n\n  if (!after) {\n    return null;\n  }\n\n  return new Node(this, attrs, content.append(after), Mark.setFrom(marks));\n}; // :: (Fragment) → bool\n// Returns true if the given fragment is valid content for this node\n// type with the given attributes.\n\n\nNodeType.prototype.validContent = function validContent(content) {\n  var result = this.contentMatch.matchFragment(content);\n\n  if (!result || !result.validEnd) {\n    return false;\n  }\n\n  for (var i = 0; i < content.childCount; i++) {\n    if (!this.allowsMarks(content.child(i).marks)) {\n      return false;\n    }\n  }\n\n  return true;\n}; // :: (MarkType) → bool\n// Check whether the given mark type is allowed in this node.\n\n\nNodeType.prototype.allowsMarkType = function allowsMarkType(markType) {\n  return this.markSet == null || this.markSet.indexOf(markType) > -1;\n}; // :: ([Mark]) → bool\n// Test whether the given set of marks are allowed in this node.\n\n\nNodeType.prototype.allowsMarks = function allowsMarks(marks) {\n  if (this.markSet == null) {\n    return true;\n  }\n\n  for (var i = 0; i < marks.length; i++) {\n    if (!this.allowsMarkType(marks[i].type)) {\n      return false;\n    }\n  }\n\n  return true;\n}; // :: ([Mark]) → [Mark]\n// Removes the marks that are not allowed in this node from the given set.\n\n\nNodeType.prototype.allowedMarks = function allowedMarks(marks) {\n  if (this.markSet == null) {\n    return marks;\n  }\n\n  var copy;\n\n  for (var i = 0; i < marks.length; i++) {\n    if (!this.allowsMarkType(marks[i].type)) {\n      if (!copy) {\n        copy = marks.slice(0, i);\n      }\n    } else if (copy) {\n      copy.push(marks[i]);\n    }\n  }\n\n  return !copy ? marks : copy.length ? copy : Mark.empty;\n};\n\nNodeType.compile = function compile(nodes, schema) {\n  var result = Object.create(null);\n  nodes.forEach(function (name, spec) {\n    return result[name] = new NodeType(name, schema, spec);\n  });\n  var topType = schema.spec.topNode || \"doc\";\n\n  if (!result[topType]) {\n    throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\");\n  }\n\n  if (!result.text) {\n    throw new RangeError(\"Every schema needs a 'text' type\");\n  }\n\n  for (var _ in result.text.attrs) {\n    throw new RangeError(\"The text node type should not have attributes\");\n  }\n\n  return result;\n};\n\nObject.defineProperties(NodeType.prototype, prototypeAccessors$5); // Attribute descriptors\n\nvar Attribute = function Attribute(options) {\n  this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\");\n  this.default = options.default;\n};\n\nvar prototypeAccessors$1$3 = {\n  isRequired: {\n    configurable: true\n  }\n};\n\nprototypeAccessors$1$3.isRequired.get = function () {\n  return !this.hasDefault;\n};\n\nObject.defineProperties(Attribute.prototype, prototypeAccessors$1$3); // Marks\n// ::- Like nodes, marks (which are associated with nodes to signify\n// things like emphasis or being part of a link) are\n// [tagged](#model.Mark.type) with type objects, which are\n// instantiated once per `Schema`.\n\nvar MarkType = function MarkType(name, rank, schema, spec) {\n  // :: string\n  // The name of the mark type.\n  this.name = name; // :: Schema\n  // The schema that this mark type instance is part of.\n\n  this.schema = schema; // :: MarkSpec\n  // The spec on which the type is based.\n\n  this.spec = spec;\n  this.attrs = initAttrs(spec.attrs);\n  this.rank = rank;\n  this.excluded = null;\n  var defaults = defaultAttrs(this.attrs);\n  this.instance = defaults && new Mark(this, defaults);\n}; // :: (?Object) → Mark\n// Create a mark of this type. `attrs` may be `null` or an object\n// containing only some of the mark's attributes. The others, if\n// they have defaults, will be added.\n\n\nMarkType.prototype.create = function create(attrs) {\n  if (!attrs && this.instance) {\n    return this.instance;\n  }\n\n  return new Mark(this, computeAttrs(this.attrs, attrs));\n};\n\nMarkType.compile = function compile(marks, schema) {\n  var result = Object.create(null),\n      rank = 0;\n  marks.forEach(function (name, spec) {\n    return result[name] = new MarkType(name, rank++, schema, spec);\n  });\n  return result;\n}; // :: ([Mark]) → [Mark]\n// When there is a mark of this type in the given set, a new set\n// without it is returned. Otherwise, the input set is returned.\n\n\nMarkType.prototype.removeFromSet = function removeFromSet(set) {\n  for (var i = 0; i < set.length; i++) {\n    if (set[i].type == this) {\n      return set.slice(0, i).concat(set.slice(i + 1));\n    }\n  }\n\n  return set;\n}; // :: ([Mark]) → ?Mark\n// Tests whether there is a mark of this type in the given set.\n\n\nMarkType.prototype.isInSet = function isInSet(set) {\n  for (var i = 0; i < set.length; i++) {\n    if (set[i].type == this) {\n      return set[i];\n    }\n  }\n}; // :: (MarkType) → bool\n// Queries whether a given mark type is\n// [excluded](#model.MarkSpec.excludes) by this one.\n\n\nMarkType.prototype.excludes = function excludes(other) {\n  return this.excluded.indexOf(other) > -1;\n}; // SchemaSpec:: interface\n// An object describing a schema, as passed to the [`Schema`](#model.Schema)\n// constructor.\n//\n//   nodes:: union<Object<NodeSpec>, OrderedMap<NodeSpec>>\n//   The node types in this schema. Maps names to\n//   [`NodeSpec`](#model.NodeSpec) objects that describe the node type\n//   associated with that name. Their order is significant—it\n//   determines which [parse rules](#model.NodeSpec.parseDOM) take\n//   precedence by default, and which nodes come first in a given\n//   [group](#model.NodeSpec.group).\n//\n//   marks:: ?union<Object<MarkSpec>, OrderedMap<MarkSpec>>\n//   The mark types that exist in this schema. The order in which they\n//   are provided determines the order in which [mark\n//   sets](#model.Mark.addToSet) are sorted and in which [parse\n//   rules](#model.MarkSpec.parseDOM) are tried.\n//\n//   topNode:: ?string\n//   The name of the default top-level node for the schema. Defaults\n//   to `\"doc\"`.\n// NodeSpec:: interface\n//\n//   content:: ?string\n//   The content expression for this node, as described in the [schema\n//   guide](/docs/guide/#schema.content_expressions). When not given,\n//   the node does not allow any content.\n//\n//   marks:: ?string\n//   The marks that are allowed inside of this node. May be a\n//   space-separated string referring to mark names or groups, `\"_\"`\n//   to explicitly allow all marks, or `\"\"` to disallow marks. When\n//   not given, nodes with inline content default to allowing all\n//   marks, other nodes default to not allowing marks.\n//\n//   group:: ?string\n//   The group or space-separated groups to which this node belongs,\n//   which can be referred to in the content expressions for the\n//   schema.\n//\n//   inline:: ?bool\n//   Should be set to true for inline nodes. (Implied for text nodes.)\n//\n//   atom:: ?bool\n//   Can be set to true to indicate that, though this isn't a [leaf\n//   node](#model.NodeType.isLeaf), it doesn't have directly editable\n//   content and should be treated as a single unit in the view.\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that nodes of this type get.\n//\n//   selectable:: ?bool\n//   Controls whether nodes of this type can be selected as a [node\n//   selection](#state.NodeSelection). Defaults to true for non-text\n//   nodes.\n//\n//   draggable:: ?bool\n//   Determines whether nodes of this type can be dragged without\n//   being selected. Defaults to false.\n//\n//   code:: ?bool\n//   Can be used to indicate that this node contains code, which\n//   causes some commands to behave differently.\n//\n//   defining:: ?bool\n//   Determines whether this node is considered an important parent\n//   node during replace operations (such as paste). Non-defining (the\n//   default) nodes get dropped when their entire content is replaced,\n//   whereas defining nodes persist and wrap the inserted content.\n//   Likewise, in _inserted_ content the defining parents of the\n//   content are preserved when possible. Typically,\n//   non-default-paragraph textblock types, and possibly list items,\n//   are marked as defining.\n//\n//   isolating:: ?bool\n//   When enabled (default is false), the sides of nodes of this type\n//   count as boundaries that regular editing operations, like\n//   backspacing or lifting, won't cross. An example of a node that\n//   should probably have this enabled is a table cell.\n//\n//   toDOM:: ?(node: Node) → DOMOutputSpec\n//   Defines the default way a node of this type should be serialized\n//   to DOM/HTML (as used by\n//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)).\n//   Should return a DOM node or an [array\n//   structure](#model.DOMOutputSpec) that describes one, with an\n//   optional number zero (“hole”) in it to indicate where the node's\n//   content should be inserted.\n//\n//   For text nodes, the default is to create a text DOM node. Though\n//   it is possible to create a serializer where text is rendered\n//   differently, this is not supported inside the editor, so you\n//   shouldn't override that in your text node spec.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this node, which can be\n//   used by [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) to\n//   automatically derive a parser. The `node` field in the rules is\n//   implied (the name of this node will be filled in automatically).\n//   If you supply your own parser, you do not need to also specify\n//   parsing rules in your schema.\n//\n//   toDebugString:: ?(node: Node) -> string\n//   Defines the default way a node of this type should be serialized\n//   to a string representation for debugging (e.g. in error messages).\n// MarkSpec:: interface\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that marks of this type get.\n//\n//   inclusive:: ?bool\n//   Whether this mark should be active when the cursor is positioned\n//   at its end (or at its start when that is also the start of the\n//   parent node). Defaults to true.\n//\n//   excludes:: ?string\n//   Determines which other marks this mark can coexist with. Should\n//   be a space-separated strings naming other marks or groups of marks.\n//   When a mark is [added](#model.Mark.addToSet) to a set, all marks\n//   that it excludes are removed in the process. If the set contains\n//   any mark that excludes the new mark but is not, itself, excluded\n//   by the new mark, the mark can not be added an the set. You can\n//   use the value `\"_\"` to indicate that the mark excludes all\n//   marks in the schema.\n//\n//   Defaults to only being exclusive with marks of the same type. You\n//   can set it to an empty string (or any string not containing the\n//   mark's own name) to allow multiple marks of a given type to\n//   coexist (as long as they have different attributes).\n//\n//   group:: ?string\n//   The group or space-separated groups to which this mark belongs.\n//\n//   spanning:: ?bool\n//   Determines whether marks of this type can span multiple adjacent\n//   nodes when serialized to DOM/HTML. Defaults to true.\n//\n//   toDOM:: ?(mark: Mark, inline: bool) → DOMOutputSpec\n//   Defines the default way marks of this type should be serialized\n//   to DOM/HTML. When the resulting spec contains a hole, that is\n//   where the marked content is placed. Otherwise, it is appended to\n//   the top node.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this mark (see the\n//   corresponding [node spec field](#model.NodeSpec.parseDOM)). The\n//   `mark` field in the rules is implied.\n// AttributeSpec:: interface\n//\n// Used to [define](#model.NodeSpec.attrs) attributes on nodes or\n// marks.\n//\n//   default:: ?any\n//   The default value for this attribute, to use when no explicit\n//   value is provided. Attributes that have no default must be\n//   provided whenever a node or mark of a type that has them is\n//   created.\n// ::- A document schema. Holds [node](#model.NodeType) and [mark\n// type](#model.MarkType) objects for the nodes and marks that may\n// occur in conforming documents, and provides functionality for\n// creating and deserializing such documents.\n\n\nvar Schema = function Schema(spec) {\n  // :: SchemaSpec\n  // The [spec](#model.SchemaSpec) on which the schema is based,\n  // with the added guarantee that its `nodes` and `marks`\n  // properties are\n  // [`OrderedMap`](https://github.com/marijnh/orderedmap) instances\n  // (not raw objects).\n  this.spec = {};\n\n  for (var prop in spec) {\n    this.spec[prop] = spec[prop];\n  }\n\n  this.spec.nodes = OrderedMap.from(spec.nodes);\n  this.spec.marks = OrderedMap.from(spec.marks); // :: Object<NodeType>\n  // An object mapping the schema's node names to node type objects.\n\n  this.nodes = NodeType.compile(this.spec.nodes, this); // :: Object<MarkType>\n  // A map from mark names to mark type objects.\n\n  this.marks = MarkType.compile(this.spec.marks, this);\n  var contentExprCache = Object.create(null);\n\n  for (var prop$1 in this.nodes) {\n    if (prop$1 in this.marks) {\n      throw new RangeError(prop$1 + \" can not be both a node and a mark\");\n    }\n\n    var type = this.nodes[prop$1],\n        contentExpr = type.spec.content || \"\",\n        markExpr = type.spec.marks;\n    type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));\n    type.inlineContent = type.contentMatch.inlineContent;\n    type.markSet = markExpr == \"_\" ? null : markExpr ? gatherMarks(this, markExpr.split(\" \")) : markExpr == \"\" || !type.inlineContent ? [] : null;\n  }\n\n  for (var prop$2 in this.marks) {\n    var type$1 = this.marks[prop$2],\n        excl = type$1.spec.excludes;\n    type$1.excluded = excl == null ? [type$1] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"));\n  }\n\n  this.nodeFromJSON = this.nodeFromJSON.bind(this);\n  this.markFromJSON = this.markFromJSON.bind(this); // :: NodeType\n  // The type of the [default top node](#model.SchemaSpec.topNode)\n  // for this schema.\n\n  this.topNodeType = this.nodes[this.spec.topNode || \"doc\"]; // :: Object\n  // An object for storing whatever values modules may want to\n  // compute and cache per schema. (If you want to store something\n  // in it, try to use property names unlikely to clash.)\n\n  this.cached = Object.create(null);\n  this.cached.wrappings = Object.create(null);\n}; // :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n// Create a node in this schema. The `type` may be a string or a\n// `NodeType` instance. Attributes will be extended\n// with defaults, `content` may be a `Fragment`,\n// `null`, a `Node`, or an array of nodes.\n\n\nSchema.prototype.node = function node(type, attrs, content, marks) {\n  if (typeof type == \"string\") {\n    type = this.nodeType(type);\n  } else if (!(type instanceof NodeType)) {\n    throw new RangeError(\"Invalid node type: \" + type);\n  } else if (type.schema != this) {\n    throw new RangeError(\"Node type from different schema used (\" + type.name + \")\");\n  }\n\n  return type.createChecked(attrs, content, marks);\n}; // :: (string, ?[Mark]) → Node\n// Create a text node in the schema. Empty text nodes are not\n// allowed.\n\n\nSchema.prototype.text = function text(text$1, marks) {\n  var type = this.nodes.text;\n  return new TextNode(type, type.defaultAttrs, text$1, Mark.setFrom(marks));\n}; // :: (union<string, MarkType>, ?Object) → Mark\n// Create a mark with the given type and attributes.\n\n\nSchema.prototype.mark = function mark(type, attrs) {\n  if (typeof type == \"string\") {\n    type = this.marks[type];\n  }\n\n  return type.create(attrs);\n}; // :: (Object) → Node\n// Deserialize a node from its JSON representation. This method is\n// bound.\n\n\nSchema.prototype.nodeFromJSON = function nodeFromJSON(json) {\n  return Node.fromJSON(this, json);\n}; // :: (Object) → Mark\n// Deserialize a mark from its JSON representation. This method is\n// bound.\n\n\nSchema.prototype.markFromJSON = function markFromJSON(json) {\n  return Mark.fromJSON(this, json);\n};\n\nSchema.prototype.nodeType = function nodeType(name) {\n  var found = this.nodes[name];\n\n  if (!found) {\n    throw new RangeError(\"Unknown node type: \" + name);\n  }\n\n  return found;\n};\n\nfunction gatherMarks(schema, marks) {\n  var found = [];\n\n  for (var i = 0; i < marks.length; i++) {\n    var name = marks[i],\n        mark = schema.marks[name],\n        ok = mark;\n\n    if (mark) {\n      found.push(mark);\n    } else {\n      for (var prop in schema.marks) {\n        var mark$1 = schema.marks[prop];\n\n        if (name == \"_\" || mark$1.spec.group && mark$1.spec.group.split(\" \").indexOf(name) > -1) {\n          found.push(ok = mark$1);\n        }\n      }\n    }\n\n    if (!ok) {\n      throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\");\n    }\n  }\n\n  return found;\n} // ParseOptions:: interface\n// These are the options recognized by the\n// [`parse`](#model.DOMParser.parse) and\n// [`parseSlice`](#model.DOMParser.parseSlice) methods.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   By default, whitespace is collapsed as per HTML's rules. Pass\n//   `true` to preserve whitespace, but normalize newlines to\n//   spaces, and `\"full\"` to preserve whitespace entirely.\n//\n//   findPositions:: ?[{node: dom.Node, offset: number}]\n//   When given, the parser will, beside parsing the content,\n//   record the document positions of the given DOM positions. It\n//   will do so by writing to the objects, adding a `pos` property\n//   that holds the document position. DOM positions that are not\n//   in the parsed content will not be written to.\n//\n//   from:: ?number\n//   The child node index to start parsing from.\n//\n//   to:: ?number\n//   The child node index to stop parsing at.\n//\n//   topNode:: ?Node\n//   By default, the content is parsed into the schema's default\n//   [top node type](#model.Schema.topNodeType). You can pass this\n//   option to use the type and attributes from a different node\n//   as the top container.\n//\n//   topMatch:: ?ContentMatch\n//   Provide the starting content match that content parsed into the\n//   top node is matched against.\n//\n//   context:: ?ResolvedPos\n//   A set of additional nodes to count as\n//   [context](#model.ParseRule.context) when parsing, above the\n//   given [top node](#model.ParseOptions.topNode).\n// ParseRule:: interface\n// A value that describes how to parse a given DOM node or inline\n// style as a ProseMirror node or mark.\n//\n//   tag:: ?string\n//   A CSS selector describing the kind of DOM elements to match. A\n//   single rule should have _either_ a `tag` or a `style` property.\n//\n//   namespace:: ?string\n//   The namespace to match. This should be used with `tag`.\n//   Nodes are only matched when the namespace matches or this property\n//   is null.\n//\n//   style:: ?string\n//   A CSS property name to match. When given, this rule matches\n//   inline styles that list that property. May also have the form\n//   `\"property=value\"`, in which case the rule only matches if the\n//   propery's value exactly matches the given value. (For more\n//   complicated filters, use [`getAttrs`](#model.ParseRule.getAttrs)\n//   and return false to indicate that the match failed.)\n//\n//   priority:: ?number\n//   Can be used to change the order in which the parse rules in a\n//   schema are tried. Those with higher priority come first. Rules\n//   without a priority are counted as having priority 50. This\n//   property is only meaningful in a schema—when directly\n//   constructing a parser, the order of the rule array is used.\n//\n//   context:: ?string\n//   When given, restricts this rule to only match when the current\n//   context—the parent nodes into which the content is being\n//   parsed—matches this expression. Should contain one or more node\n//   names or node group names followed by single or double slashes.\n//   For example `\"paragraph/\"` means the rule only matches when the\n//   parent node is a paragraph, `\"blockquote/paragraph/\"` restricts\n//   it to be in a paragraph that is inside a blockquote, and\n//   `\"section//\"` matches any position inside a section—a double\n//   slash matches any sequence of ancestor nodes. To allow multiple\n//   different contexts, they can be separated by a pipe (`|`)\n//   character, as in `\"blockquote/|list_item/\"`.\n//\n//   node:: ?string\n//   The name of the node type to create when this rule matches. Only\n//   valid for rules with a `tag` property, not for style rules. Each\n//   rule should have one of a `node`, `mark`, or `ignore` property\n//   (except when it appears in a [node](#model.NodeSpec.parseDOM) or\n//   [mark spec](#model.MarkSpec.parseDOM), in which case the `node`\n//   or `mark` property will be derived from its position).\n//\n//   mark:: ?string\n//   The name of the mark type to wrap the matched content in.\n//\n//   ignore:: ?bool\n//   When true, ignore content that matches this rule.\n//\n//   closeParent:: ?bool\n//   When true, finding an element that matches this rule will close\n//   the current node.\n//\n//   skip:: ?bool\n//   When true, ignore the node that matches this rule, but do parse\n//   its content.\n//\n//   attrs:: ?Object\n//   Attributes for the node or mark created by this rule. When\n//   `getAttrs` is provided, it takes precedence.\n//\n//   getAttrs:: ?(union<dom.Node, string>) → ?union<Object, false>\n//   A function used to compute the attributes for the node or mark\n//   created by this rule. Can also be used to describe further\n//   conditions the DOM element or style must match. When it returns\n//   `false`, the rule won't match. When it returns null or undefined,\n//   that is interpreted as an empty/default set of attributes.\n//\n//   Called with a DOM Element for `tag` rules, and with a string (the\n//   style's value) for `style` rules.\n//\n//   contentElement:: ?union<string, (dom.Node) → dom.Node>\n//   For `tag` rules that produce non-leaf nodes or marks, by default\n//   the content of the DOM element is parsed as content of the mark\n//   or node. If the child nodes are in a descendent node, this may be\n//   a CSS selector string that the parser must use to find the actual\n//   content element, or a function that returns the actual content\n//   element to the parser.\n//\n//   getContent:: ?(dom.Node, schema: Schema) → Fragment\n//   Can be used to override the content of a matched node. When\n//   present, instead of parsing the node's child nodes, the result of\n//   this function is used.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   Controls whether whitespace should be preserved when parsing the\n//   content inside the matched element. `false` means whitespace may\n//   be collapsed, `true` means that whitespace should be preserved\n//   but newlines normalized to spaces, and `\"full\"` means that\n//   newlines should also be preserved.\n// ::- A DOM parser represents a strategy for parsing DOM content into\n// a ProseMirror document conforming to a given schema. Its behavior\n// is defined by an array of [rules](#model.ParseRule).\n\n\nvar DOMParser = function DOMParser(schema, rules) {\n  var this$1 = this; // :: Schema\n  // The schema into which the parser parses.\n\n  this.schema = schema; // :: [ParseRule]\n  // The set of [parse rules](#model.ParseRule) that the parser\n  // uses, in order of precedence.\n\n  this.rules = rules;\n  this.tags = [];\n  this.styles = [];\n  rules.forEach(function (rule) {\n    if (rule.tag) {\n      this$1.tags.push(rule);\n    } else if (rule.style) {\n      this$1.styles.push(rule);\n    }\n  }); // Only normalize list elements when lists in the schema can't directly contain themselves\n\n  this.normalizeLists = !this.tags.some(function (r) {\n    if (!/^(ul|ol)\\b/.test(r.tag) || !r.node) {\n      return false;\n    }\n\n    var node = schema.nodes[r.node];\n    return node.contentMatch.matchType(node);\n  });\n}; // :: (dom.Node, ?ParseOptions) → Node\n// Parse a document from the content of a DOM node.\n\n\nDOMParser.prototype.parse = function parse(dom, options) {\n  if (options === void 0) options = {};\n  var context = new ParseContext(this, options, false);\n  context.addAll(dom, null, options.from, options.to);\n  return context.finish();\n}; // :: (dom.Node, ?ParseOptions) → Slice\n// Parses the content of the given DOM node, like\n// [`parse`](#model.DOMParser.parse), and takes the same set of\n// options. But unlike that method, which produces a whole node,\n// this one returns a slice that is open at the sides, meaning that\n// the schema constraints aren't applied to the start of nodes to\n// the left of the input and the end of nodes at the end.\n\n\nDOMParser.prototype.parseSlice = function parseSlice(dom, options) {\n  if (options === void 0) options = {};\n  var context = new ParseContext(this, options, true);\n  context.addAll(dom, null, options.from, options.to);\n  return Slice.maxOpen(context.finish());\n};\n\nDOMParser.prototype.matchTag = function matchTag(dom, context) {\n  for (var i = 0; i < this.tags.length; i++) {\n    var rule = this.tags[i];\n\n    if (matches(dom, rule.tag) && (rule.namespace === undefined || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {\n      if (rule.getAttrs) {\n        var result = rule.getAttrs(dom);\n\n        if (result === false) {\n          continue;\n        }\n\n        rule.attrs = result;\n      }\n\n      return rule;\n    }\n  }\n};\n\nDOMParser.prototype.matchStyle = function matchStyle(prop, value, context) {\n  for (var i = 0; i < this.styles.length; i++) {\n    var rule = this.styles[i];\n\n    if (rule.style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,\n    // or has an '=' sign after the prop, followed by the given\n    // value.\n    rule.style.length > prop.length && (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value)) {\n      continue;\n    }\n\n    if (rule.getAttrs) {\n      var result = rule.getAttrs(value);\n\n      if (result === false) {\n        continue;\n      }\n\n      rule.attrs = result;\n    }\n\n    return rule;\n  }\n}; // : (Schema) → [ParseRule]\n\n\nDOMParser.schemaRules = function schemaRules(schema) {\n  var result = [];\n\n  function insert(rule) {\n    var priority = rule.priority == null ? 50 : rule.priority,\n        i = 0;\n\n    for (; i < result.length; i++) {\n      var next = result[i],\n          nextPriority = next.priority == null ? 50 : next.priority;\n\n      if (nextPriority < priority) {\n        break;\n      }\n    }\n\n    result.splice(i, 0, rule);\n  }\n\n  var loop = function (name) {\n    var rules = schema.marks[name].spec.parseDOM;\n\n    if (rules) {\n      rules.forEach(function (rule) {\n        insert(rule = copy(rule));\n        rule.mark = name;\n      });\n    }\n  };\n\n  for (var name in schema.marks) loop(name);\n\n  var loop$1 = function (name) {\n    var rules$1 = schema.nodes[name$1].spec.parseDOM;\n\n    if (rules$1) {\n      rules$1.forEach(function (rule) {\n        insert(rule = copy(rule));\n        rule.node = name$1;\n      });\n    }\n  };\n\n  for (var name$1 in schema.nodes) loop$1();\n\n  return result;\n}; // :: (Schema) → DOMParser\n// Construct a DOM parser using the parsing rules listed in a\n// schema's [node specs](#model.NodeSpec.parseDOM), reordered by\n// [priority](#model.ParseRule.priority).\n\n\nDOMParser.fromSchema = function fromSchema(schema) {\n  return schema.cached.domParser || (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)));\n}; // : Object<bool> The block-level tags in HTML5\n\n\nvar blockTags = {\n  address: true,\n  article: true,\n  aside: true,\n  blockquote: true,\n  canvas: true,\n  dd: true,\n  div: true,\n  dl: true,\n  fieldset: true,\n  figcaption: true,\n  figure: true,\n  footer: true,\n  form: true,\n  h1: true,\n  h2: true,\n  h3: true,\n  h4: true,\n  h5: true,\n  h6: true,\n  header: true,\n  hgroup: true,\n  hr: true,\n  li: true,\n  noscript: true,\n  ol: true,\n  output: true,\n  p: true,\n  pre: true,\n  section: true,\n  table: true,\n  tfoot: true,\n  ul: true\n}; // : Object<bool> The tags that we normally ignore.\n\nvar ignoreTags = {\n  head: true,\n  noscript: true,\n  object: true,\n  script: true,\n  style: true,\n  title: true\n}; // : Object<bool> List tags.\n\nvar listTags = {\n  ol: true,\n  ul: true\n}; // Using a bitfield for node context options\n\nvar OPT_PRESERVE_WS = 1,\n    OPT_PRESERVE_WS_FULL = 2,\n    OPT_OPEN_LEFT = 4;\n\nfunction wsOptionsFor(preserveWhitespace) {\n  return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0);\n}\n\nvar NodeContext = function NodeContext(type, attrs, marks, pendingMarks, solid, match, options) {\n  this.type = type;\n  this.attrs = attrs;\n  this.solid = solid;\n  this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);\n  this.options = options;\n  this.content = []; // Marks applied to this node itself\n\n  this.marks = marks; // Marks applied to its children\n\n  this.activeMarks = Mark.none; // Marks that can't apply here, but will be used in children if possible\n\n  this.pendingMarks = pendingMarks;\n};\n\nNodeContext.prototype.findWrapping = function findWrapping(node) {\n  if (!this.match) {\n    if (!this.type) {\n      return [];\n    }\n\n    var fill = this.type.contentMatch.fillBefore(Fragment.from(node));\n\n    if (fill) {\n      this.match = this.type.contentMatch.matchFragment(fill);\n    } else {\n      var start = this.type.contentMatch,\n          wrap;\n\n      if (wrap = start.findWrapping(node.type)) {\n        this.match = start;\n        return wrap;\n      } else {\n        return null;\n      }\n    }\n  }\n\n  return this.match.findWrapping(node.type);\n};\n\nNodeContext.prototype.finish = function finish(openEnd) {\n  if (!(this.options & OPT_PRESERVE_WS)) {\n    // Strip trailing whitespace\n    var last = this.content[this.content.length - 1],\n        m;\n\n    if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n      if (last.text.length == m[0].length) {\n        this.content.pop();\n      } else {\n        this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length));\n      }\n    }\n  }\n\n  var content = Fragment.from(this.content);\n\n  if (!openEnd && this.match) {\n    content = content.append(this.match.fillBefore(Fragment.empty, true));\n  }\n\n  return this.type ? this.type.create(this.attrs, content, this.marks) : content;\n};\n\nNodeContext.prototype.applyPending = function applyPending(nextType) {\n  for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {\n    var mark = pending[i];\n\n    if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) && !mark.isInSet(this.activeMarks)) {\n      this.activeMarks = mark.addToSet(this.activeMarks);\n      this.pendingMarks = mark.removeFromSet(this.pendingMarks);\n    }\n  }\n};\n\nvar ParseContext = function ParseContext(parser, options, open) {\n  // : DOMParser The parser we are using.\n  this.parser = parser; // : Object The options passed to this parse.\n\n  this.options = options;\n  this.isOpen = open;\n  var topNode = options.topNode,\n      topContext;\n  var topOptions = wsOptionsFor(options.preserveWhitespace) | (open ? OPT_OPEN_LEFT : 0);\n\n  if (topNode) {\n    topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);\n  } else if (open) {\n    topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions);\n  } else {\n    topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions);\n  }\n\n  this.nodes = [topContext]; // : [Mark] The current set of marks\n\n  this.open = 0;\n  this.find = options.findPositions;\n  this.needsBlock = false;\n};\n\nvar prototypeAccessors$6 = {\n  top: {\n    configurable: true\n  },\n  currentPos: {\n    configurable: true\n  }\n};\n\nprototypeAccessors$6.top.get = function () {\n  return this.nodes[this.open];\n}; // : (dom.Node)\n// Add a DOM node to the content. Text is inserted as text node,\n// otherwise, the node is passed to `addElement` or, if it has a\n// `style` attribute, `addElementWithStyles`.\n\n\nParseContext.prototype.addDOM = function addDOM(dom) {\n  if (dom.nodeType == 3) {\n    this.addTextNode(dom);\n  } else if (dom.nodeType == 1) {\n    var style = dom.getAttribute(\"style\");\n    var marks = style ? this.readStyles(parseStyles(style)) : null,\n        top = this.top;\n\n    if (marks != null) {\n      for (var i = 0; i < marks.length; i++) {\n        this.addPendingMark(marks[i]);\n      }\n    }\n\n    this.addElement(dom);\n\n    if (marks != null) {\n      for (var i$1 = 0; i$1 < marks.length; i$1++) {\n        this.removePendingMark(marks[i$1], top);\n      }\n    }\n  }\n};\n\nParseContext.prototype.addTextNode = function addTextNode(dom) {\n  var value = dom.nodeValue;\n  var top = this.top;\n\n  if ((top.type ? top.type.inlineContent : top.content.length && top.content[0].isInline) || /[^ \\t\\r\\n\\u000c]/.test(value)) {\n    if (!(top.options & OPT_PRESERVE_WS)) {\n      value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \"); // If this starts with whitespace, and there is no node before it, or\n      // a hard break, or a text node that ends with whitespace, strip the\n      // leading space.\n\n      if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n        var nodeBefore = top.content[top.content.length - 1];\n        var domNodeBefore = dom.previousSibling;\n\n        if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == 'BR' || nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text)) {\n          value = value.slice(1);\n        }\n      }\n    } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {\n      value = value.replace(/\\r?\\n|\\r/g, \" \");\n    }\n\n    if (value) {\n      this.insertNode(this.parser.schema.text(value));\n    }\n\n    this.findInText(dom);\n  } else {\n    this.findInside(dom);\n  }\n}; // : (dom.Element)\n// Try to find a handler for the given tag and use that to parse. If\n// none is found, the element's content nodes are added directly.\n\n\nParseContext.prototype.addElement = function addElement(dom) {\n  var name = dom.nodeName.toLowerCase();\n\n  if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) {\n    normalizeList(dom);\n  }\n\n  var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || this.parser.matchTag(dom, this);\n\n  if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n    this.findInside(dom);\n  } else if (!rule || rule.skip || rule.closeParent) {\n    if (rule && rule.closeParent) {\n      this.open = Math.max(0, this.open - 1);\n    } else if (rule && rule.skip.nodeType) {\n      dom = rule.skip;\n    }\n\n    var sync,\n        top = this.top,\n        oldNeedsBlock = this.needsBlock;\n\n    if (blockTags.hasOwnProperty(name)) {\n      sync = true;\n\n      if (!top.type) {\n        this.needsBlock = true;\n      }\n    } else if (!dom.firstChild) {\n      this.leafFallback(dom);\n      return;\n    }\n\n    this.addAll(dom);\n\n    if (sync) {\n      this.sync(top);\n    }\n\n    this.needsBlock = oldNeedsBlock;\n  } else {\n    this.addElementByRule(dom, rule);\n  }\n}; // Called for leaf DOM nodes that would otherwise be ignored\n\n\nParseContext.prototype.leafFallback = function leafFallback(dom) {\n  if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent) {\n    this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\"));\n  }\n}; // Run any style parser associated with the node's styles. Either\n// return an array of marks, or null to indicate some of the styles\n// had a rule with `ignore` set.\n\n\nParseContext.prototype.readStyles = function readStyles(styles) {\n  var marks = Mark.none;\n\n  for (var i = 0; i < styles.length; i += 2) {\n    var rule = this.parser.matchStyle(styles[i], styles[i + 1], this);\n\n    if (!rule) {\n      continue;\n    }\n\n    if (rule.ignore) {\n      return null;\n    }\n\n    marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks);\n  }\n\n  return marks;\n}; // : (dom.Element, ParseRule) → bool\n// Look up a handler for the given node. If none are found, return\n// false. Otherwise, apply it, use its return value to drive the way\n// the node's content is wrapped, and return true.\n\n\nParseContext.prototype.addElementByRule = function addElementByRule(dom, rule) {\n  var this$1 = this;\n  var sync, nodeType, markType, mark;\n\n  if (rule.node) {\n    nodeType = this.parser.schema.nodes[rule.node];\n\n    if (!nodeType.isLeaf) {\n      sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace);\n    } else if (!this.insertNode(nodeType.create(rule.attrs))) {\n      this.leafFallback(dom);\n    }\n  } else {\n    markType = this.parser.schema.marks[rule.mark];\n    mark = markType.create(rule.attrs);\n    this.addPendingMark(mark);\n  }\n\n  var startIn = this.top;\n\n  if (nodeType && nodeType.isLeaf) {\n    this.findInside(dom);\n  } else if (rule.getContent) {\n    this.findInside(dom);\n    rule.getContent(dom, this.parser.schema).forEach(function (node) {\n      return this$1.insertNode(node);\n    });\n  } else {\n    var contentDOM = rule.contentElement;\n\n    if (typeof contentDOM == \"string\") {\n      contentDOM = dom.querySelector(contentDOM);\n    } else if (typeof contentDOM == \"function\") {\n      contentDOM = contentDOM(dom);\n    }\n\n    if (!contentDOM) {\n      contentDOM = dom;\n    }\n\n    this.findAround(dom, contentDOM, true);\n    this.addAll(contentDOM, sync);\n  }\n\n  if (sync) {\n    this.sync(startIn);\n    this.open--;\n  }\n\n  if (mark) {\n    this.removePendingMark(mark, startIn);\n  }\n}; // : (dom.Node, ?NodeBuilder, ?number, ?number)\n// Add all child nodes between `startIndex` and `endIndex` (or the\n// whole node, if not given). If `sync` is passed, use it to\n// synchronize after every block element.\n\n\nParseContext.prototype.addAll = function addAll(parent, sync, startIndex, endIndex) {\n  var index = startIndex || 0;\n\n  for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {\n    this.findAtPoint(parent, index);\n    this.addDOM(dom);\n\n    if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase())) {\n      this.sync(sync);\n    }\n  }\n\n  this.findAtPoint(parent, index);\n}; // Try to find a way to fit the given node type into the current\n// context. May add intermediate wrappers and/or leave non-solid\n// nodes that we're in.\n\n\nParseContext.prototype.findPlace = function findPlace(node) {\n  var route, sync;\n\n  for (var depth = this.open; depth >= 0; depth--) {\n    var cx = this.nodes[depth];\n    var found = cx.findWrapping(node);\n\n    if (found && (!route || route.length > found.length)) {\n      route = found;\n      sync = cx;\n\n      if (!found.length) {\n        break;\n      }\n    }\n\n    if (cx.solid) {\n      break;\n    }\n  }\n\n  if (!route) {\n    return false;\n  }\n\n  this.sync(sync);\n\n  for (var i = 0; i < route.length; i++) {\n    this.enterInner(route[i], null, false);\n  }\n\n  return true;\n}; // : (Node) → ?Node\n// Try to insert the given node, adjusting the context when needed.\n\n\nParseContext.prototype.insertNode = function insertNode(node) {\n  if (node.isInline && this.needsBlock && !this.top.type) {\n    var block = this.textblockFromContext();\n\n    if (block) {\n      this.enterInner(block);\n    }\n  }\n\n  if (this.findPlace(node)) {\n    this.closeExtra();\n    var top = this.top;\n    top.applyPending(node.type);\n\n    if (top.match) {\n      top.match = top.match.matchType(node.type);\n    }\n\n    var marks = top.activeMarks;\n\n    for (var i = 0; i < node.marks.length; i++) {\n      if (!top.type || top.type.allowsMarkType(node.marks[i].type)) {\n        marks = node.marks[i].addToSet(marks);\n      }\n    }\n\n    top.content.push(node.mark(marks));\n    return true;\n  }\n\n  return false;\n}; // : (NodeType, ?Object) → bool\n// Try to start a node of the given type, adjusting the context when\n// necessary.\n\n\nParseContext.prototype.enter = function enter(type, attrs, preserveWS) {\n  var ok = this.findPlace(type.create(attrs));\n\n  if (ok) {\n    this.enterInner(type, attrs, true, preserveWS);\n  }\n\n  return ok;\n}; // Open a node of the given type\n\n\nParseContext.prototype.enterInner = function enterInner(type, attrs, solid, preserveWS) {\n  this.closeExtra();\n  var top = this.top;\n  top.applyPending(type);\n  top.match = top.match && top.match.matchType(type, attrs);\n  var options = preserveWS == null ? top.options & ~OPT_OPEN_LEFT : wsOptionsFor(preserveWS);\n\n  if (top.options & OPT_OPEN_LEFT && top.content.length == 0) {\n    options |= OPT_OPEN_LEFT;\n  }\n\n  this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));\n  this.open++;\n}; // Make sure all nodes above this.open are finished and added to\n// their parents\n\n\nParseContext.prototype.closeExtra = function closeExtra(openEnd) {\n  var i = this.nodes.length - 1;\n\n  if (i > this.open) {\n    for (; i > this.open; i--) {\n      this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));\n    }\n\n    this.nodes.length = this.open + 1;\n  }\n};\n\nParseContext.prototype.finish = function finish() {\n  this.open = 0;\n  this.closeExtra(this.isOpen);\n  return this.nodes[0].finish(this.isOpen || this.options.topOpen);\n};\n\nParseContext.prototype.sync = function sync(to) {\n  for (var i = this.open; i >= 0; i--) {\n    if (this.nodes[i] == to) {\n      this.open = i;\n      return;\n    }\n  }\n};\n\nprototypeAccessors$6.currentPos.get = function () {\n  this.closeExtra();\n  var pos = 0;\n\n  for (var i = this.open; i >= 0; i--) {\n    var content = this.nodes[i].content;\n\n    for (var j = content.length - 1; j >= 0; j--) {\n      pos += content[j].nodeSize;\n    }\n\n    if (i) {\n      pos++;\n    }\n  }\n\n  return pos;\n};\n\nParseContext.prototype.findAtPoint = function findAtPoint(parent, offset) {\n  if (this.find) {\n    for (var i = 0; i < this.find.length; i++) {\n      if (this.find[i].node == parent && this.find[i].offset == offset) {\n        this.find[i].pos = this.currentPos;\n      }\n    }\n  }\n};\n\nParseContext.prototype.findInside = function findInside(parent) {\n  if (this.find) {\n    for (var i = 0; i < this.find.length; i++) {\n      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n        this.find[i].pos = this.currentPos;\n      }\n    }\n  }\n};\n\nParseContext.prototype.findAround = function findAround(parent, content, before) {\n  if (parent != content && this.find) {\n    for (var i = 0; i < this.find.length; i++) {\n      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n        var pos = content.compareDocumentPosition(this.find[i].node);\n\n        if (pos & (before ? 2 : 4)) {\n          this.find[i].pos = this.currentPos;\n        }\n      }\n    }\n  }\n};\n\nParseContext.prototype.findInText = function findInText(textNode) {\n  if (this.find) {\n    for (var i = 0; i < this.find.length; i++) {\n      if (this.find[i].node == textNode) {\n        this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);\n      }\n    }\n  }\n}; // : (string) → bool\n// Determines whether the given [context\n// string](#ParseRule.context) matches this context.\n\n\nParseContext.prototype.matchesContext = function matchesContext(context) {\n  var this$1 = this;\n\n  if (context.indexOf(\"|\") > -1) {\n    return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this);\n  }\n\n  var parts = context.split(\"/\");\n  var option = this.options.context;\n  var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);\n  var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);\n\n  var match = function (i, depth) {\n    for (; i >= 0; i--) {\n      var part = parts[i];\n\n      if (part == \"\") {\n        if (i == parts.length - 1 || i == 0) {\n          continue;\n        }\n\n        for (; depth >= minDepth; depth--) {\n          if (match(i - 1, depth)) {\n            return true;\n          }\n        }\n\n        return false;\n      } else {\n        var next = depth > 0 || depth == 0 && useRoot ? this$1.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;\n\n        if (!next || next.name != part && next.groups.indexOf(part) == -1) {\n          return false;\n        }\n\n        depth--;\n      }\n    }\n\n    return true;\n  };\n\n  return match(parts.length - 1, this.open);\n};\n\nParseContext.prototype.textblockFromContext = function textblockFromContext() {\n  var $context = this.options.context;\n\n  if ($context) {\n    for (var d = $context.depth; d >= 0; d--) {\n      var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;\n\n      if (deflt && deflt.isTextblock && deflt.defaultAttrs) {\n        return deflt;\n      }\n    }\n  }\n\n  for (var name in this.parser.schema.nodes) {\n    var type = this.parser.schema.nodes[name];\n\n    if (type.isTextblock && type.defaultAttrs) {\n      return type;\n    }\n  }\n};\n\nParseContext.prototype.addPendingMark = function addPendingMark(mark) {\n  this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);\n};\n\nParseContext.prototype.removePendingMark = function removePendingMark(mark, upto) {\n  for (var depth = this.open; depth >= 0; depth--) {\n    var level = this.nodes[depth];\n    var found = level.pendingMarks.lastIndexOf(mark);\n\n    if (found > -1) {\n      level.pendingMarks = mark.removeFromSet(level.pendingMarks);\n    } else {\n      level.activeMarks = mark.removeFromSet(level.activeMarks);\n    }\n\n    if (level == upto) {\n      break;\n    }\n  }\n};\n\nObject.defineProperties(ParseContext.prototype, prototypeAccessors$6); // Kludge to work around directly nested list nodes produced by some\n// tools and allowed by browsers to mean that the nested list is\n// actually part of the list item above it.\n\nfunction normalizeList(dom) {\n  for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n    var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;\n\n    if (name && listTags.hasOwnProperty(name) && prevItem) {\n      prevItem.appendChild(child);\n      child = prevItem;\n    } else if (name == \"li\") {\n      prevItem = child;\n    } else if (name) {\n      prevItem = null;\n    }\n  }\n} // Apply a CSS selector.\n\n\nfunction matches(dom, selector) {\n  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);\n} // : (string) → [string]\n// Tokenize a style attribute into property/value pairs.\n\n\nfunction parseStyles(style) {\n  var re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g,\n      m,\n      result = [];\n\n  while (m = re.exec(style)) {\n    result.push(m[1], m[2].trim());\n  }\n\n  return result;\n}\n\nfunction copy(obj) {\n  var copy = {};\n\n  for (var prop in obj) {\n    copy[prop] = obj[prop];\n  }\n\n  return copy;\n} // Used when finding a mark at the top level of a fragment parse.\n// Checks whether it would be reasonable to apply a given mark type to\n// a given node, by looking at the way the mark occurs in the schema.\n\n\nfunction markMayApply(markType, nodeType) {\n  var nodes = nodeType.schema.nodes;\n\n  var loop = function (name) {\n    var parent = nodes[name];\n\n    if (!parent.allowsMarkType(markType)) {\n      return;\n    }\n\n    var seen = [],\n        scan = function (match) {\n      seen.push(match);\n\n      for (var i = 0; i < match.edgeCount; i++) {\n        var ref = match.edge(i);\n        var type = ref.type;\n        var next = ref.next;\n\n        if (type == nodeType) {\n          return true;\n        }\n\n        if (seen.indexOf(next) < 0 && scan(next)) {\n          return true;\n        }\n      }\n    };\n\n    if (scan(parent.contentMatch)) {\n      return {\n        v: true\n      };\n    }\n  };\n\n  for (var name in nodes) {\n    var returned = loop(name);\n    if (returned) return returned.v;\n  }\n} // DOMOutputSpec:: interface\n// A description of a DOM structure. Can be either a string, which is\n// interpreted as a text node, a DOM node, which is interpreted as\n// itself, or an array.\n//\n// An array describes a DOM element. The first value in the array\n// should be a string—the name of the DOM element, optionally prefixed\n// by a namespace URL and a space. If the second element is plain\n// object, it is interpreted as a set of attributes for the element.\n// Any elements after that (including the 2nd if it's not an attribute\n// object) are interpreted as children of the DOM elements, and must\n// either be valid `DOMOutputSpec` values, or the number zero.\n//\n// The number zero (pronounced “hole”) is used to indicate the place\n// where a node's child nodes should be inserted. If it occurs in an\n// output spec, it should be the only child element in its parent\n// node.\n// ::- A DOM serializer knows how to convert ProseMirror nodes and\n// marks of various types to DOM nodes.\n\n\nvar DOMSerializer = function DOMSerializer(nodes, marks) {\n  // :: Object<(node: Node) → DOMOutputSpec>\n  // The node serialization functions.\n  this.nodes = nodes || {}; // :: Object<?(mark: Mark, inline: bool) → DOMOutputSpec>\n  // The mark serialization functions.\n\n  this.marks = marks || {};\n}; // :: (Fragment, ?Object) → dom.DocumentFragment\n// Serialize the content of this fragment to a DOM fragment. When\n// not in the browser, the `document` option, containing a DOM\n// document, should be passed so that the serializer can create\n// nodes.\n\n\nDOMSerializer.prototype.serializeFragment = function serializeFragment(fragment, options, target) {\n  var this$1 = this;\n  if (options === void 0) options = {};\n\n  if (!target) {\n    target = doc(options).createDocumentFragment();\n  }\n\n  var top = target,\n      active = null;\n  fragment.forEach(function (node) {\n    if (active || node.marks.length) {\n      if (!active) {\n        active = [];\n      }\n\n      var keep = 0,\n          rendered = 0;\n\n      while (keep < active.length && rendered < node.marks.length) {\n        var next = node.marks[rendered];\n\n        if (!this$1.marks[next.type.name]) {\n          rendered++;\n          continue;\n        }\n\n        if (!next.eq(active[keep]) || next.type.spec.spanning === false) {\n          break;\n        }\n\n        keep += 2;\n        rendered++;\n      }\n\n      while (keep < active.length) {\n        top = active.pop();\n        active.pop();\n      }\n\n      while (rendered < node.marks.length) {\n        var add = node.marks[rendered++];\n        var markDOM = this$1.serializeMark(add, node.isInline, options);\n\n        if (markDOM) {\n          active.push(add, top);\n          top.appendChild(markDOM.dom);\n          top = markDOM.contentDOM || markDOM.dom;\n        }\n      }\n    }\n\n    top.appendChild(this$1.serializeNode(node, options));\n  });\n  return target;\n}; // :: (Node, ?Object) → dom.Node\n// Serialize this node to a DOM node. This can be useful when you\n// need to serialize a part of a document, as opposed to the whole\n// document. To serialize a whole document, use\n// [`serializeFragment`](#model.DOMSerializer.serializeFragment) on\n// its [content](#model.Node.content).\n\n\nDOMSerializer.prototype.serializeNode = function serializeNode(node, options) {\n  if (options === void 0) options = {};\n  var ref = DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node));\n  var dom = ref.dom;\n  var contentDOM = ref.contentDOM;\n\n  if (contentDOM) {\n    if (node.isLeaf) {\n      throw new RangeError(\"Content hole not allowed in a leaf node spec\");\n    }\n\n    if (options.onContent) {\n      options.onContent(node, contentDOM, options);\n    } else {\n      this.serializeFragment(node.content, options, contentDOM);\n    }\n  }\n\n  return dom;\n};\n\nDOMSerializer.prototype.serializeNodeAndMarks = function serializeNodeAndMarks(node, options) {\n  if (options === void 0) options = {};\n  var dom = this.serializeNode(node, options);\n\n  for (var i = node.marks.length - 1; i >= 0; i--) {\n    var wrap = this.serializeMark(node.marks[i], node.isInline, options);\n\n    if (wrap) {\n      (wrap.contentDOM || wrap.dom).appendChild(dom);\n      dom = wrap.dom;\n    }\n  }\n\n  return dom;\n};\n\nDOMSerializer.prototype.serializeMark = function serializeMark(mark, inline, options) {\n  if (options === void 0) options = {};\n  var toDOM = this.marks[mark.type.name];\n  return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline));\n}; // :: (dom.Document, DOMOutputSpec) → {dom: dom.Node, contentDOM: ?dom.Node}\n// Render an [output spec](#model.DOMOutputSpec) to a DOM node. If\n// the spec has a hole (zero) in it, `contentDOM` will point at the\n// node with the hole.\n\n\nDOMSerializer.renderSpec = function renderSpec(doc, structure, xmlNS) {\n  if (xmlNS === void 0) xmlNS = null;\n\n  if (typeof structure == \"string\") {\n    return {\n      dom: doc.createTextNode(structure)\n    };\n  }\n\n  if (structure.nodeType != null) {\n    return {\n      dom: structure\n    };\n  }\n\n  var tagName = structure[0],\n      space = tagName.indexOf(\" \");\n\n  if (space > 0) {\n    xmlNS = tagName.slice(0, space);\n    tagName = tagName.slice(space + 1);\n  }\n\n  var contentDOM = null,\n      dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName);\n  var attrs = structure[1],\n      start = 1;\n\n  if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n    start = 2;\n\n    for (var name in attrs) {\n      if (attrs[name] != null) {\n        var space$1 = name.indexOf(\" \");\n\n        if (space$1 > 0) {\n          dom.setAttributeNS(name.slice(0, space$1), name.slice(space$1 + 1), attrs[name]);\n        } else {\n          dom.setAttribute(name, attrs[name]);\n        }\n      }\n    }\n  }\n\n  for (var i = start; i < structure.length; i++) {\n    var child = structure[i];\n\n    if (child === 0) {\n      if (i < structure.length - 1 || i > start) {\n        throw new RangeError(\"Content hole must be the only child of its parent node\");\n      }\n\n      return {\n        dom: dom,\n        contentDOM: dom\n      };\n    } else {\n      var ref = DOMSerializer.renderSpec(doc, child, xmlNS);\n      var inner = ref.dom;\n      var innerContent = ref.contentDOM;\n      dom.appendChild(inner);\n\n      if (innerContent) {\n        if (contentDOM) {\n          throw new RangeError(\"Multiple content holes\");\n        }\n\n        contentDOM = innerContent;\n      }\n    }\n  }\n\n  return {\n    dom: dom,\n    contentDOM: contentDOM\n  };\n}; // :: (Schema) → DOMSerializer\n// Build a serializer using the [`toDOM`](#model.NodeSpec.toDOM)\n// properties in a schema's node and mark specs.\n\n\nDOMSerializer.fromSchema = function fromSchema(schema) {\n  return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));\n}; // : (Schema) → Object<(node: Node) → DOMOutputSpec>\n// Gather the serializers in a schema's node specs into an object.\n// This can be useful as a base to build a custom serializer from.\n\n\nDOMSerializer.nodesFromSchema = function nodesFromSchema(schema) {\n  var result = gatherToDOM(schema.nodes);\n\n  if (!result.text) {\n    result.text = function (node) {\n      return node.text;\n    };\n  }\n\n  return result;\n}; // : (Schema) → Object<(mark: Mark) → DOMOutputSpec>\n// Gather the serializers in a schema's mark specs into an object.\n\n\nDOMSerializer.marksFromSchema = function marksFromSchema(schema) {\n  return gatherToDOM(schema.marks);\n};\n\nfunction gatherToDOM(obj) {\n  var result = {};\n\n  for (var name in obj) {\n    var toDOM = obj[name].spec.toDOM;\n\n    if (toDOM) {\n      result[name] = toDOM;\n    }\n  }\n\n  return result;\n}\n\nfunction doc(options) {\n  // declare global: window\n  return options.document || window.document;\n}\n\nexport { ContentMatch, DOMParser, DOMSerializer, Fragment, Mark, MarkType, Node, NodeRange, NodeType, ReplaceError, ResolvedPos, Schema, Slice };","map":{"version":3,"sources":["../src/diff.js","../src/fragment.js","../src/comparedeep.js","../src/mark.js","../src/replace.js","../src/resolvedpos.js","../src/node.js","../src/content.js","../src/schema.js","../src/from_dom.js","../src/to_dom.js"],"names":["let","const","p","prototypeAccessors","n","prototypeAccessors$1","super","i","type","loop","next","states","prop","text","mark","this","name","rules","space"],"mappings":";;AAAO,SAAS,aAAT,CAAuB,CAAvB,EAA0B,CAA1B,EAA6B,GAA7B,EAAkC;AACvC,OAAKA,IAAI,CAAC,GAAG,CAAb,GAAiB,CAAC,EAAlB,EAAsB;AACpB,QAAI,CAAC,IAAI,CAAC,CAAC,UAAP,IAAqB,CAAC,IAAI,CAAC,CAAC,UAAhC,E;AACE,aAAO,CAAC,CAAC,UAAF,IAAgB,CAAC,CAAC,UAAlB,GAA+B,IAA/B,GAAsC,GAA7C;AAAgD;;AAElDA,QAAI,MAAM,GAAG,CAAC,CAAC,KAAF,CAAQ,CAAR,CAAbA;AAAAA,QAAyB,MAAM,GAAG,CAAC,CAAC,KAAF,CAAQ,CAAR,CAAlCA;;AACA,QAAI,MAAM,IAAI,MAAd,EAAsB;AAAE,MAAA,GAAG,IAAI,MAAM,CAAC,QAAd;AAAwB;AAAU;;AAE1D,QAAI,CAAC,MAAM,CAAC,UAAP,CAAkB,MAAlB,CAAL,EAA8B;AAAE,aAAO,GAAP;AAAU;;AAE1C,QAAI,MAAM,CAAC,MAAP,IAAiB,MAAM,CAAC,IAAP,IAAe,MAAM,CAAC,IAA3C,EAAiD;AAC/C,WAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,MAAM,CAAC,IAAP,CAAY,CAAZ,KAAkB,MAAM,CAAC,IAAP,CAAY,CAAZ,CAAlC,EAAkD,CAAC,EAAnD,E;AACE,QAAA,GAAG;AAAE;;AACP,aAAO,GAAP;AACD;;AACD,QAAI,MAAM,CAAC,OAAP,CAAe,IAAf,IAAuB,MAAM,CAAC,OAAP,CAAe,IAA1C,EAAgD;AAC9CA,UAAI,KAAK,GAAG,aAAa,CAAC,MAAM,CAAC,OAAR,EAAiB,MAAM,CAAC,OAAxB,EAAiC,GAAG,GAAG,CAAvC,CAAzBA;;AACA,UAAI,KAAK,IAAI,IAAb,EAAiB;AAAE,eAAO,KAAP;AAAY;AAChC;;AACD,IAAA,GAAG,IAAI,MAAM,CAAC,QAAd;AACD;AACF;;AAEM,SAAS,WAAT,CAAqB,CAArB,EAAwB,CAAxB,EAA2B,IAA3B,EAAiC,IAAjC,EAAuC;AAC5C,OAAKA,IAAI,EAAE,GAAG,CAAC,CAAC,UAAXA,EAAuB,EAAE,GAAG,CAAC,CAAC,UAAnC,IAAiD;AAC/C,QAAI,EAAE,IAAI,CAAN,IAAW,EAAE,IAAI,CAArB,E;AACE,aAAO,EAAE,IAAI,EAAN,GAAW,IAAX,GAAkB;AAAC,QAAA,CAAC,EAAE,IAAJ;AAAU,QAAA,CAAC,EAAE;AAAb,OAAzB;AAA2C;;AAE7CA,QAAI,MAAM,GAAG,CAAC,CAAC,KAAF,CAAQ,EAAE,EAAV,CAAbA;AAAAA,QAA4B,MAAM,GAAG,CAAC,CAAC,KAAF,CAAQ,EAAE,EAAV,CAArCA;AAAAA,QAAoD,IAAI,GAAG,MAAM,CAAC,QAAlEA;;AACA,QAAI,MAAM,IAAI,MAAd,EAAsB;AACpB,MAAA,IAAI,IAAI,IAAR;AAAc,MAAA,IAAI,IAAI,IAAR;AACd;AACD;;AAED,QAAI,CAAC,MAAM,CAAC,UAAP,CAAkB,MAAlB,CAAL,EAA8B;AAAE,aAAO;AAAC,QAAA,CAAC,EAAE,IAAJ;AAAU,QAAA,CAAC,EAAE;AAAb,OAAP;AAAyB;;AAEzD,QAAI,MAAM,CAAC,MAAP,IAAiB,MAAM,CAAC,IAAP,IAAe,MAAM,CAAC,IAA3C,EAAiD;AAC/CA,UAAI,IAAI,GAAG,CAAXA;AAAAA,UAAc,OAAO,GAAG,IAAI,CAAC,GAAL,CAAS,MAAM,CAAC,IAAP,CAAY,MAArB,EAA6B,MAAM,CAAC,IAAP,CAAY,MAAzC,CAAxBA;;AACA,aAAO,IAAI,GAAG,OAAP,IAAkB,MAAM,CAAC,IAAP,CAAY,MAAM,CAAC,IAAP,CAAY,MAAZ,GAAqB,IAArB,GAA4B,CAAxC,KAA8C,MAAM,CAAC,IAAP,CAAY,MAAM,CAAC,IAAP,CAAY,MAAZ,GAAqB,IAArB,GAA4B,CAAxC,CAAvE,EAAmH;AACjH,QAAA,IAAI;AAAI,QAAA,IAAI;AAAI,QAAA,IAAI;AACrB;;AACD,aAAO;AAAC,QAAA,CAAC,EAAE,IAAJ;AAAU,QAAA,CAAC,EAAE;AAAb,OAAP;AACD;;AACD,QAAI,MAAM,CAAC,OAAP,CAAe,IAAf,IAAuB,MAAM,CAAC,OAAP,CAAe,IAA1C,EAAgD;AAC9CA,UAAI,KAAK,GAAG,WAAW,CAAC,MAAM,CAAC,OAAR,EAAiB,MAAM,CAAC,OAAxB,EAAiC,IAAI,GAAG,CAAxC,EAA2C,IAAI,GAAG,CAAlD,CAAvBA;;AACA,UAAI,KAAJ,EAAS;AAAE,eAAO,KAAP;AAAY;AACxB;;AACD,IAAA,IAAI,IAAI,IAAR;AAAc,IAAA,IAAI,IAAI,IAAR;AACf;AACF,C;;;;;;;AC1CD,IAAa,QAAQ,GACnB,SAAA,QAAA,CAAY,OAAZ,EAAqB,IAArB,EAA2B;AACzB,OAAK,OAAL,GAAe,OAAf,CADyB,C;;;;AAKzB,OAAK,IAAL,GAAY,IAAI,IAAI,CAApB;;AACA,MAAI,IAAI,IAAI,IAAZ,EAAgB;AAAE,SAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,OAAO,CAAC,MAA5B,EAAoC,CAAC,EAArC,EAClB;AAAE,WAAK,IAAL,IAAa,OAAO,CAAC,CAAD,CAAP,CAAW,QAAxB;AAAwB;AAAQ;CARtC;;;;;;;;;;kBASG;;;;;;;AAMH,QAAA,CAAA,SAAA,CAAE,YAAF,GAAE,SAAA,YAAA,CAAa,IAAb,EAAmB,EAAnB,EAAuB,CAAvB,EAA0B,SAA1B,EAAyC,MAAzC,EAAiD;qCAAd,GAAG,C;;AACpC,OAAKA,IAAI,CAAC,GAAG,CAARA,EAAW,GAAG,GAAG,CAAtB,EAAyB,GAAG,GAAG,EAA/B,EAAmC,CAAC,EAApC,EAAwC;AACtCA,QAAI,KAAK,GAAG,KAAK,OAAL,CAAa,CAAb,CAAZA;AAAAA,QAA6B,GAAG,GAAG,GAAG,GAAG,KAAK,CAAC,QAA/CA;;AACF,QAAM,GAAG,GAAG,IAAN,IAAc,CAAC,CAAC,KAAD,EAAQ,SAAS,GAAG,GAApB,EAAyB,MAAzB,EAAiC,CAAjC,CAAD,KAAyC,KAAvD,IAAgE,KAAK,CAAC,OAAN,CAAc,IAApF,EAA0F;AACtFA,UAAI,KAAK,GAAG,GAAG,GAAG,CAAlBA;AACA,MAAA,KAAK,CAAC,YAAN,CAAmB,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,IAAI,GAAG,KAAnB,CAAnB,EACmB,IAAI,CAAC,GAAL,CAAS,KAAK,CAAC,OAAN,CAAc,IAAvB,EAA6B,EAAE,GAAG,KAAlC,CADnB,EAEmB,CAFnB,EAEsB,SAAS,GAAG,KAFlC;AAGD;;AACH,IAAA,GAAK,GAAG,GAAR;AACC;AACF,CAXH,C;;;;;AAgBA,QAAA,CAAA,SAAA,CAAE,WAAF,GAAE,SAAA,WAAA,CAAY,CAAZ,EAAe;AACf,OAAO,YAAP,CAAoB,CAApB,EAAuB,KAAK,IAA5B,EAAkC,CAAlC;AACC,CAFH,C;;;AAKA,QAAA,CAAA,SAAA,CAAE,WAAF,GAAE,SAAA,WAAA,CAAY,IAAZ,EAAkB,EAAlB,EAAsB,cAAtB,EAAsC,QAAtC,EAAgD;AAChD,MAAM,IAAI,GAAG,EAAb;AAAA,MAAiB,SAAS,GAAG,IAA7B;AACE,OAAK,YAAL,CAAkB,IAAlB,EAAwB,EAAxB,EAA0B,UAAG,IAAH,EAAS,GAAT,EAAc;AACtC,QAAI,IAAI,CAAC,MAAT,EAAiB;AACjB,MAAA,IAAM,IAAI,IAAI,CAAC,IAAL,CAAU,KAAV,CAAgB,IAAI,CAAC,GAAL,CAAS,IAAT,EAAe,GAAf,IAAsB,GAAtC,EAA2C,EAAE,GAAG,GAAhD,CAAV;AACA,MAAA,SAAW,GAAG,CAAC,cAAf;AACC,KAHD,MAGO,IAAI,IAAI,CAAC,MAAL,IAAe,QAAnB,EAA6B;AACpC,MAAA,IAAM,IAAI,QAAV;AACA,MAAA,SAAW,GAAG,CAAC,cAAf;AACC,KAHM,MAGA,IAAI,CAAC,SAAD,IAAc,IAAI,CAAC,OAAvB,EAAgC;AACvC,MAAA,IAAM,IAAI,cAAV;AACA,MAAA,SAAW,GAAG,IAAd;AACC;AACF,GAXD,EAWG,CAXH;AAYA,SAAO,IAAP;AACD,CAfH,C;;;;;AAoBA,QAAA,CAAA,SAAA,CAAE,MAAF,GAAE,SAAA,MAAA,CAAO,KAAP,EAAc;AACZ,MAAI,CAAC,KAAK,CAAC,IAAX,EAAe;AAAE,WAAO,IAAP;AAAW;;AAC5B,MAAI,CAAC,KAAK,IAAV,EAAc;AAAE,WAAO,KAAP;AAAY;;AAC9B,MAAM,IAAI,GAAG,KAAK,SAAlB;AAAA,MAA6B,KAAK,GAAG,KAAK,CAAC,UAA3C;AAAA,MAAuD,OAAO,GAAG,KAAK,OAAL,CAAa,KAAb,EAAjE;AAAA,MAAuF,CAAC,GAAG,CAA3F;;AACA,MAAM,IAAI,CAAC,MAAL,IAAe,IAAI,CAAC,UAAL,CAAgB,KAAhB,CAArB,EAA6C;AAC3C,IAAA,OAAS,CAAC,OAAO,CAAC,MAAR,GAAiB,CAAlB,CAAT,GAAgC,IAAI,CAAC,QAAL,CAAc,IAAI,CAAC,IAAL,GAAY,KAAK,CAAC,IAAhC,CAAhC;AACA,IAAA,CAAG,GAAG,CAAN;AACC;;AACH,SAAS,CAAC,GAAG,KAAK,CAAC,OAAN,CAAc,MAA3B,EAAmC,CAAC,EAApC,EAAsC;AAAE,IAAA,OAAO,CAAC,IAAR,CAAa,KAAK,CAAC,OAAN,CAAc,CAAd,CAAb;AAA8B;;AACpE,SAAO,IAAI,QAAJ,CAAa,OAAb,EAAsB,KAAK,IAAL,GAAY,KAAK,CAAC,IAAxC,CAAP;AACD,CAVH,C;;;;AAcA,QAAA,CAAA,SAAA,CAAE,GAAF,GAAE,SAAA,GAAA,CAAI,IAAJ,EAAU,EAAV,EAAc;AACd,MAAM,EAAE,IAAI,IAAZ,EAAgB;AAAE,IAAA,EAAE,GAAG,KAAK,IAAV;AAAc;;AAC9B,MAAI,IAAI,IAAI,CAAR,IAAa,EAAE,IAAI,KAAK,IAA5B,EAAgC;AAAE,WAAO,IAAP;AAAW;;AAC/C,MAAM,MAAM,GAAG,EAAf;AAAA,MAAmB,IAAI,GAAG,CAA1B;;AACA,MAAM,EAAE,GAAG,IAAX,EAAe;AAAE,SAAKA,IAAI,CAAC,GAAG,CAARA,EAAW,GAAG,GAAG,CAAtB,EAAyB,GAAG,GAAG,EAA/B,EAAmC,CAAC,EAApC,EAAwC;AACrDA,UAAI,KAAK,GAAG,KAAK,OAAL,CAAa,CAAb,CAAZA;AAAAA,UAA6B,GAAG,GAAG,GAAG,GAAG,KAAK,CAAC,QAA/CA;;AACA,UAAI,GAAG,GAAG,IAAV,EAAgB;AAChB,YAAM,GAAG,GAAG,IAAN,IAAc,GAAG,GAAG,EAA1B,EAA8B;AAC5B,cAAM,KAAK,CAAC,MAAZ,EACE;AAAE,YAAA,KAAK,GAAG,KAAK,CAAC,GAAN,CAAU,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,IAAI,GAAG,GAAnB,CAAV,EAAmC,IAAI,CAAC,GAAL,CAAS,KAAK,CAAC,IAAN,CAAW,MAApB,EAA4B,EAAE,GAAG,GAAjC,CAAnC,CAAR;AAAiF,WADrF,MAGE;AAAE,YAAA,KAAK,GAAG,KAAK,CAAC,GAAN,CAAU,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,IAAI,GAAG,GAAP,GAAa,CAAzB,CAAV,EAAuC,IAAI,CAAC,GAAL,CAAS,KAAK,CAAC,OAAN,CAAc,IAAvB,EAA6B,EAAE,GAAG,GAAL,GAAW,CAAxC,CAAvC,CAAR;AAA0F;AAC7F;;AACD,QAAA,MAAM,CAAC,IAAP,CAAY,KAAZ;AACA,QAAA,IAAI,IAAI,KAAK,CAAC,QAAd;AACD;;AACH,MAAA,GAAK,GAAG,GAAR;;AACC;;AACD,SAAO,IAAI,QAAJ,CAAa,MAAb,EAAqB,IAArB,CAAP;AACD,CAnBH;;AAqBA,QAAA,CAAA,SAAA,CAAE,UAAF,GAAE,SAAA,UAAA,CAAW,IAAX,EAAiB,EAAjB,EAAqB;AACrB,MAAM,IAAI,IAAI,EAAd,EAAgB;AAAE,WAAO,QAAQ,CAAC,KAAhB;AAAqB;;AACrC,MAAI,IAAI,IAAI,CAAR,IAAa,EAAE,IAAI,KAAK,OAAL,CAAa,MAApC,EAA0C;AAAE,WAAO,IAAP;AAAW;;AACvD,SAAO,IAAI,QAAJ,CAAa,KAAK,OAAL,CAAa,KAAb,CAAmB,IAAnB,EAAyB,EAAzB,CAAb,CAAP;AACD,CAJH,C;;;;;AASA,QAAA,CAAA,SAAA,CAAE,YAAF,GAAE,SAAA,YAAA,CAAa,KAAb,EAAoB,IAApB,EAA0B;AAC1B,MAAM,OAAO,GAAG,KAAK,OAAL,CAAa,KAAb,CAAhB;;AACE,MAAI,OAAO,IAAI,IAAf,EAAmB;AAAE,WAAO,IAAP;AAAW;;AAClC,MAAM,IAAI,GAAG,KAAK,OAAL,CAAa,KAAb,EAAb;AACEA,MAAI,IAAI,GAAG,KAAK,IAAL,GAAY,IAAI,CAAC,QAAjB,GAA4B,OAAO,CAAC,QAA/CA;AACA,EAAA,IAAI,CAAC,KAAD,CAAJ,GAAc,IAAd;AACA,SAAO,IAAI,QAAJ,CAAa,IAAb,EAAmB,IAAnB,CAAP;AACD,CAPH,C;;;;;AAYA,QAAA,CAAA,SAAA,CAAE,UAAF,GAAE,SAAA,UAAA,CAAW,IAAX,EAAiB;AACjB,SAAS,IAAI,QAAJ,CAAa,CAAC,IAAD,EAAO,MAAP,CAAc,KAAK,OAAnB,CAAb,EAA0C,KAAK,IAAL,GAAY,IAAI,CAAC,QAA3D,CAAT;AACC,CAFH,C;;;;;AAOA,QAAA,CAAA,SAAA,CAAE,QAAF,GAAE,SAAA,QAAA,CAAS,IAAT,EAAe;AACf,SAAS,IAAI,QAAJ,CAAa,KAAK,OAAL,CAAa,MAAb,CAAoB,IAApB,CAAb,EAAwC,KAAK,IAAL,GAAY,IAAI,CAAC,QAAzD,CAAT;AACC,CAFH,C;;;;AAMA,QAAA,CAAA,SAAA,CAAE,EAAF,GAAE,SAAA,EAAA,CAAG,KAAH,EAAU;AACR,MAAI,KAAK,OAAL,CAAa,MAAb,IAAuB,KAAK,CAAC,OAAN,CAAc,MAAzC,EAA+C;AAAE,WAAO,KAAP;AAAY;;AAC7D,OAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,OAAL,CAAa,MAAjC,EAAyC,CAAC,EAA1C,EACA;AAAE,QAAI,CAAC,KAAK,OAAL,CAAa,CAAb,EAAgB,EAAhB,CAAmB,KAAK,CAAC,OAAN,CAAc,CAAd,CAAnB,CAAL,EAAyC;AAAE,aAAO,KAAP;AAAO;AAAK;;AACzD,SAAO,IAAP;AACD,CALH,C;;;;AASE,kBAAA,CAAI,UAAJ,CAAI,GAAJ,GAAI,YAAa;AAAE,SAAO,KAAK,OAAL,CAAa,MAAb,GAAsB,KAAK,OAAL,CAAa,CAAb,CAAtB,GAAwC,IAA/C;AAAmD,CAAtE,C;;;;AAIF,kBAAA,CAAM,SAAN,CAAM,GAAN,GAAM,YAAY;AAAE,SAAO,KAAK,OAAL,CAAa,MAAb,GAAsB,KAAK,OAAL,CAAa,KAAK,OAAL,CAAa,MAAb,GAAsB,CAAnC,CAAtB,GAA8D,IAArE;AAAyE,CAA7F,C;;;;AAIA,kBAAA,CAAM,UAAN,CAAM,GAAN,GAAM,YAAa;AAAE,SAAO,KAAK,OAAL,CAAa,MAApB;AAA0B,CAA/C,C;;;;;AAKA,QAAA,CAAA,SAAA,CAAE,KAAF,GAAE,SAAA,KAAA,CAAM,KAAN,EAAa;AACb,MAAM,KAAK,GAAG,KAAK,OAAL,CAAa,KAAb,CAAd;;AACE,MAAI,CAAC,KAAL,EAAU;AAAE,UAAM,IAAI,UAAJ,CAAe,WAAW,KAAX,GAAmB,oBAAnB,GAA0C,IAAzD,CAAN;AAAoE;;AAChF,SAAO,KAAP;AACD,CAJH,C;;;;AAQA,QAAA,CAAA,SAAA,CAAE,UAAF,GAAE,SAAA,UAAA,CAAW,KAAX,EAAkB;AAChB,SAAO,KAAK,OAAL,CAAa,KAAb,CAAP;AACD,CAFH,C;;;;;AAOA,QAAA,CAAA,SAAA,CAAE,OAAF,GAAE,SAAA,OAAA,CAAQ,CAAR,EAAW;AACX,OAAOA,IAAI,CAAC,GAAG,CAARA,EAAW,CAAC,GAAG,CAAtB,EAAyB,CAAC,GAAG,KAAK,OAAL,CAAa,MAA1C,EAAkD,CAAC,EAAnD,EAAuD;AACrD,QAAM,KAAK,GAAG,KAAK,OAAL,CAAa,CAAb,CAAd;AACE,IAAA,CAAC,CAAC,KAAD,EAAQ,CAAR,EAAW,CAAX,CAAD;AACA,IAAA,CAAC,IAAI,KAAK,CAAC,QAAX;AACD;AACF,CANH,C;;;;;AAWA,QAAA,CAAA,SAAA,CAAE,aAAF,GAAE,SAAA,eAAA,CAAc,KAAd,EAAqB,GAArB,EAA8B;yBAAN,GAAG,C;AAC3B,SAAS,aAAa,CAAC,IAAD,EAAO,KAAP,EAAc,GAAd,CAAtB;AACC,CAFH,C;;;;;;;AASA,QAAA,CAAA,SAAA,CAAE,WAAF,GAAE,SAAA,aAAA,CAAY,KAAZ,EAAmB,GAAnB,EAAoC,QAApC,EAA2D;yBAArC,GAAG,KAAK,I;mCAAc,GAAG,KAAK,CAAC,I;AACrD,SAAS,WAAW,CAAC,IAAD,EAAO,KAAP,EAAc,GAAd,EAAmB,QAAnB,CAApB;AACC,CAFH,C;;;;;;AAQA,QAAA,CAAA,SAAA,CAAE,SAAF,GAAE,SAAA,SAAA,CAAU,GAAV,EAAe,KAAf,EAA2B;6BAAP,GAAG,CAAC,C;;AACxB,MAAM,GAAG,IAAI,CAAb,EAAc;AAAE,WAAO,QAAQ,CAAC,CAAD,EAAI,GAAJ,CAAf;AAAuB;;AACrC,MAAI,GAAG,IAAI,KAAK,IAAhB,EAAoB;AAAE,WAAO,QAAQ,CAAC,KAAK,OAAL,CAAa,MAAd,EAAsB,GAAtB,CAAf;AAAyC;;AACjE,MAAM,GAAG,GAAG,KAAK,IAAX,IAAmB,GAAG,GAAG,CAA/B,EAAgC;AAAE,UAAM,IAAI,UAAJ,CAAc,cAAa,GAAb,GAAgB,wBAAhB,GAAyC,IAAzC,GAA6C,GAA3D,CAAN;AAAqE;;AACrG,OAAKA,IAAI,CAAC,GAAG,CAARA,EAAW,MAAM,GAAG,CAAzB,GAA6B,CAAC,EAA9B,EAAkC;AAChCA,QAAI,GAAG,GAAG,KAAK,KAAL,CAAW,CAAX,CAAVA;AAAAA,QAAyB,GAAG,GAAG,MAAM,GAAG,GAAG,CAAC,QAA5CA;;AACA,QAAI,GAAG,IAAI,GAAX,EAAgB;AACd,UAAI,GAAG,IAAI,GAAP,IAAc,KAAK,GAAG,CAA1B,EAA2B;AAAE,eAAO,QAAQ,CAAC,CAAC,GAAG,CAAL,EAAQ,GAAR,CAAf;AAA2B;;AACxD,aAAO,QAAQ,CAAC,CAAD,EAAI,MAAJ,CAAf;AACD;;AACH,IAAA,MAAQ,GAAG,GAAX;AACC;AACF,CAZH,C;;;;AAgBA,QAAA,CAAA,SAAA,CAAE,QAAF,GAAE,SAAA,QAAA,GAAW;AAAE,SAAO,MAAM,KAAK,aAAL,EAAN,GAA6B,GAApC;AAAuC,CAAtD;;AAEA,QAAA,CAAA,SAAA,CAAE,aAAF,GAAE,SAAA,aAAA,GAAgB;AAAE,SAAO,KAAK,OAAL,CAAa,IAAb,CAAkB,IAAlB,CAAP;AAA8B,CAAlD,C;;;;AAIA,QAAA,CAAA,SAAA,CAAE,MAAF,GAAE,SAAA,MAAA,GAAS;AACT,SAAS,KAAK,OAAL,CAAa,MAAb,GAAsB,KAAK,OAAL,CAAa,GAAb,CAAgB,UAAC,CAAD,EAAG;AAAA,WAAG,CAAC,CAAC,MAAF,EAAH;AAAa,GAAhC,CAAtB,GAA0D,IAAnE;AACC,CAFH,C;;;;AAME,QAAA,CAAO,QAAP,GAAO,SAAA,QAAA,CAAS,MAAT,EAAiB,KAAjB,EAAwB;AAC7B,MAAI,CAAC,KAAL,EAAU;AAAE,WAAO,QAAQ,CAAC,KAAhB;AAAqB;;AACjC,MAAI,CAAC,KAAK,CAAC,OAAN,CAAc,KAAd,CAAL,EAAyB;AAAE,UAAM,IAAI,UAAJ,CAAe,qCAAf,CAAN;AAA2D;;AACtF,SAAO,IAAI,QAAJ,CAAa,KAAK,CAAC,GAAN,CAAU,MAAM,CAAC,YAAjB,CAAb,CAAP;AACD,CAJD,C;;;;;AASA,QAAA,CAAO,SAAP,GAAO,SAAA,SAAA,CAAU,KAAV,EAAiB;AACxB,MAAM,CAAC,KAAK,CAAC,MAAb,EAAmB;AAAE,WAAO,QAAQ,CAAC,KAAhB;AAAqB;;AACxCA,MAAI,MAAJA;AAAAA,MAAY,IAAI,GAAG,CAAnBA;;AACA,OAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,EAAnC,EAAuC;AACrCA,QAAI,IAAI,GAAG,KAAK,CAAC,CAAD,CAAhBA;AACA,IAAA,IAAI,IAAI,IAAI,CAAC,QAAb;;AACA,QAAI,CAAC,IAAI,IAAI,CAAC,MAAV,IAAoB,KAAK,CAAC,CAAC,GAAG,CAAL,CAAL,CAAa,UAAb,CAAwB,IAAxB,CAAxB,EAAuD;AACrD,UAAI,CAAC,MAAL,EAAW;AAAE,QAAA,MAAM,GAAG,KAAK,CAAC,KAAN,CAAY,CAAZ,EAAe,CAAf,CAAT;AAA0B;;AACzC,MAAA,MAAQ,CAAC,MAAM,CAAC,MAAP,GAAgB,CAAjB,CAAR,GAA8B,IAAI,CAAC,QAAL,CAAc,MAAM,CAAC,MAAM,CAAC,MAAP,GAAgB,CAAjB,CAAN,CAA0B,IAA1B,GAAiC,IAAI,CAAC,IAApD,CAA9B;AACC,KAHD,MAGO,IAAI,MAAJ,EAAY;AACjB,MAAA,MAAM,CAAC,IAAP,CAAY,IAAZ;AACD;AACF;;AACH,SAAS,IAAI,QAAJ,CAAa,MAAM,IAAI,KAAvB,EAA8B,IAA9B,CAAT;AACC,CAdD,C;;;;;;;AAqBA,QAAA,CAAO,IAAP,GAAO,SAAA,IAAA,CAAK,KAAL,EAAY;AACjB,MAAI,CAAC,KAAL,EAAU;AAAE,WAAO,QAAQ,CAAC,KAAhB;AAAqB;;AACjC,MAAI,KAAK,YAAY,QAArB,EAA6B;AAAE,WAAO,KAAP;AAAY;;AAC3C,MAAI,KAAK,CAAC,OAAN,CAAc,KAAd,CAAJ,EAAwB;AAAE,WAAO,KAAK,SAAL,CAAe,KAAf,CAAP;AAA4B;;AACtD,MAAI,KAAK,CAAC,KAAV,EAAe;AAAE,WAAO,IAAI,QAAJ,CAAa,CAAC,KAAD,CAAb,EAAsB,KAAK,CAAC,QAA5B,CAAP;AAA4C;;AAC/D,QAAQ,IAAI,UAAJ,CAAe,qBAAqB,KAArB,GAA6B,gBAA7B,IACC,KAAK,CAAC,YAAN,GAAqB,kEAArB,GAA0F,EAD3F,CAAf,CAAR;AAEC,CAPD;;4CAQD,kB;AAEDC,IAAM,KAAK,GAAG;AAAC,EAAA,KAAK,EAAE,CAAR;AAAW,EAAA,MAAM,EAAE;AAAnB,CAAdA;;AACA,SAAS,QAAT,CAAkB,KAAlB,EAAyB,MAAzB,EAAiC;AAC/B,EAAA,KAAK,CAAC,KAAN,GAAc,KAAd;AACA,EAAA,KAAK,CAAC,MAAN,GAAe,MAAf;AACA,SAAO,KAAP;AACD,C;;;;;;AAMD,QAAQ,CAAC,KAAT,GAAiB,IAAI,QAAJ,CAAa,EAAb,EAAiB,CAAjB,CAAjB;;ACpRO,SAAS,WAAT,CAAqB,CAArB,EAAwB,CAAxB,EAA2B;AAChC,MAAI,CAAC,KAAK,CAAV,EAAW;AAAE,WAAO,IAAP;AAAW;;AACxB,MAAI,EAAE,CAAC,IAAI,OAAO,CAAP,IAAY,QAAnB,KACA,EAAE,CAAC,IAAI,OAAO,CAAP,IAAY,QAAnB,CADJ,EACgC;AAAE,WAAO,KAAP;AAAY;;AAC9CD,MAAI,KAAK,GAAG,KAAK,CAAC,OAAN,CAAc,CAAd,CAAZA;;AACA,MAAI,KAAK,CAAC,OAAN,CAAc,CAAd,KAAoB,KAAxB,EAA6B;AAAE,WAAO,KAAP;AAAY;;AAC3C,MAAI,KAAJ,EAAW;AACT,QAAI,CAAC,CAAC,MAAF,IAAY,CAAC,CAAC,MAAlB,EAAwB;AAAE,aAAO,KAAP;AAAY;;AACtC,SAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,CAAC,CAAC,MAAtB,EAA8B,CAAC,EAA/B,EAAiC;AAAE,UAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAD,CAAF,EAAO,CAAC,CAAC,CAAD,CAAR,CAAhB,EAA4B;AAAE,eAAO,KAAP;AAAO;AAAK;AAC9E,GAHD,MAGO;AACL,SAAKA,IAAI,CAAT,IAAc,CAAd,EAAe;AAAE,UAAI,EAAE,CAAC,IAAI,CAAP,KAAa,CAAC,WAAW,CAAC,CAAC,CAAC,CAAD,CAAF,EAAO,CAAC,CAAC,CAAD,CAAR,CAA7B,EAAyC;AAAE,eAAO,KAAP;AAAO;AAAK;;AACxE,SAAKA,IAAIE,GAAT,IAAc,CAAd,EAAe;AAAE,UAAI,EAAEA,GAAC,IAAI,CAAP,CAAJ,EAAa;AAAE,eAAO,KAAP;AAAO;AAAK;AAC7C;;AACD,SAAO,IAAP;AACD,C;;;;;;;;ACND,IAAa,IAAI,GACf,SAAA,IAAA,CAAY,IAAZ,EAAkB,KAAlB,EAAyB;;;AAGvB,OAAK,IAAL,GAAY,IAAZ,CAHuB,C;;;AAMvB,OAAK,KAAL,GAAa,KAAb;AACD,CARH,C;;;;;;;;AAgBA,IAAA,CAAA,SAAA,CAAE,QAAF,GAAE,SAAA,QAAA,CAAS,GAAT,EAAc;AACZF,MAAI,IAAJA;AAAAA,MAAU,MAAM,GAAG,KAAnBA;;AACA,OAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAAG,CAAC,MAAxB,EAAgC,CAAC,EAAjC,EAAqC;AACnCA,QAAI,KAAK,GAAG,GAAG,CAAC,CAAD,CAAfA;;AACF,QAAM,KAAK,EAAL,CAAQ,KAAR,CAAN,EAAoB;AAAE,aAAO,GAAP;AAAU;;AAChC,QAAM,KAAK,IAAL,CAAU,QAAV,CAAmB,KAAK,CAAC,IAAzB,CAAN,EAAsC;AAClC,UAAI,CAAC,IAAL,EAAS;AAAE,QAAA,IAAI,GAAG,GAAG,CAAC,KAAJ,CAAU,CAAV,EAAa,CAAb,CAAP;AAAsB;AAClC,KAFH,MAES,IAAI,KAAK,CAAC,IAAN,CAAW,QAAX,CAAoB,KAAK,IAAzB,CAAJ,EAAoC;AACzC,aAAO,GAAP;AACD,KAFM,MAEA;AACL,UAAI,CAAC,MAAD,IAAW,KAAK,CAAC,IAAN,CAAW,IAAX,GAAkB,KAAK,IAAL,CAAU,IAA3C,EAAiD;AAC/C,YAAI,CAAC,IAAL,EAAS;AAAE,UAAA,IAAI,GAAG,GAAG,CAAC,KAAJ,CAAU,CAAV,EAAa,CAAb,CAAP;AAAsB;;AACjC,QAAA,IAAI,CAAC,IAAL,CAAU,IAAV;AACF,QAAA,MAAQ,GAAG,IAAX;AACC;;AACH,UAAM,IAAN,EAAU;AAAE,QAAA,IAAI,CAAC,IAAL,CAAU,KAAV;AAAgB;AAC3B;AACF;;AACH,MAAM,CAAC,IAAP,EAAW;AAAE,IAAA,IAAI,GAAG,GAAG,CAAC,KAAJ,EAAP;AAAkB;;AAC/B,MAAM,CAAC,MAAP,EAAa;AAAE,IAAA,IAAI,CAAC,IAAL,CAAU,IAAV;AAAe;;AAC5B,SAAO,IAAP;AACD,CArBH,C;;;;;AA0BA,IAAA,CAAA,SAAA,CAAE,aAAF,GAAE,SAAA,aAAA,CAAc,GAAd,EAAmB;AACjB,OAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAAG,CAAC,MAAxB,EAAgC,CAAC,EAAjC,EACA;AAAE,QAAI,KAAK,EAAL,CAAQ,GAAG,CAAC,CAAD,CAAX,CAAJ,EACA;AAAE,aAAO,GAAG,CAAC,KAAJ,CAAU,CAAV,EAAa,CAAb,EAAgB,MAAhB,CAAuB,GAAG,CAAC,KAAJ,CAAU,CAAC,GAAG,CAAd,CAAvB,CAAP;AAA8C;AAAC;;AACnD,SAAO,GAAP;AACD,CALH,C;;;;AASA,IAAA,CAAA,SAAA,CAAE,OAAF,GAAE,SAAA,OAAA,CAAQ,GAAR,EAAa;AACX,OAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAAG,CAAC,MAAxB,EAAgC,CAAC,EAAjC,EACA;AAAE,QAAI,KAAK,EAAL,CAAQ,GAAG,CAAC,CAAD,CAAX,CAAJ,EAAmB;AAAE,aAAO,IAAP;AAAO;AAAI;;AAClC,SAAO,KAAP;AACD,CAJH,C;;;;;AASA,IAAA,CAAA,SAAA,CAAE,EAAF,GAAE,SAAA,EAAA,CAAG,KAAH,EAAU;AACV,SAAS,QAAQ,KAAR,IACJ,KAAK,IAAL,IAAa,KAAK,CAAC,IAAnB,IAA2B,WAAW,CAAC,KAAK,KAAN,EAAa,KAAK,CAAC,KAAnB,CAD3C;AAEC,CAHH,C;;;;AAOA,IAAA,CAAA,SAAA,CAAE,MAAF,GAAE,SAAA,MAAA,GAAS;AACPA,MAAI,GAAG,GAAG;AAAC,IAAA,IAAI,EAAE,KAAK,IAAL,CAAU;AAAjB,GAAVA;;AACF,OAAOA,IAAI,CAAX,IAAgB,KAAK,KAArB,EAA4B;AACxB,IAAA,GAAG,CAAC,KAAJ,GAAY,KAAK,KAAjB;AACA;AACD;;AACD,SAAO,GAAP;AACD,CAPH,C;;;AAUE,IAAA,CAAO,QAAP,GAAO,SAAA,QAAA,CAAS,MAAT,EAAiB,IAAjB,EAAuB;AAC9B,MAAM,CAAC,IAAP,EAAW;AAAE,UAAM,IAAI,UAAJ,CAAe,iCAAf,CAAN;AAAuD;;AACpE,MAAM,IAAI,GAAG,MAAM,CAAC,KAAP,CAAa,IAAI,CAAC,IAAlB,CAAb;;AACE,MAAI,CAAC,IAAL,EAAS;AAAE,UAAM,IAAI,UAAJ,CAAc,2BAA0B,IAAI,CAAC,IAA/B,GAAmC,iBAAjD,CAAN;AAAyE;;AACtF,SAAS,IAAI,CAAC,MAAL,CAAY,IAAI,CAAC,KAAjB,CAAT;AACC,CALD,C;;;;AASA,IAAA,CAAO,OAAP,GAAO,SAAA,OAAA,CAAQ,CAAR,EAAW,CAAX,EAAc;AACnB,MAAI,CAAC,IAAI,CAAT,EAAU;AAAE,WAAO,IAAP;AAAW;;AACzB,MAAM,CAAC,CAAC,MAAF,IAAY,CAAC,CAAC,MAApB,EAA0B;AAAE,WAAO,KAAP;AAAY;;AACtC,OAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,CAAC,CAAC,MAAtB,EAA8B,CAAC,EAA/B,EACA;AAAE,QAAI,CAAC,CAAC,CAAC,CAAD,CAAD,CAAK,EAAL,CAAQ,CAAC,CAAC,CAAD,CAAT,CAAL,EAAkB;AAAE,aAAO,KAAP;AAAO;AAAK;;AAClC,SAAO,IAAP;AACD,CAND,C;;;;;AAWA,IAAA,CAAO,OAAP,GAAO,SAAA,OAAA,CAAQ,KAAR,EAAe;AACpB,MAAI,CAAC,KAAD,IAAU,KAAK,CAAC,MAAN,IAAgB,CAA9B,EAA+B;AAAE,WAAO,IAAI,CAAC,IAAZ;AAAgB;;AACnD,MAAM,KAAK,YAAY,IAAvB,EAA2B;AAAE,WAAO,CAAC,KAAD,CAAP;AAAc;;AACzCA,MAAI,IAAI,GAAG,KAAK,CAAC,KAAN,EAAXA;AACF,EAAA,IAAM,CAAC,IAAP,CAAW,UAAE,CAAF,EAAK,CAAL,EAAQ;AAAA,WAAG,CAAC,CAAC,IAAF,CAAO,IAAP,GAAc,CAAC,CAAC,IAAF,CAAO,IAAxB;AAA4B,GAA/C;AACE,SAAO,IAAP;AACD,CAND,C;;;AAUF,IAAI,CAAC,IAAL,GAAY,EAAZ,C;;;;AC7GO,SAAS,YAAT,CAAsB,OAAtB,EAA+B;AACpCA,MAAI,GAAG,GAAG,KAAK,CAAC,IAAN,CAAW,IAAX,EAAiB,OAAjB,CAAVA;AACA,EAAA,GAAG,CAAC,SAAJ,GAAgB,YAAY,CAAC,SAA7B;AACA,SAAO,GAAP;AACD;;AAED,YAAY,CAAC,SAAb,GAAyB,MAAM,CAAC,MAAP,CAAc,KAAK,CAAC,SAApB,CAAzB;AACA,YAAY,CAAC,SAAb,CAAuB,WAAvB,GAAqC,YAArC;AACA,YAAY,CAAC,SAAb,CAAuB,IAAvB,GAA8B,cAA9B,C;;;;AAKA,IAAa,KAAK,GAWhB,SAAA,KAAA,CAAY,OAAZ,EAAqB,SAArB,EAAgC,OAAhC,EAAyC;;AAEvC,OAAK,OAAL,GAAe,OAAf,CAFuC,C;;AAIvC,OAAK,SAAL,GAAiB,SAAjB,CAJuC,C;;AAMvC,OAAK,OAAL,GAAe,OAAf;CAjBJ;;;;kBAkBG;;;;;AAIHG,oBAAAA,CAAM,IAANA,CAAM,GAANA,GAAM,YAAO;AACT,SAAO,KAAK,OAAL,CAAa,IAAb,GAAoB,KAAK,SAAzB,GAAqC,KAAK,OAAjD;AACD,CAFHA;;AAIA,KAAA,CAAA,SAAA,CAAE,QAAF,GAAE,SAAA,QAAA,CAAS,GAAT,EAAc,QAAd,EAAwB;AACtBH,MAAI,OAAO,GAAG,UAAU,CAAC,KAAK,OAAN,EAAe,GAAG,GAAG,KAAK,SAA1B,EAAqC,QAArC,EAA+C,IAA/C,CAAxBA;AACA,SAAO,OAAO,IAAI,IAAI,KAAJ,CAAU,OAAV,EAAmB,KAAK,SAAxB,EAAmC,KAAK,OAAxC,CAAlB;AACD,CAHH;;AAKA,KAAA,CAAA,SAAA,CAAE,aAAF,GAAE,SAAA,aAAA,CAAc,IAAd,EAAoB,EAApB,EAAwB;AACtB,SAAO,IAAI,KAAJ,CAAU,WAAW,CAAC,KAAK,OAAN,EAAe,IAAI,GAAG,KAAK,SAA3B,EAAsC,EAAE,GAAG,KAAK,SAAhD,CAArB,EAAiF,KAAK,SAAtF,EAAiG,KAAK,OAAtG,CAAP;AACD,CAFH,C;;;;AAMA,KAAA,CAAA,SAAA,CAAE,EAAF,GAAE,SAAA,EAAA,CAAG,KAAH,EAAU;AACV,SAAS,KAAK,OAAL,CAAa,EAAb,CAAgB,KAAK,CAAC,OAAtB,KAAkC,KAAK,SAAL,IAAkB,KAAK,CAAC,SAA1D,IAAuE,KAAK,OAAL,IAAgB,KAAK,CAAC,OAAtG;AACC,CAFH;;AAIA,KAAA,CAAA,SAAA,CAAE,QAAF,GAAE,SAAA,QAAA,GAAW;AACT,SAAO,KAAK,OAAL,GAAe,GAAf,GAAqB,KAAK,SAA1B,GAAsC,GAAtC,GAA4C,KAAK,OAAjD,GAA2D,GAAlE;AACD,CAFH,C;;;;AAMA,KAAA,CAAA,SAAA,CAAE,MAAF,GAAE,SAAA,MAAA,GAAS;AACT,MAAM,CAAC,KAAK,OAAL,CAAa,IAApB,EAAwB;AAAE,WAAO,IAAP;AAAW;;AACnCA,MAAI,IAAI,GAAG;AAAC,IAAA,OAAO,EAAE,KAAK,OAAL,CAAa,MAAb;AAAV,GAAXA;;AACA,MAAI,KAAK,SAAL,GAAiB,CAArB,EAAsB;AAAE,IAAA,IAAI,CAAC,SAAL,GAAiB,KAAK,SAAtB;AAA+B;;AACvD,MAAI,KAAK,OAAL,GAAe,CAAnB,EAAoB;AAAE,IAAA,IAAI,CAAC,OAAL,GAAe,KAAK,OAApB;AAA2B;;AACjD,SAAO,IAAP;AACD,CANH,C;;;;AAUE,KAAA,CAAO,QAAP,GAAO,SAAA,QAAA,CAAS,MAAT,EAAiB,IAAjB,EAAuB;AAC5B,MAAI,CAAC,IAAL,EAAS;AAAE,WAAO,KAAK,CAAC,KAAb;AAAkB;;AAC7BA,MAAI,SAAS,GAAG,IAAI,CAAC,SAAL,IAAkB,CAAlCA;AAAAA,MAAqC,OAAO,GAAG,IAAI,CAAC,OAAL,IAAgB,CAA/DA;;AACF,MAAM,OAAO,SAAP,IAAoB,QAApB,IAAgC,OAAO,OAAP,IAAkB,QAAxD,EACE;AAAE,UAAM,IAAI,UAAJ,CAAe,kCAAf,CAAN;AAAwD;;AAC1D,SAAO,IAAI,KAAJ,CAAU,QAAQ,CAAC,QAAT,CAAkB,MAAlB,EAA0B,IAAI,CAAC,OAA/B,CAAV,EAAmD,SAAnD,EAA8D,OAA9D,CAAP;AACD,CAND,C;;;;;AAWA,KAAA,CAAO,OAAP,GAAO,SAAA,OAAA,CAAQ,QAAR,EAAkB,aAAlB,EAAsC;6CAAP,GAAC,I;AACvC,MAAM,SAAS,GAAG,CAAlB;AAAA,MAAqB,OAAO,GAAG,CAA/B;;AACE,OAAKA,IAAI,CAAC,GAAG,QAAQ,CAAC,UAAtB,EAAkC,CAAC,IAAI,CAAC,CAAC,CAAC,MAAR,KAAmB,aAAa,IAAI,CAAC,CAAC,CAAC,IAAF,CAAO,IAAP,CAAY,SAAjD,CAAlC,EAA+F,CAAC,GAAG,CAAC,CAAC,UAArG,EAA+G;AAAE,IAAA,SAAS;AAAE;;AAC5H,OAAKA,IAAII,GAAC,GAAG,QAAQ,CAAC,SAAtB,EAAiCA,GAAC,IAAI,CAACA,GAAC,CAAC,MAARA,KAAmB,aAAa,IAAI,CAACA,GAAC,CAAC,IAAFA,CAAO,IAAPA,CAAY,SAAjDA,CAAjC,EAA8FA,GAAC,GAAGA,GAAC,CAAC,SAApG,EAA6G;AAAE,IAAA,OAAO;AAAE;;AAC1H,SAAS,IAAI,KAAJ,CAAU,QAAV,EAAoB,SAApB,EAA+B,OAA/B,CAAT;AACC,CALD;;yCAMD,oB;;AAED,SAAS,WAAT,CAAqB,OAArB,EAA8B,IAA9B,EAAoC,EAApC,EAAwC;AACtC,MAAA,GAAmB,GAAG,OAAO,CAAC,SAAR,CAAkB,IAAlB,CAAtB;AAAK,MAAA,KAAA,GAAA,GAAA,CAAA,KAAA;AAAO,MAAA,MAAA,GAAA,GAAA,CAAA,MAAA;AAAiC,MAAE,KAAK,GAAG,OAAO,CAAC,UAAR,CAAmB,KAAnB,CAAV;AAC7C,MAAA,KAAsC,GAAG,OAAO,CAAC,SAAR,CAAkB,EAAlB,CAAzC;AAAY,MAAA,OAAA,GAAA,KAAA,CAAA,KAAA;AAAiB,MAAA,QAAA,GAAA,KAAA,CAAA,MAAA;;AAC7B,MAAI,MAAM,IAAI,IAAV,IAAkB,KAAK,CAAC,MAA5B,EAAoC;AAClC,QAAI,QAAQ,IAAI,EAAZ,IAAkB,CAAC,OAAO,CAAC,KAAR,CAAc,OAAd,EAAuB,MAA9C,EAAoD;AAAE,YAAM,IAAI,UAAJ,CAAe,yBAAf,CAAN;AAA+C;;AACrG,WAAO,OAAO,CAAC,GAAR,CAAY,CAAZ,EAAe,IAAf,EAAqB,MAArB,CAA4B,OAAO,CAAC,GAAR,CAAY,EAAZ,CAA5B,CAAP;AACD;;AACD,MAAI,KAAK,IAAI,OAAb,EAAoB;AAAE,UAAM,IAAI,UAAJ,CAAe,yBAAf,CAAN;AAA+C;;AACrE,SAAO,OAAO,CAAC,YAAR,CAAqB,KAArB,EAA4B,KAAK,CAAC,IAAN,CAAW,WAAW,CAAC,KAAK,CAAC,OAAP,EAAgB,IAAI,GAAG,MAAP,GAAgB,CAAhC,EAAmC,EAAE,GAAG,MAAL,GAAc,CAAjD,CAAtB,CAA5B,CAAP;AACD;;AAED,SAAS,UAAT,CAAoB,OAApB,EAA6B,IAA7B,EAAmC,MAAnC,EAA2C,MAA3C,EAAmD;AACjD,MAAA,GAAmB,GAAG,OAAO,CAAC,SAAR,CAAkB,IAAlB,CAAtB;AAAK,MAAA,KAAA,GAAA,GAAA,CAAA,KAAA;AAAO,MAAA,MAAA,GAAA,GAAA,CAAA,MAAA;AAAiC,MAAE,KAAK,GAAG,OAAO,CAAC,UAAR,CAAmB,KAAnB,CAAV;;AAC7C,MAAI,MAAM,IAAI,IAAV,IAAkB,KAAK,CAAC,MAA5B,EAAoC;AAClC,QAAI,MAAM,IAAI,CAAC,MAAM,CAAC,UAAP,CAAkB,KAAlB,EAAyB,KAAzB,EAAgC,MAAhC,CAAf,EAAsD;AAAE,aAAO,IAAP;AAAW;;AACnE,WAAO,OAAO,CAAC,GAAR,CAAY,CAAZ,EAAe,IAAf,EAAqB,MAArB,CAA4B,MAA5B,EAAoC,MAApC,CAA2C,OAAO,CAAC,GAAR,CAAY,IAAZ,CAA3C,CAAP;AACD;;AACDJ,MAAI,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC,OAAP,EAAgB,IAAI,GAAG,MAAP,GAAgB,CAAhC,EAAmC,MAAnC,CAAtBA;AACA,SAAO,KAAK,IAAI,OAAO,CAAC,YAAR,CAAqB,KAArB,EAA4B,KAAK,CAAC,IAAN,CAAW,KAAX,CAA5B,CAAhB;AACD,C;;;;AAID,KAAK,CAAC,KAAN,GAAc,IAAI,KAAJ,CAAU,QAAQ,CAAC,KAAnB,EAA0B,CAA1B,EAA6B,CAA7B,CAAd;;AAEO,SAAS,OAAT,CAAiB,KAAjB,EAAwB,GAAxB,EAA6B,KAA7B,EAAoC;AACzC,MAAI,KAAK,CAAC,SAAN,GAAkB,KAAK,CAAC,KAA5B,E;AACE,UAAM,IAAI,YAAJ,CAAiB,iDAAjB,CAAN;AAAyE;;AAC3E,MAAI,KAAK,CAAC,KAAN,GAAc,KAAK,CAAC,SAApB,IAAiC,GAAG,CAAC,KAAJ,GAAY,KAAK,CAAC,OAAvD,E;AACE,UAAM,IAAI,YAAJ,CAAiB,0BAAjB,CAAN;AAAkD;;AACpD,SAAO,YAAY,CAAC,KAAD,EAAQ,GAAR,EAAa,KAAb,EAAoB,CAApB,CAAnB;AACD;;AAED,SAAS,YAAT,CAAsB,KAAtB,EAA6B,GAA7B,EAAkC,KAAlC,EAAyC,KAAzC,EAAgD;AAC9CA,MAAI,KAAK,GAAG,KAAK,CAAC,KAAN,CAAY,KAAZ,CAAZA;AAAAA,MAAgC,IAAI,GAAG,KAAK,CAAC,IAAN,CAAW,KAAX,CAAvCA;;AACA,MAAI,KAAK,IAAI,GAAG,CAAC,KAAJ,CAAU,KAAV,CAAT,IAA6B,KAAK,GAAG,KAAK,CAAC,KAAN,GAAc,KAAK,CAAC,SAA7D,EAAwE;AACtEA,QAAI,KAAK,GAAG,YAAY,CAAC,KAAD,EAAQ,GAAR,EAAa,KAAb,EAAoB,KAAK,GAAG,CAA5B,CAAxBA;AACA,WAAO,IAAI,CAAC,IAAL,CAAU,IAAI,CAAC,OAAL,CAAa,YAAb,CAA0B,KAA1B,EAAiC,KAAjC,CAAV,CAAP;AACD,GAHD,MAGO,IAAI,CAAC,KAAK,CAAC,OAAN,CAAc,IAAnB,EAAyB;AAC9B,WAAO,KAAK,CAAC,IAAD,EAAO,aAAa,CAAC,KAAD,EAAQ,GAAR,EAAa,KAAb,CAApB,CAAZ;AACD,GAFM,MAEA,IAAI,CAAC,KAAK,CAAC,SAAP,IAAoB,CAAC,KAAK,CAAC,OAA3B,IAAsC,KAAK,CAAC,KAAN,IAAe,KAArD,IAA8D,GAAG,CAAC,KAAJ,IAAa,KAA/E,EAAsF;AAAA;AAC3FA,QAAI,MAAM,GAAG,KAAK,CAAC,MAAnBA;AAAAA,QAA2B,OAAO,GAAG,MAAM,CAAC,OAA5CA;AACA,WAAO,KAAK,CAAC,MAAD,EAAS,OAAO,CAAC,GAAR,CAAY,CAAZ,EAAe,KAAK,CAAC,YAArB,EAAmC,MAAnC,CAA0C,KAAK,CAAC,OAAhD,EAAyD,MAAzD,CAAgE,OAAO,CAAC,GAAR,CAAY,GAAG,CAAC,YAAhB,CAAhE,CAAT,CAAZ;AACD,GAHM,MAGA;AACL,QAAA,GAAgB,GAAG,sBAAsB,CAAC,KAAD,EAAQ,KAAR,CAAzC;AAAK,QAAA,KAAA,GAAA,GAAA,CAAA,KAAA;AAAO,QAAA,GAAA,GAAA,GAAA,CAAA,GAAA;AACZ,WAAO,KAAK,CAAC,IAAD,EAAO,eAAe,CAAC,KAAD,EAAQ,KAAR,EAAe,GAAf,EAAoB,GAApB,EAAyB,KAAzB,CAAtB,CAAZ;AACD;AACF;;AAED,SAAS,SAAT,CAAmB,IAAnB,EAAyB,GAAzB,EAA8B;AAC5B,MAAI,CAAC,GAAG,CAAC,IAAJ,CAAS,iBAAT,CAA2B,IAAI,CAAC,IAAhC,CAAL,E;AACE,UAAM,IAAI,YAAJ,CAAiB,iBAAiB,GAAG,CAAC,IAAJ,CAAS,IAA1B,GAAiC,QAAjC,GAA4C,IAAI,CAAC,IAAL,CAAU,IAAvE,CAAN;AAAkF;AACrF;;AAED,SAAS,QAAT,CAAkB,OAAlB,EAA2B,MAA3B,EAAmC,KAAnC,EAA0C;AACxCA,MAAI,IAAI,GAAG,OAAO,CAAC,IAAR,CAAa,KAAb,CAAXA;AACA,EAAA,SAAS,CAAC,IAAD,EAAO,MAAM,CAAC,IAAP,CAAY,KAAZ,CAAP,CAAT;AACA,SAAO,IAAP;AACD;;AAED,SAAS,OAAT,CAAiB,KAAjB,EAAwB,MAAxB,EAAgC;AAC9BA,MAAI,IAAI,GAAG,MAAM,CAAC,MAAP,GAAgB,CAA3BA;;AACA,MAAI,IAAI,IAAI,CAAR,IAAa,KAAK,CAAC,MAAnB,IAA6B,KAAK,CAAC,UAAN,CAAiB,MAAM,CAAC,IAAD,CAAvB,CAAjC,E;AACE,IAAA,MAAM,CAAC,IAAD,CAAN,GAAe,KAAK,CAAC,QAAN,CAAe,MAAM,CAAC,IAAD,CAAN,CAAa,IAAb,GAAoB,KAAK,CAAC,IAAzC,CAAf;AAA6D,GAD/D,M;AAGE,IAAA,MAAM,CAAC,IAAP,CAAY,KAAZ;AAAkB;AACrB;;AAED,SAAS,QAAT,CAAkB,MAAlB,EAA0B,IAA1B,EAAgC,KAAhC,EAAuC,MAAvC,EAA+C;AAC7CA,MAAI,IAAI,GAAG,CAAC,IAAI,IAAI,MAAT,EAAiB,IAAjB,CAAsB,KAAtB,CAAXA;AACAA,MAAI,UAAU,GAAG,CAAjBA;AAAAA,MAAoB,QAAQ,GAAG,IAAI,GAAG,IAAI,CAAC,KAAL,CAAW,KAAX,CAAH,GAAuB,IAAI,CAAC,UAA/DA;;AACA,MAAI,MAAJ,EAAY;AACV,IAAA,UAAU,GAAG,MAAM,CAAC,KAAP,CAAa,KAAb,CAAb;;AACA,QAAI,MAAM,CAAC,KAAP,GAAe,KAAnB,EAA0B;AACxB,MAAA,UAAU;AACX,KAFD,MAEO,IAAI,MAAM,CAAC,UAAX,EAAuB;AAC5B,MAAA,OAAO,CAAC,MAAM,CAAC,SAAR,EAAmB,MAAnB,CAAP;AACA,MAAA,UAAU;AACX;AACF;;AACD,OAAKA,IAAI,CAAC,GAAG,UAAb,EAAyB,CAAC,GAAG,QAA7B,EAAuC,CAAC,EAAxC,EAA0C;AAAE,IAAA,OAAO,CAAC,IAAI,CAAC,KAAL,CAAW,CAAX,CAAD,EAAgB,MAAhB,CAAP;AAA8B;;AAC1E,MAAI,IAAI,IAAI,IAAI,CAAC,KAAL,IAAc,KAAtB,IAA+B,IAAI,CAAC,UAAxC,E;AACE,IAAA,OAAO,CAAC,IAAI,CAAC,UAAN,EAAkB,MAAlB,CAAP;AAAgC;AACnC;;AAED,SAAS,KAAT,CAAe,IAAf,EAAqB,OAArB,EAA8B;AAC5B,MAAI,CAAC,IAAI,CAAC,IAAL,CAAU,YAAV,CAAuB,OAAvB,CAAL,E;AACE,UAAM,IAAI,YAAJ,CAAiB,8BAA8B,IAAI,CAAC,IAAL,CAAU,IAAzD,CAAN;AAAoE;;AACtE,SAAO,IAAI,CAAC,IAAL,CAAU,OAAV,CAAP;AACD;;AAED,SAAS,eAAT,CAAyB,KAAzB,EAAgC,MAAhC,EAAwC,IAAxC,EAA8C,GAA9C,EAAmD,KAAnD,EAA0D;AACxDA,MAAI,SAAS,GAAG,KAAK,CAAC,KAAN,GAAc,KAAd,IAAuB,QAAQ,CAAC,KAAD,EAAQ,MAAR,EAAgB,KAAK,GAAG,CAAxB,CAA/CA;AACAA,MAAI,OAAO,GAAG,GAAG,CAAC,KAAJ,GAAY,KAAZ,IAAqB,QAAQ,CAAC,IAAD,EAAO,GAAP,EAAY,KAAK,GAAG,CAApB,CAA3CA;AAEAA,MAAI,OAAO,GAAG,EAAdA;AACA,EAAA,QAAQ,CAAC,IAAD,EAAO,KAAP,EAAc,KAAd,EAAqB,OAArB,CAAR;;AACA,MAAI,SAAS,IAAI,OAAb,IAAwB,MAAM,CAAC,KAAP,CAAa,KAAb,KAAuB,IAAI,CAAC,KAAL,CAAW,KAAX,CAAnD,EAAsE;AACpE,IAAA,SAAS,CAAC,SAAD,EAAY,OAAZ,CAAT;AACA,IAAA,OAAO,CAAC,KAAK,CAAC,SAAD,EAAY,eAAe,CAAC,KAAD,EAAQ,MAAR,EAAgB,IAAhB,EAAsB,GAAtB,EAA2B,KAAK,GAAG,CAAnC,CAA3B,CAAN,EAAyE,OAAzE,CAAP;AACD,GAHD,MAGO;AACL,QAAI,SAAJ,E;AACE,MAAA,OAAO,CAAC,KAAK,CAAC,SAAD,EAAY,aAAa,CAAC,KAAD,EAAQ,MAAR,EAAgB,KAAK,GAAG,CAAxB,CAAzB,CAAN,EAA4D,OAA5D,CAAP;AAA2E;;AAC7E,IAAA,QAAQ,CAAC,MAAD,EAAS,IAAT,EAAe,KAAf,EAAsB,OAAtB,CAAR;;AACA,QAAI,OAAJ,E;AACE,MAAA,OAAO,CAAC,KAAK,CAAC,OAAD,EAAU,aAAa,CAAC,IAAD,EAAO,GAAP,EAAY,KAAK,GAAG,CAApB,CAAvB,CAAN,EAAsD,OAAtD,CAAP;AAAqE;AACxE;;AACD,EAAA,QAAQ,CAAC,GAAD,EAAM,IAAN,EAAY,KAAZ,EAAmB,OAAnB,CAAR;AACA,SAAO,IAAI,QAAJ,CAAa,OAAb,CAAP;AACD;;AAED,SAAS,aAAT,CAAuB,KAAvB,EAA8B,GAA9B,EAAmC,KAAnC,EAA0C;AACxCA,MAAI,OAAO,GAAG,EAAdA;AACA,EAAA,QAAQ,CAAC,IAAD,EAAO,KAAP,EAAc,KAAd,EAAqB,OAArB,CAAR;;AACA,MAAI,KAAK,CAAC,KAAN,GAAc,KAAlB,EAAyB;AACvBA,QAAI,IAAI,GAAG,QAAQ,CAAC,KAAD,EAAQ,GAAR,EAAa,KAAK,GAAG,CAArB,CAAnBA;AACA,IAAA,OAAO,CAAC,KAAK,CAAC,IAAD,EAAO,aAAa,CAAC,KAAD,EAAQ,GAAR,EAAa,KAAK,GAAG,CAArB,CAApB,CAAN,EAAoD,OAApD,CAAP;AACD;;AACD,EAAA,QAAQ,CAAC,GAAD,EAAM,IAAN,EAAY,KAAZ,EAAmB,OAAnB,CAAR;AACA,SAAO,IAAI,QAAJ,CAAa,OAAb,CAAP;AACD;;AAED,SAAS,sBAAT,CAAgC,KAAhC,EAAuC,MAAvC,EAA+C;AAC7CA,MAAI,KAAK,GAAG,MAAM,CAAC,KAAP,GAAe,KAAK,CAAC,SAAjCA;AAAAA,MAA4C,MAAM,GAAG,MAAM,CAAC,IAAP,CAAY,KAAZ,CAArDA;AACAA,MAAI,IAAI,GAAG,MAAM,CAAC,IAAP,CAAY,KAAK,CAAC,OAAlB,CAAXA;;AACA,OAAKA,IAAI,CAAC,GAAG,KAAK,GAAG,CAArB,EAAwB,CAAC,IAAI,CAA7B,EAAgC,CAAC,EAAjC,E;AACE,IAAA,IAAI,GAAG,MAAM,CAAC,IAAP,CAAY,CAAZ,EAAe,IAAf,CAAoB,QAAQ,CAAC,IAAT,CAAc,IAAd,CAApB,CAAP;AAA+C;;AACjD,SAAO;AAAC,IAAA,KAAK,EAAE,IAAI,CAAC,cAAL,CAAoB,KAAK,CAAC,SAAN,GAAkB,KAAtC,CAAR;AACC,IAAA,GAAG,EAAE,IAAI,CAAC,cAAL,CAAoB,IAAI,CAAC,OAAL,CAAa,IAAb,GAAoB,KAAK,CAAC,OAA1B,GAAoC,KAAxD;AADN,GAAP;AAED,C;;;;;;;;;;ACtND,IAAa,WAAW,GACtB,SAAA,WAAA,CAAY,GAAZ,EAAiB,IAAjB,EAAuB,YAAvB,EAAqC;;AAEnC,OAAK,GAAL,GAAW,GAAX;AACA,OAAK,IAAL,GAAY,IAAZ,CAHmC,C;;;;;AAQrC,OAAO,KAAP,GAAe,IAAI,CAAC,MAAL,GAAc,CAAd,GAAkB,CAAjC,CARqC,C;;AAUnC,OAAK,YAAL,GAAoB,YAApB;CAXJ;;;;;;;;;;;;;;;;kBAYG;;;;AAEH,WAAA,CAAA,SAAA,CAAE,YAAF,GAAE,SAAA,YAAA,CAAa,GAAb,EAAkB;AAClB,MAAM,GAAG,IAAI,IAAb,EAAiB;AAAE,WAAO,KAAK,KAAZ;AAAiB;;AACpC,MAAM,GAAG,GAAG,CAAZ,EAAa;AAAE,WAAO,KAAK,KAAL,GAAa,GAApB;AAAuB;;AACpC,SAAO,GAAP;AACD,CAJH,C;;;;;;AAUEG,oBAAAA,CAAI,MAAJA,CAAI,GAAJA,GAAI,YAAS;AAAE,SAAO,KAAK,IAAL,CAAU,KAAK,KAAf,CAAP;AAA4B,CAA3CA,C;;;;AAIFA,oBAAAA,CAAM,GAANA,CAAM,GAANA,GAAM,YAAM;AAAE,SAAO,KAAK,IAAL,CAAU,CAAV,CAAP;AAAmB,CAAjCA,C;;;;;AAKA,WAAA,CAAA,SAAA,CAAE,IAAF,GAAE,SAAA,IAAA,CAAK,KAAL,EAAY;AAAE,SAAO,KAAK,IAAL,CAAU,KAAK,YAAL,CAAkB,KAAlB,IAA2B,CAArC,CAAP;AAA8C,CAA9D,C;;;;;;AAMA,WAAA,CAAA,SAAA,CAAE,KAAF,GAAE,SAAA,KAAA,CAAM,KAAN,EAAa;AAAE,SAAO,KAAK,IAAL,CAAU,KAAK,YAAL,CAAkB,KAAlB,IAA2B,CAA3B,GAA+B,CAAzC,CAAP;AAAkD,CAAnE,C;;;;;AAKA,WAAA,CAAA,SAAA,CAAE,UAAF,GAAE,SAAA,UAAA,CAAW,KAAX,EAAkB;AAChB,EAAA,KAAK,GAAG,KAAK,YAAL,CAAkB,KAAlB,CAAR;AACF,SAAS,KAAK,KAAL,CAAW,KAAX,KAAqB,KAAK,IAAI,KAAK,KAAd,IAAuB,CAAC,KAAK,UAA7B,GAA0C,CAA1C,GAA8C,CAAnE,CAAT;AACC,CAHH,C;;;;;AAQA,WAAA,CAAA,SAAA,CAAE,KAAF,GAAE,SAAA,KAAA,CAAM,KAAN,EAAa;AACX,EAAA,KAAK,GAAG,KAAK,YAAL,CAAkB,KAAlB,CAAR;AACA,SAAO,KAAK,IAAI,CAAT,GAAa,CAAb,GAAiB,KAAK,IAAL,CAAU,KAAK,GAAG,CAAR,GAAY,CAAtB,IAA2B,CAAnD;AACD,CAHH,C;;;;;AAQA,WAAA,CAAA,SAAA,CAAE,GAAF,GAAE,SAAA,GAAA,CAAI,KAAJ,EAAW;AACT,EAAA,KAAK,GAAG,KAAK,YAAL,CAAkB,KAAlB,CAAR;AACA,SAAO,KAAK,KAAL,CAAW,KAAX,IAAoB,KAAK,IAAL,CAAU,KAAV,EAAiB,OAAjB,CAAyB,IAApD;AACD,CAHH,C;;;;;;AASA,WAAA,CAAA,SAAA,CAAE,MAAF,GAAE,SAAA,MAAA,CAAO,KAAP,EAAc;AACZ,EAAA,KAAK,GAAG,KAAK,YAAL,CAAkB,KAAlB,CAAR;;AACF,MAAM,CAAC,KAAP,EAAY;AAAE,UAAM,IAAI,UAAJ,CAAe,gDAAf,CAAN;AAAsE;;AACpF,SAAS,KAAK,IAAI,KAAK,KAAL,GAAa,CAAtB,GAA0B,KAAK,GAA/B,GAAqC,KAAK,IAAL,CAAU,KAAK,GAAG,CAAR,GAAY,CAAtB,CAA9C;AACC,CAJH,C;;;;;AASA,WAAA,CAAA,SAAA,CAAE,KAAF,GAAE,SAAA,KAAA,CAAM,KAAN,EAAa;AACX,EAAA,KAAK,GAAG,KAAK,YAAL,CAAkB,KAAlB,CAAR;;AACF,MAAM,CAAC,KAAP,EAAY;AAAE,UAAM,IAAI,UAAJ,CAAe,+CAAf,CAAN;AAAqE;;AACjF,SAAO,KAAK,IAAI,KAAK,KAAL,GAAa,CAAtB,GAA0B,KAAK,GAA/B,GAAqC,KAAK,IAAL,CAAU,KAAK,GAAG,CAAR,GAAY,CAAtB,IAA2B,KAAK,IAAL,CAAU,KAAK,GAAG,CAAlB,EAAqB,QAA5F;AACD,CAJH,C;;;;;;AAUAA,oBAAAA,CAAM,UAANA,CAAM,GAANA,GAAM,YAAa;AAAE,SAAO,KAAK,GAAL,GAAW,KAAK,IAAL,CAAU,KAAK,IAAL,CAAU,MAAV,GAAmB,CAA7B,CAAlB;AAAiD,CAAtEA,C;;;;;;AAMAA,oBAAAA,CAAM,SAANA,CAAM,GAANA,GAAM,YAAY;AACdH,MAAI,MAAM,GAAG,KAAK,MAAlBA;AAAAA,MAA0B,KAAK,GAAG,KAAK,KAAL,CAAW,KAAK,KAAhB,CAAlCA;;AACF,MAAM,KAAK,IAAI,MAAM,CAAC,UAAtB,EAAgC;AAAE,WAAO,IAAP;AAAW;;AAC3CA,MAAI,IAAI,GAAG,KAAK,GAAL,GAAW,KAAK,IAAL,CAAU,KAAK,IAAL,CAAU,MAAV,GAAmB,CAA7B,CAAtBA;AAAAA,MAAuD,KAAK,GAAG,MAAM,CAAC,KAAP,CAAa,KAAb,CAA/DA;AACA,SAAO,IAAI,GAAG,MAAM,CAAC,KAAP,CAAa,KAAb,EAAoB,GAApB,CAAwB,IAAxB,CAAH,GAAmC,KAA9C;AACD,CALHG,C;;;;;;AAWAA,oBAAAA,CAAM,UAANA,CAAM,GAANA,GAAM,YAAa;AACjB,MAAM,KAAK,GAAG,KAAK,KAAL,CAAW,KAAK,KAAhB,CAAd;AACEH,MAAI,IAAI,GAAG,KAAK,GAAL,GAAW,KAAK,IAAL,CAAU,KAAK,IAAL,CAAU,MAAV,GAAmB,CAA7B,CAAtBA;;AACA,MAAI,IAAJ,EAAQ;AAAE,WAAO,KAAK,MAAL,CAAY,KAAZ,CAAkB,KAAlB,EAAyB,GAAzB,CAA6B,CAA7B,EAAgC,IAAhC,CAAP;AAA4C;;AACtD,SAAO,KAAK,IAAI,CAAT,GAAa,IAAb,GAAoB,KAAK,MAAL,CAAY,KAAZ,CAAkB,KAAK,GAAG,CAA1B,CAA3B;AACD,CALHG,C;;;;;AAUA,WAAA,CAAA,SAAA,CAAE,UAAF,GAAE,SAAA,UAAA,CAAW,KAAX,EAAkB,KAAlB,EAAyB;AACvB,EAAA,KAAK,GAAG,KAAK,YAAL,CAAkB,KAAlB,CAAR;AACAH,MAAI,IAAI,GAAG,KAAK,IAAL,CAAU,KAAK,GAAG,CAAlB,CAAXA;AAAAA,MAAiC,GAAG,GAAG,KAAK,IAAI,CAAT,GAAa,CAAb,GAAiB,KAAK,IAAL,CAAU,KAAK,GAAG,CAAR,GAAY,CAAtB,IAA2B,CAAnFA;;AACF,OAAOA,IAAI,CAAC,GAAG,CAAf,EAAkB,CAAC,GAAG,KAAtB,EAA6B,CAAC,EAA9B,EAAgC;AAAE,IAAA,GAAG,IAAI,IAAI,CAAC,KAAL,CAAW,CAAX,EAAc,QAArB;AAA6B;;AAC7D,SAAO,GAAP;AACD,CALH,C;;;;;;;AAYA,WAAA,CAAA,SAAA,CAAE,KAAF,GAAE,SAAA,KAAA,GAAQ;AACNA,MAAI,MAAM,GAAG,KAAK,MAAlBA;AAAAA,MAA0B,KAAK,GAAG,KAAK,KAAL,EAAlCA,CADM,C;;AAIN,MAAI,MAAM,CAAC,OAAP,CAAe,IAAf,IAAuB,CAA3B,EAA4B;AAAE,WAAO,IAAI,CAAC,IAAZ;AAAgB,GAJxC,C;;;AAON,MAAI,KAAK,UAAT,EAAmB;AAAE,WAAO,MAAM,CAAC,KAAP,CAAa,KAAb,EAAoB,KAA3B;AAAgC;;AAEvD,MAAM,IAAI,GAAG,MAAM,CAAC,UAAP,CAAkB,KAAK,GAAG,CAA1B,CAAb;AAAA,MAA2C,KAAK,GAAG,MAAM,CAAC,UAAP,CAAkB,KAAlB,CAAnD,CATQ,C;;;AAYR,MAAM,CAAC,IAAP,EAAa;AAAEA,QAAI,GAAG,GAAG,IAAVA;AAAgB,IAAA,IAAI,GAAG,KAAP;AAAc,IAAA,KAAK,GAAG,GAAR;AAAa,GAZlD,C;;;;AAgBNA,MAAI,KAAK,GAAG,IAAI,CAAC,KAAjBA;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,EAAnC,EACA;AAAE,QAAI,KAAK,CAAC,CAAD,CAAL,CAAS,IAAT,CAAc,IAAd,CAAmB,SAAnB,KAAiC,KAAjC,KAA2C,CAAC,KAAD,IAAU,CAAC,KAAK,CAAC,CAAD,CAAL,CAAS,OAAT,CAAiB,KAAK,CAAC,KAAvB,CAAtD,CAAJ,EACA;AAAE,MAAA,KAAK,GAAG,KAAK,CAAC,CAAC,EAAF,CAAL,CAAW,aAAX,CAAyB,KAAzB,CAAR;AAAsC;AAAC;;AAE3C,SAAO,KAAP;AACD,CAtBH,C;;;;;;;;;AA+BA,WAAA,CAAA,SAAA,CAAE,WAAF,GAAE,SAAA,WAAA,CAAY,IAAZ,EAAkB;AAChBA,MAAI,KAAK,GAAG,KAAK,MAAL,CAAY,UAAZ,CAAuB,KAAK,KAAL,EAAvB,CAAZA;;AACF,MAAM,CAAC,KAAD,IAAU,CAAC,KAAK,CAAC,QAAvB,EAA+B;AAAE,WAAO,IAAP;AAAW;;AAE5C,MAAM,KAAK,GAAG,KAAK,CAAC,KAApB;AAAA,MAA2B,IAAI,GAAG,IAAI,CAAC,MAAL,CAAY,UAAZ,CAAuB,IAAI,CAAC,KAAL,EAAvB,CAAlC;;AACE,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,EAAnC,EACA;AAAE,QAAI,KAAK,CAAC,CAAD,CAAL,CAAS,IAAT,CAAc,IAAd,CAAmB,SAAnB,KAAiC,KAAjC,KAA2C,CAAC,IAAD,IAAS,CAAC,KAAK,CAAC,CAAD,CAAL,CAAS,OAAT,CAAiB,IAAI,CAAC,KAAtB,CAArD,CAAJ,EACA;AAAE,MAAA,KAAK,GAAG,KAAK,CAAC,CAAC,EAAF,CAAL,CAAW,aAAX,CAAyB,KAAzB,CAAR;AAAsC;AAAC;;AAC3C,SAAO,KAAP;AACD,CATH,C;;;;;AAcA,WAAA,CAAA,SAAA,CAAE,WAAF,GAAE,SAAA,WAAA,CAAY,GAAZ,EAAiB;AACf,OAAKA,IAAI,KAAK,GAAG,KAAK,KAAtB,EAA6B,KAAK,GAAG,CAArC,EAAwC,KAAK,EAA7C,EACA;AAAE,QAAI,KAAK,KAAL,CAAW,KAAX,KAAqB,GAArB,IAA4B,KAAK,GAAL,CAAS,KAAT,KAAmB,GAAnD,EAAsD;AAAE,aAAO,KAAP;AAAO;AAAK;;AACtE,SAAO,CAAP;AACD,CAJH,C;;;;;;;;;;AAcA,WAAA,CAAA,SAAA,CAAE,UAAF,GAAE,SAAA,UAAA,CAAW,KAAX,EAAyB,IAAzB,EAA+B;6BAAf,GAAG,I;;AACjB,MAAI,KAAK,CAAC,GAAN,GAAY,KAAK,GAArB,EAAwB;AAAE,WAAO,KAAK,CAAC,UAAN,CAAiB,IAAjB,CAAP;AAA6B;;AACvD,OAAKA,IAAI,CAAC,GAAG,KAAK,KAAL,IAAc,KAAK,MAAL,CAAY,aAAZ,IAA6B,KAAK,GAAL,IAAY,KAAK,CAAC,GAA/C,GAAqD,CAArD,GAAyD,CAAvE,CAAb,EAAwF,CAAC,IAAI,CAA7F,EAAgG,CAAC,EAAjG,EACA;AAAE,QAAI,KAAK,CAAC,GAAN,IAAa,KAAK,GAAL,CAAS,CAAT,CAAb,KAA6B,CAAC,IAAD,IAAS,IAAI,CAAC,KAAK,IAAL,CAAU,CAAV,CAAD,CAA1C,CAAJ,EACA;AAAE,aAAO,IAAI,SAAJ,CAAc,IAAd,EAAoB,KAApB,EAA2B,CAA3B,CAAP;AAAmC;AAAC;AACzC,CALH,C;;;;AASA,WAAA,CAAA,SAAA,CAAE,UAAF,GAAE,SAAA,UAAA,CAAW,KAAX,EAAkB;AAChB,SAAO,KAAK,GAAL,GAAW,KAAK,YAAhB,IAAgC,KAAK,CAAC,GAAN,GAAY,KAAK,CAAC,YAAzD;AACD,CAFH,C;;;;AAMA,WAAA,CAAA,SAAA,CAAE,GAAF,GAAE,SAAA,GAAA,CAAI,KAAJ,EAAW;AACX,SAAS,KAAK,CAAC,GAAN,GAAY,KAAK,GAAjB,GAAuB,KAAvB,GAA+B,IAAxC;AACC,CAFH,C;;;;AAMA,WAAA,CAAA,SAAA,CAAE,GAAF,GAAE,SAAA,GAAA,CAAI,KAAJ,EAAW;AACX,SAAS,KAAK,CAAC,GAAN,GAAY,KAAK,GAAjB,GAAuB,KAAvB,GAA+B,IAAxC;AACC,CAFH;;AAIA,WAAA,CAAA,SAAA,CAAE,QAAF,GAAE,SAAA,QAAA,GAAW;AACTA,MAAI,GAAG,GAAG,EAAVA;;AACA,OAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,IAAI,KAAK,KAA1B,EAAiC,CAAC,EAAlC,EACA;AAAE,IAAA,GAAG,IAAI,CAAC,GAAG,GAAG,GAAH,GAAS,EAAb,IAAmB,KAAK,IAAL,CAAU,CAAV,EAAa,IAAb,CAAkB,IAArC,GAA4C,GAA5C,GAAkD,KAAK,KAAL,CAAW,CAAC,GAAG,CAAf,CAAzD;AAA0E;;AAC5E,SAAO,GAAG,GAAG,GAAN,GAAY,KAAK,YAAxB;AACD,CALH;;AAOE,WAAA,CAAO,OAAP,GAAO,SAAA,OAAA,CAAQ,GAAR,EAAa,GAAb,EAAkB;AACzB,MAAM,EAAE,GAAG,IAAI,CAAP,IAAY,GAAG,IAAI,GAAG,CAAC,OAAJ,CAAY,IAAjC,CAAN,EAA4C;AAAE,UAAM,IAAI,UAAJ,CAAe,cAAc,GAAd,GAAoB,eAAnC,CAAN;AAAyD;;AACrGA,MAAI,IAAI,GAAG,EAAXA;AACF,MAAM,KAAK,GAAG,CAAd;AAAA,MAAiB,YAAY,GAAG,GAAhC;;AACE,OAAKA,IAAI,IAAI,GAAG,GAAhB,IAAuB;AACvB,QAAA,GAAqB,GAAG,IAAI,CAAC,OAAL,CAAa,SAAb,CAAuB,YAAvB,CAAxB;AAAO,QAAA,KAAA,GAAA,GAAA,CAAA,KAAA;AAAO,QAAA,MAAA,GAAA,GAAA,CAAA,MAAA;AACZA,QAAI,GAAG,GAAG,YAAY,GAAG,MAAzBA;AACF,IAAA,IAAM,CAAC,IAAP,CAAY,IAAZ,EAAkB,KAAlB,EAAyB,KAAK,GAAG,MAAjC;;AACE,QAAI,CAAC,GAAL,EAAQ;AAAE;AAAK;;AACf,IAAA,IAAI,GAAG,IAAI,CAAC,KAAL,CAAW,KAAX,CAAP;;AACA,QAAI,IAAI,CAAC,MAAT,EAAe;AAAE;AAAK;;AACtB,IAAA,YAAY,GAAG,GAAG,GAAG,CAArB;AACA,IAAA,KAAK,IAAI,MAAM,GAAG,CAAlB;AACD;;AACH,SAAS,IAAI,WAAJ,CAAgB,GAAhB,EAAqB,IAArB,EAA2B,YAA3B,CAAT;AACC,CAfD;;AAiBA,WAAA,CAAO,aAAP,GAAO,SAAA,aAAA,CAAc,GAAd,EAAmB,GAAnB,EAAwB;AAC7B,OAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,YAAY,CAAC,MAAjC,EAAyC,CAAC,EAA1C,EAA8C;AAC5CA,QAAI,MAAM,GAAG,YAAY,CAAC,CAAD,CAAzBA;;AACA,QAAI,MAAM,CAAC,GAAP,IAAc,GAAd,IAAqB,MAAM,CAAC,GAAP,IAAc,GAAvC,EAA0C;AAAE,aAAO,MAAP;AAAa;AAC1D;;AACDA,MAAI,MAAM,GAAG,YAAY,CAAC,eAAD,CAAZ,GAAgC,WAAW,CAAC,OAAZ,CAAoB,GAApB,EAAyB,GAAzB,CAA7CA;AACF,EAAA,eAAiB,GAAG,CAAC,eAAe,GAAG,CAAnB,IAAwB,gBAA5C;AACE,SAAO,MAAP;AACD,CARD;;+CASD,oB;AAEDA,IAAI,YAAY,GAAG,EAAnBA;AAAAA,IAAuB,eAAe,GAAG,CAAzCA;AAAAA,IAA4C,gBAAgB,GAAG,EAA/DA,C;;;AAIA,IAAa,SAAS,GAKpB,SAAA,SAAA,CAAY,KAAZ,EAAmB,GAAnB,EAAwB,KAAxB,EAA+B;;;;;;AAM7B,OAAK,KAAL,GAAa,KAAb,CAN6B,C;;;AAS7B,OAAK,GAAL,GAAW,GAAX,CAT6B,C;;AAW7B,OAAK,KAAL,GAAa,KAAb;CAhBJ;;;;;;;;;;;;;;;;kBAiBG;;;;AAGDK,sBAAAA,CAAI,KAAJA,CAAI,GAAJA,GAAI,YAAQ;AAAE,SAAO,KAAK,KAAL,CAAW,MAAX,CAAkB,KAAK,KAAL,GAAa,CAA/B,CAAP;AAAwC,CAAtDA,C;;;AAEAA,sBAAAA,CAAI,GAAJA,CAAI,GAAJA,GAAI,YAAM;AAAE,SAAO,KAAK,GAAL,CAAS,KAAT,CAAe,KAAK,KAAL,GAAa,CAA5B,CAAP;AAAqC,CAAjDA,C;;;AAGAA,sBAAAA,CAAI,MAAJA,CAAI,GAAJA,GAAI,YAAS;AAAE,SAAO,KAAK,KAAL,CAAW,IAAX,CAAgB,KAAK,KAArB,CAAP;AAAkC,CAAjDA,C;;;AAEAA,sBAAAA,CAAI,UAAJA,CAAI,GAAJA,GAAI,YAAa;AAAE,SAAO,KAAK,KAAL,CAAW,KAAX,CAAiB,KAAK,KAAtB,CAAP;AAAmC,CAAtDA,C;;;AAEAA,sBAAAA,CAAI,QAAJA,CAAI,GAAJA,GAAI,YAAW;AAAE,SAAO,KAAK,GAAL,CAAS,UAAT,CAAoB,KAAK,KAAzB,CAAP;AAAwC,CAAzDA;;6CACD,sB;AC5RDJ,IAAM,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,IAAd,CAAnBA,C;;;;;;;;;;;;;AAcA,IAAa,IAAI,GACf,SAAA,IAAA,CAAY,IAAZ,EAAkB,KAAlB,EAAyB,OAAzB,EAAkC,KAAlC,EAAyC;;;AAGvC,OAAK,IAAL,GAAY,IAAZ,CAHuC,C;;;;;AASvC,OAAK,KAAL,GAAa,KAAb,CATuC,C;;;AAazC,OAAO,OAAP,GAAiB,OAAO,IAAI,QAAQ,CAAC,KAArC,CAbyC,C;;;;AAkBzC,OAAO,KAAP,GAAe,KAAK,IAAI,IAAI,CAAC,IAA7B;CAnBF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kBAoBG;;;;;;;;;;;AAWDE,oBAAAA,CAAI,QAAJA,CAAI,GAAJA,GAAI,YAAW;AAAE,SAAO,KAAK,MAAL,GAAc,CAAd,GAAkB,IAAI,KAAK,OAAL,CAAa,IAA1C;AAA8C,CAA/DA,C;;;;AAIFA,oBAAAA,CAAM,UAANA,CAAM,GAANA,GAAM,YAAa;AAAE,SAAO,KAAK,OAAL,CAAa,UAApB;AAA8B,CAAnDA,C;;;;;AAKA,IAAA,CAAA,SAAA,CAAE,KAAF,GAAE,SAAA,KAAA,CAAM,KAAN,EAAa;AAAE,SAAO,KAAK,OAAL,CAAa,KAAb,CAAmB,KAAnB,CAAP;AAAgC,CAAjD,C;;;;AAIA,IAAA,CAAA,SAAA,CAAE,UAAF,GAAE,SAAA,UAAA,CAAW,KAAX,EAAkB;AAAE,SAAO,KAAK,OAAL,CAAa,UAAb,CAAwB,KAAxB,CAAP;AAAqC,CAA3D,C;;;;;AAKA,IAAA,CAAA,SAAA,CAAE,OAAF,GAAE,SAAA,OAAA,CAAQ,CAAR,EAAW;AAAE,OAAK,OAAL,CAAa,OAAb,CAAqB,CAArB;AAAuB,CAAtC,C;;;;;;;;;;AAUA,IAAA,CAAA,SAAA,CAAE,YAAF,GAAE,SAAA,YAAA,CAAa,IAAb,EAAmB,EAAnB,EAAuB,CAAvB,EAA0B,QAA1B,EAAwC;mCAAN,GAAG,C;AACnC,OAAK,OAAL,CAAa,YAAb,CAA0B,IAA1B,EAAgC,EAAhC,EAAoC,CAApC,EAAuC,QAAvC,EAAiD,IAAjD;AACD,CAFH,C;;;;;AAOA,IAAA,CAAA,SAAA,CAAE,WAAF,GAAE,SAAA,WAAA,CAAY,CAAZ,EAAe;AACb,OAAK,YAAL,CAAkB,CAAlB,EAAqB,KAAK,OAAL,CAAa,IAAlC,EAAwC,CAAxC;AACD,CAFH,C;;;;;AAOEA,oBAAAA,CAAI,WAAJA,CAAI,GAAJA,GAAI,YAAc;AAAE,SAAO,KAAK,WAAL,CAAiB,CAAjB,EAAoB,KAAK,OAAL,CAAa,IAAjC,EAAuC,EAAvC,CAAP;AAAiD,CAArEA,C;;;;;;;AAOF,IAAA,CAAA,SAAA,CAAE,WAAF,GAAE,SAAA,WAAA,CAAY,IAAZ,EAAkB,EAAlB,EAAsB,cAAtB,EAAsC,QAAtC,EAAgD;AAC9C,SAAO,KAAK,OAAL,CAAa,WAAb,CAAyB,IAAzB,EAA+B,EAA/B,EAAmC,cAAnC,EAAmD,QAAnD,CAAP;AACD,CAFH,C;;;;;AAOAA,oBAAAA,CAAM,UAANA,CAAM,GAANA,GAAM,YAAa;AAAE,SAAO,KAAK,OAAL,CAAa,UAApB;AAA8B,CAAnDA,C;;;;;AAKAA,oBAAAA,CAAM,SAANA,CAAM,GAANA,GAAM,YAAY;AAAE,SAAO,KAAK,OAAL,CAAa,SAApB;AAA6B,CAAjDA,C;;;;AAIA,IAAA,CAAA,SAAA,CAAE,EAAF,GAAE,SAAA,EAAA,CAAG,KAAH,EAAU;AACV,SAAS,QAAQ,KAAR,IAAkB,KAAK,UAAL,CAAgB,KAAhB,KAA0B,KAAK,OAAL,CAAa,EAAb,CAAgB,KAAK,CAAC,OAAtB,CAArD;AACC,CAFH,C;;;;;AAOA,IAAA,CAAA,SAAA,CAAE,UAAF,GAAE,SAAA,UAAA,CAAW,KAAX,EAAkB;AAChB,SAAO,KAAK,SAAL,CAAe,KAAK,CAAC,IAArB,EAA2B,KAAK,CAAC,KAAjC,EAAwC,KAAK,CAAC,KAA9C,CAAP;AACD,CAFH,C;;;;;AAOA,IAAA,CAAA,SAAA,CAAE,SAAF,GAAE,SAAA,SAAA,CAAU,IAAV,EAAgB,KAAhB,EAAuB,KAAvB,EAA8B;AAC5B,SAAO,KAAK,IAAL,IAAa,IAAb,IACL,WAAW,CAAC,KAAK,KAAN,EAAa,KAAK,IAAI,IAAI,CAAC,YAAd,IAA8B,UAA3C,CADN,IAEL,IAAI,CAAC,OAAL,CAAa,KAAK,KAAlB,EAAyB,KAAK,IAAI,IAAI,CAAC,IAAvC,CAFF;AAGD,CAJH,C;;;;;AASA,IAAA,CAAA,SAAA,CAAE,IAAF,GAAE,SAAA,IAAA,CAAK,OAAL,EAAqB;iCAAT,GAAG,I;;AACf,MAAM,OAAO,IAAI,KAAK,OAAtB,EAA6B;AAAE,WAAO,IAAP;AAAW;;AACxC,SAAO,IAAI,KAAK,WAAT,CAAqB,KAAK,IAA1B,EAAgC,KAAK,KAArC,EAA4C,OAA5C,EAAqD,KAAK,KAA1D,CAAP;AACD,CAHH,C;;;;;AAQA,IAAA,CAAA,SAAA,CAAE,IAAF,GAAE,SAAA,IAAA,CAAK,KAAL,EAAY;AACZ,SAAS,KAAK,IAAI,KAAK,KAAd,GAAsB,IAAtB,GAA6B,IAAI,KAAK,WAAT,CAAqB,KAAK,IAA1B,EAAgC,KAAK,KAArC,EAA4C,KAAK,OAAjD,EAA0D,KAA1D,CAAtC;AACC,CAFH,C;;;;;;AAQA,IAAA,CAAA,SAAA,CAAE,GAAF,GAAE,SAAA,GAAA,CAAI,IAAJ,EAAU,EAAV,EAAc;AACZ,MAAI,IAAI,IAAI,CAAR,IAAa,EAAE,IAAI,KAAK,OAAL,CAAa,IAApC,EAAwC;AAAE,WAAO,IAAP;AAAW;;AACrD,SAAO,KAAK,IAAL,CAAU,KAAK,OAAL,CAAa,GAAb,CAAiB,IAAjB,EAAuB,EAAvB,CAAV,CAAP;AACD,CAHH,C;;;;;AAQA,IAAA,CAAA,SAAA,CAAE,KAAF,GAAE,SAAA,KAAA,CAAM,IAAN,EAAY,EAAZ,EAAoC,cAApC,EAA4D;uBAA9C,GAAG,KAAK,OAAL,CAAa,I;+CAAoB,GAAG,K;;AACrD,MAAM,IAAI,IAAI,EAAd,EAAgB;AAAE,WAAO,KAAK,CAAC,KAAb;AAAkB;;AAElCH,MAAI,KAAK,GAAG,KAAK,OAAL,CAAa,IAAb,CAAZA;AAAAA,MAAgC,GAAG,GAAG,KAAK,OAAL,CAAa,EAAb,CAAtCA;AACAA,MAAI,KAAK,GAAG,cAAc,GAAG,CAAH,GAAO,KAAK,CAAC,WAAN,CAAkB,EAAlB,CAAjCA;AACAA,MAAI,KAAK,GAAG,KAAK,CAAC,KAAN,CAAY,KAAZ,CAAZA;AAAAA,MAAgC,IAAI,GAAG,KAAK,CAAC,IAAN,CAAW,KAAX,CAAvCA;AACF,MAAM,OAAO,GAAG,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,KAAK,CAAC,GAAN,GAAY,KAA7B,EAAoC,GAAG,CAAC,GAAJ,GAAU,KAA9C,CAAhB;AACE,SAAO,IAAI,KAAJ,CAAU,OAAV,EAAmB,KAAK,CAAC,KAAN,GAAc,KAAjC,EAAwC,GAAG,CAAC,KAAJ,GAAY,KAApD,CAAP;AACD,CARH,C;;;;;;;;;AAiBA,IAAA,CAAA,SAAA,CAAE,OAAF,GAAE,SAAA,SAAA,CAAQ,IAAR,EAAc,EAAd,EAAkB,KAAlB,EAAyB;AACvB,SAAO,OAAO,CAAC,KAAK,OAAL,CAAa,IAAb,CAAD,EAAqB,KAAK,OAAL,CAAa,EAAb,CAArB,EAAuC,KAAvC,CAAd;AACD,CAFH,C;;;;AAMA,IAAA,CAAA,SAAA,CAAE,MAAF,GAAE,SAAA,MAAA,CAAO,GAAP,EAAY;AACV,OAAKA,IAAI,IAAI,GAAG,IAAhB,IAAwB;AACxB,QAAA,GAAqB,GAAG,IAAI,CAAC,OAAL,CAAa,SAAb,CAAuB,GAAvB,CAAxB;AAAO,QAAA,KAAA,GAAA,GAAA,CAAA,KAAA;AAAO,QAAA,MAAA,GAAA,GAAA,CAAA,MAAA;AACZ,IAAA,IAAI,GAAG,IAAI,CAAC,UAAL,CAAgB,KAAhB,CAAP;;AACA,QAAI,CAAC,IAAL,EAAS;AAAE,aAAO,IAAP;AAAW;;AACxB,QAAM,MAAM,IAAI,GAAV,IAAiB,IAAI,CAAC,MAA5B,EAAkC;AAAE,aAAO,IAAP;AAAW;;AAC7C,IAAA,GAAG,IAAI,MAAM,GAAG,CAAhB;AACD;AACF,CARH,C;;;;;;AAcA,IAAA,CAAA,SAAA,CAAE,UAAF,GAAE,SAAA,UAAA,CAAW,GAAX,EAAgB;AAChB,MAAA,GAAqB,GAAG,KAAK,OAAL,CAAa,SAAb,CAAuB,GAAvB,CAAxB;AAAO,MAAA,KAAA,GAAA,GAAA,CAAA,KAAA;AAAO,MAAA,MAAA,GAAA,GAAA,CAAA,MAAA;AACZ,SAAO;AAAC,IAAA,IAAI,EAAE,KAAK,OAAL,CAAa,UAAb,CAAwB,KAAxB,CAAP;AAAqC,IAAA,KAAA,EAAE,KAAvC;AAA4C,IAAA,MAAA,EAAE;AAA9C,GAAP;AACD,CAHH,C;;;;;;AASA,IAAA,CAAA,SAAA,CAAE,WAAF,GAAE,SAAA,WAAA,CAAY,GAAZ,EAAiB;AACf,MAAI,GAAG,IAAI,CAAX,EAAY;AAAE,WAAO;AAAC,MAAA,IAAI,EAAE,IAAP;AAAa,MAAA,KAAK,EAAE,CAApB;AAAuB,MAAA,MAAM,EAAE;AAA/B,KAAP;AAAwC;;AACxD,MAAA,GAAqB,GAAG,KAAK,OAAL,CAAa,SAAb,CAAuB,GAAvB,CAAxB;AAAO,MAAA,KAAA,GAAA,GAAA,CAAA,KAAA;AAAO,MAAA,MAAA,GAAA,GAAA,CAAA,MAAA;;AACd,MAAM,MAAM,GAAG,GAAf,EAAkB;AAAE,WAAO;AAAC,MAAA,IAAI,EAAE,KAAK,OAAL,CAAa,KAAb,CAAmB,KAAnB,CAAP;AAAgC,MAAA,KAAA,EAAE,KAAlC;AAAuC,MAAA,MAAA,EAAE;AAAzC,KAAP;AAAuD;;AACzEA,MAAI,IAAI,GAAG,KAAK,OAAL,CAAa,KAAb,CAAmB,KAAK,GAAG,CAA3B,CAAXA;AACA,SAAO;AAAA,IAAA,IAAA,EAAC,IAAD;AAAO,IAAA,KAAK,EAAE,KAAK,GAAG,CAAtB;AAAyB,IAAA,MAAM,EAAE,MAAM,GAAG,IAAI,CAAC;AAA/C,GAAP;AACD,CANH,C;;;;;AAWA,IAAA,CAAA,SAAA,CAAE,OAAF,GAAE,SAAA,OAAA,CAAQ,GAAR,EAAa;AAAE,SAAO,WAAW,CAAC,aAAZ,CAA0B,IAA1B,EAAgC,GAAhC,CAAP;AAA2C,CAA5D;;AAEA,IAAA,CAAA,SAAA,CAAE,cAAF,GAAE,SAAA,cAAA,CAAe,GAAf,EAAoB;AAAE,SAAO,WAAW,CAAC,OAAZ,CAAoB,IAApB,EAA0B,GAA1B,CAAP;AAAqC,CAA7D,C;;;;;AAKA,IAAA,CAAA,SAAA,CAAE,YAAF,GAAE,SAAA,YAAA,CAAa,IAAb,EAAmB,EAAnB,EAAuB,IAAvB,EAA6B;AAC3BA,MAAI,KAAK,GAAG,KAAZA;;AACA,MAAI,EAAE,GAAG,IAAT,EAAa;AAAE,SAAK,YAAL,CAAkB,IAAlB,EAAwB,EAAxB,EAA0B,UAAE,IAAF,EAAO;AAC9C,UAAI,IAAI,CAAC,OAAL,CAAa,IAAI,CAAC,KAAlB,CAAJ,EAA4B;AAAE,QAAA,KAAK,GAAG,IAAR;AAAY;;AAC5C,aAAS,CAAC,KAAV;AACC,KAHc;AAGb;;AACF,SAAO,KAAP;AACD,CAPH,C;;;;AAWAG,oBAAAA,CAAM,OAANA,CAAM,GAANA,GAAM,YAAU;AAAE,SAAO,KAAK,IAAL,CAAU,OAAjB;AAAwB,CAA1CA,C;;;;;AAKAA,oBAAAA,CAAM,WAANA,CAAM,GAANA,GAAM,YAAc;AAAE,SAAO,KAAK,IAAL,CAAU,WAAjB;AAA4B,CAAlDA,C;;;;AAIAA,oBAAAA,CAAM,aAANA,CAAM,GAANA,GAAM,YAAgB;AAAE,SAAO,KAAK,IAAL,CAAU,aAAjB;AAA8B,CAAtDA,C;;;;;AAKAA,oBAAAA,CAAM,QAANA,CAAM,GAANA,GAAM,YAAW;AAAE,SAAO,KAAK,IAAL,CAAU,QAAjB;AAAyB,CAA5CA,C;;;;AAIAA,oBAAAA,CAAM,MAANA,CAAM,GAANA,GAAM,YAAS;AAAE,SAAO,KAAK,IAAL,CAAU,MAAjB;AAAuB,CAAxCA,C;;;;AAIAA,oBAAAA,CAAM,MAANA,CAAM,GAANA,GAAM,YAAS;AAAE,SAAO,KAAK,IAAL,CAAU,MAAjB;AAAuB,CAAxCA,C;;;;;;;;AAQAA,oBAAAA,CAAM,MAANA,CAAM,GAANA,GAAM,YAAS;AAAE,SAAO,KAAK,IAAL,CAAU,MAAjB;AAAuB,CAAxCA,C;;;;;AAKA,IAAA,CAAA,SAAA,CAAE,QAAF,GAAE,SAAA,QAAA,GAAW;AACT,MAAI,KAAK,IAAL,CAAU,IAAV,CAAe,aAAnB,EAAgC;AAAE,WAAO,KAAK,IAAL,CAAU,IAAV,CAAe,aAAf,CAA6B,IAA7B,CAAP;AAAyC;;AAC7E,MAAM,IAAI,GAAG,KAAK,IAAL,CAAU,IAAvB;;AACE,MAAI,KAAK,OAAL,CAAa,IAAjB,EACA;AAAE,IAAA,IAAI,IAAI,MAAM,KAAK,OAAL,CAAa,aAAb,EAAN,GAAqC,GAA7C;AAAgD;;AACpD,SAAS,SAAS,CAAC,KAAK,KAAN,EAAa,IAAb,CAAlB;AACC,CANH,C;;;;AAUA,IAAA,CAAA,SAAA,CAAE,cAAF,GAAE,SAAA,cAAA,CAAe,KAAf,EAAsB;AACpBH,MAAI,KAAK,GAAG,KAAK,IAAL,CAAU,YAAV,CAAuB,aAAvB,CAAqC,KAAK,OAA1C,EAAmD,CAAnD,EAAsD,KAAtD,CAAZA;;AACF,MAAM,CAAC,KAAP,EAAY;AAAE,UAAM,IAAI,KAAJ,CAAU,sDAAV,CAAN;AAAuE;;AACnF,SAAO,KAAP;AACD,CAJH,C;;;;;;;;AAYA,IAAA,CAAA,SAAA,CAAE,UAAF,GAAE,SAAA,UAAA,CAAW,IAAX,EAAiB,EAAjB,EAAqB,WAArB,EAAmD,KAAnD,EAA8D,GAA9D,EAA4F;yCAA5D,GAAG,QAAQ,CAAC,K;6BAAY,GAAG,C;yBAAM,GAAG,WAAW,CAAC,U;AAC9EA,MAAI,GAAG,GAAG,KAAK,cAAL,CAAoB,IAApB,EAA0B,aAA1B,CAAwC,WAAxC,EAAqD,KAArD,EAA4D,GAA5D,CAAVA;AACAA,MAAI,GAAG,GAAG,GAAG,IAAI,GAAG,CAAC,aAAJ,CAAkB,KAAK,OAAvB,EAAgC,EAAhC,CAAjBA;;AACF,MAAM,CAAC,GAAD,IAAQ,CAAC,GAAG,CAAC,QAAnB,EAA2B;AAAE,WAAO,KAAP;AAAY;;AACvC,OAAKA,IAAI,CAAC,GAAG,KAAb,EAAoB,CAAC,GAAG,GAAxB,EAA6B,CAAC,EAA9B,EAAgC;AAAE,QAAI,CAAC,KAAK,IAAL,CAAU,WAAV,CAAsB,WAAW,CAAC,KAAZ,CAAkB,CAAlB,EAAqB,KAA3C,CAAL,EAAsD;AAAE,aAAO,KAAP;AAAO;AAAK;;AACtG,SAAO,IAAP;AACD,CANH,C;;;;;AAWA,IAAA,CAAA,SAAA,CAAE,cAAF,GAAE,SAAA,cAAA,CAAe,IAAf,EAAqB,EAArB,EAAyB,IAAzB,EAA+B,KAA/B,EAAsC;AACpC,MAAI,KAAK,IAAI,CAAC,KAAK,IAAL,CAAU,WAAV,CAAsB,KAAtB,CAAd,EAA0C;AAAE,WAAO,KAAP;AAAY;;AACxDA,MAAI,KAAK,GAAG,KAAK,cAAL,CAAoB,IAApB,EAA0B,SAA1B,CAAoC,IAApC,CAAZA;AACAA,MAAI,GAAG,GAAG,KAAK,IAAI,KAAK,CAAC,aAAN,CAAoB,KAAK,OAAzB,EAAkC,EAAlC,CAAnBA;AACA,SAAO,GAAG,GAAG,GAAG,CAAC,QAAP,GAAkB,KAA5B;AACD,CALH,C;;;;;;;AAYA,IAAA,CAAA,SAAA,CAAE,SAAF,GAAE,SAAA,SAAA,CAAU,KAAV,EAAiB;AACjB,MAAM,KAAK,CAAC,OAAN,CAAc,IAApB,EAAwB;AAAE,WAAO,KAAK,UAAL,CAAgB,KAAK,UAArB,EAAiC,KAAK,UAAtC,EAAkD,KAAK,CAAC,OAAxD,CAAP;AAAuE,GAAjG,M;AACO,WAAO,KAAK,IAAL,CAAU,iBAAV,CAA4B,KAAK,CAAC,IAAlC,CAAP;AAA8C;AACpD,CAHH,C;;;;;AAQA,IAAA,CAAA,SAAA,CAAE,KAAF,GAAE,SAAA,KAAA,GAAQ;AACR,MAAM,CAAC,KAAK,IAAL,CAAU,YAAV,CAAuB,KAAK,OAA5B,CAAP,EACE;AAAE,UAAM,IAAI,UAAJ,CAAc,8BAA6B,KAAK,IAAL,CAAU,IAAvC,GAA2C,IAA3C,GAAgD,KAAK,OAAL,CAAa,QAAb,GAAwB,KAAxB,CAA8B,CAA9B,EAAiC,EAAjC,CAA9D,CAAN;AAA2G;;AAC7G,OAAK,OAAL,CAAa,OAAb,CAAoB,UAAC,IAAD,EAAM;AAAA,WAAG,IAAI,CAAC,KAAL,EAAH;AAAe,GAAzC;AACD,CAJH,C;;;;AAQA,IAAA,CAAA,SAAA,CAAE,MAAF,GAAE,SAAA,MAAA,GAAS;AACPA,MAAI,GAAG,GAAG;AAAC,IAAA,IAAI,EAAE,KAAK,IAAL,CAAU;AAAjB,GAAVA;;AACF,OAAOA,IAAI,CAAX,IAAgB,KAAK,KAArB,EAA4B;AACxB,IAAA,GAAG,CAAC,KAAJ,GAAY,KAAK,KAAjB;AACA;AACD;;AACD,MAAI,KAAK,OAAL,CAAa,IAAjB,EACA;AAAE,IAAA,GAAG,CAAC,OAAJ,GAAc,KAAK,OAAL,CAAa,MAAb,EAAd;AAAmC;;AACrC,MAAI,KAAK,KAAL,CAAW,MAAf,EACA;AAAE,IAAA,GAAG,CAAC,KAAJ,GAAY,KAAK,KAAL,CAAW,GAAX,CAAc,UAAC,CAAD,EAAG;AAAA,aAAG,CAAC,CAAC,MAAF,EAAH;AAAa,KAA9B,CAAZ;AAA2C;;AAC7C,SAAO,GAAP;AACD,CAXH,C;;;;AAeE,IAAA,CAAO,QAAP,GAAO,SAAA,QAAA,CAAS,MAAT,EAAiB,IAAjB,EAAuB;AAC9B,MAAM,CAAC,IAAP,EAAW;AAAE,UAAM,IAAI,UAAJ,CAAe,iCAAf,CAAN;AAAuD;;AAClEA,MAAI,KAAK,GAAG,IAAZA;;AACA,MAAI,IAAI,CAAC,KAAT,EAAgB;AACd,QAAI,CAAC,KAAK,CAAC,OAAN,CAAc,IAAI,CAAC,KAAnB,CAAL,EAA8B;AAAE,YAAM,IAAI,UAAJ,CAAe,qCAAf,CAAN;AAA2D;;AAC7F,IAAA,KAAO,GAAG,IAAI,CAAC,KAAL,CAAW,GAAX,CAAe,MAAM,CAAC,YAAtB,CAAV;AACC;;AACD,MAAI,IAAI,CAAC,IAAL,IAAa,MAAjB,EAAyB;AACvB,QAAI,OAAO,IAAI,CAAC,IAAZ,IAAoB,QAAxB,EAAgC;AAAE,YAAM,IAAI,UAAJ,CAAe,2BAAf,CAAN;AAAiD;;AACrF,WAAS,MAAM,CAAC,IAAP,CAAY,IAAI,CAAC,IAAjB,EAAuB,KAAvB,CAAT;AACC;;AACDA,MAAI,OAAO,GAAG,QAAQ,CAAC,QAAT,CAAkB,MAAlB,EAA0B,IAAI,CAAC,OAA/B,CAAdA;AACA,SAAO,MAAM,CAAC,QAAP,CAAgB,IAAI,CAAC,IAArB,EAA2B,MAA3B,CAAkC,IAAI,CAAC,KAAvC,EAA8C,OAA9C,EAAuD,KAAvD,CAAP;AACD,CAbD;;wCAcD,oB;;AAEM,IAAM,QAAQ,GAAA,aAAA,UAAA,IAAA,EAAA;AACnB,WAAA,QAAA,CAAY,IAAZ,EAAkB,KAAlB,EAAyB,OAAzB,EAAkC,KAAlC,EAAyC;AACvCM,IAAAA,IAAAA,CAAAA,IAAAA,CAAK,IAALA,EAAM,IAANA,EAAY,KAAZA,EAAmB,IAAnBA,EAAyB,KAAzBA;;AAEA,QAAI,CAAC,OAAL,EAAY;AAAE,YAAM,IAAI,UAAJ,CAAe,kCAAf,CAAN;AAAwD;;AAEtE,SAAK,IAAL,GAAY,OAAZ;;;;;;;;;;;oBACD;;;;qBAED,Q,GAAA,SAAA,QAAA,GAAW;AACT,QAAI,KAAK,IAAL,CAAU,IAAV,CAAe,aAAnB,EAAgC;AAAE,aAAO,KAAK,IAAL,CAAU,IAAV,CAAe,aAAf,CAA6B,IAA7B,CAAP;AAAyC;;AAC3E,WAAO,SAAS,CAAC,KAAK,KAAN,EAAa,IAAI,CAAC,SAAL,CAAe,KAAK,IAApB,CAAb,CAAhB;AACD,G;;AAED,EAAA,oBAAA,CAAI,WAAJ,CAAI,GAAJ,GAAI,YAAc;AAAE,WAAO,KAAK,IAAZ;AAAgB,GAApC;;qBAEA,W,GAAA,SAAA,WAAA,CAAY,IAAZ,EAAkB,EAAlB,EAAsB;AAAE,WAAO,KAAK,IAAL,CAAU,KAAV,CAAgB,IAAhB,EAAsB,EAAtB,CAAP;AAAgC,G;;AAExD,EAAA,oBAAA,CAAI,QAAJ,CAAI,GAAJ,GAAI,YAAW;AAAE,WAAO,KAAK,IAAL,CAAU,MAAjB;AAAuB,GAAxC;;qBAEA,I,GAAA,SAAA,IAAA,CAAK,KAAL,EAAY;AACV,WAAO,KAAK,IAAI,KAAK,KAAd,GAAsB,IAAtB,GAA6B,IAAI,QAAJ,CAAa,KAAK,IAAlB,EAAwB,KAAK,KAA7B,EAAoC,KAAK,IAAzC,EAA+C,KAA/C,CAApC;AACD,G;;qBAED,Q,GAAA,SAAA,QAAA,CAAS,IAAT,EAAe;AACb,QAAI,IAAI,IAAI,KAAK,IAAjB,EAAqB;AAAE,aAAO,IAAP;AAAW;;AAClC,WAAO,IAAI,QAAJ,CAAa,KAAK,IAAlB,EAAwB,KAAK,KAA7B,EAAoC,IAApC,EAA0C,KAAK,KAA/C,CAAP;AACD,G;;qBAED,G,GAAA,SAAA,GAAA,CAAI,IAAJ,EAAc,EAAd,EAAqC;6BAA7B,GAAG,C;yBAAK,GAAG,KAAK,IAAL,CAAU,M;;AAC3B,QAAI,IAAI,IAAI,CAAR,IAAa,EAAE,IAAI,KAAK,IAAL,CAAU,MAAjC,EAAuC;AAAE,aAAO,IAAP;AAAW;;AACpD,WAAO,KAAK,QAAL,CAAc,KAAK,IAAL,CAAU,KAAV,CAAgB,IAAhB,EAAsB,EAAtB,CAAd,CAAP;AACD,G;;qBAED,E,GAAA,SAAA,EAAA,CAAG,KAAH,EAAU;AACR,WAAO,KAAK,UAAL,CAAgB,KAAhB,KAA0B,KAAK,IAAL,IAAa,KAAK,CAAC,IAApD;AACD,G;;qBAED,M,GAAA,SAAA,MAAA,GAAS;AACPN,QAAI,IAAI,GAAGM,IAAAA,CAAAA,SAAAA,CAAM,MAANA,CAAM,IAANA,CAAY,IAAZA,CAAXN;AACA,IAAA,IAAI,CAAC,IAAL,GAAY,KAAK,IAAjB;AACA,WAAO,IAAP;AACD,G;;;;CA1CkB,CAAS,IAAT,CAAd;;AA6CP,SAAS,SAAT,CAAmB,KAAnB,EAA0B,GAA1B,EAA+B;AAC7B,OAAKA,IAAI,CAAC,GAAG,KAAK,CAAC,MAAN,GAAe,CAA5B,EAA+B,CAAC,IAAI,CAApC,EAAuC,CAAC,EAAxC,E;AACE,IAAA,GAAG,GAAG,KAAK,CAAC,CAAD,CAAL,CAAS,IAAT,CAAc,IAAd,GAAqB,GAArB,GAA2B,GAA3B,GAAiC,GAAvC;AAA0C;;AAC5C,SAAO,GAAP;AACD,C;;;;;;ACxZD,IAAa,YAAY,GACvB,SAAA,YAAA,CAAY,QAAZ,EAAsB;;;AAGpB,OAAK,QAAL,GAAgB,QAAhB;AACA,OAAK,IAAL,GAAY,EAAZ;AACA,OAAK,SAAL,GAAiB,EAAjB;CANJ;;;;;;;;;;kBAOG;;;;AAED,YAAA,CAAO,KAAP,GAAO,SAAA,KAAA,CAAM,MAAN,EAAc,SAAd,EAAyB;AAChC,MAAM,MAAM,GAAG,IAAI,WAAJ,CAAgB,MAAhB,EAAwB,SAAxB,CAAf;;AACA,MAAM,MAAM,CAAC,IAAP,IAAe,IAArB,EAAyB;AAAE,WAAO,YAAY,CAAC,KAApB;AAAyB;;AAClDA,MAAI,IAAI,GAAG,SAAS,CAAC,MAAD,CAApBA;;AACF,MAAM,MAAM,CAAC,IAAb,EAAiB;AAAE,IAAA,MAAM,CAAC,GAAP,CAAW,0BAAX;AAAsC;;AACzD,MAAM,KAAK,GAAG,GAAG,CAAC,GAAG,CAAC,IAAD,CAAJ,CAAjB;AACE,EAAA,gBAAgB,CAAC,KAAD,EAAQ,MAAR,CAAhB;AACA,SAAO,KAAP;AACD,CARD,C;;;;;AAaF,YAAA,CAAA,SAAA,CAAE,SAAF,GAAE,SAAA,SAAA,CAAU,IAAV,EAAgB;AACd,OAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,IAAL,CAAU,MAA9B,EAAsC,CAAC,IAAI,CAA3C,EACA;AAAE,QAAI,KAAK,IAAL,CAAU,CAAV,KAAgB,IAApB,EAAwB;AAAE,aAAO,KAAK,IAAL,CAAU,CAAC,GAAG,CAAd,CAAP;AAAsB;AAAC;;AACnD,SAAO,IAAP;AACD,CAJH,C;;;;;AASA,YAAA,CAAA,SAAA,CAAE,aAAF,GAAE,SAAA,aAAA,CAAc,IAAd,EAAoB,KAApB,EAA+B,GAA/B,EAAsD;6BAA7B,GAAG,C;yBAAM,GAAG,IAAI,CAAC,U;AACxCA,MAAI,GAAG,GAAG,IAAVA;;AACA,OAAKA,IAAI,CAAC,GAAG,KAAb,EAAoB,GAAG,IAAI,CAAC,GAAG,GAA/B,EAAoC,CAAC,EAArC,EACA;AAAE,IAAA,GAAG,GAAG,GAAG,CAAC,SAAJ,CAAc,IAAI,CAAC,KAAL,CAAW,CAAX,EAAc,IAA5B,CAAN;AAAuC;;AACzC,SAAO,GAAP;AACD,CALH;;AAOAG,oBAAAA,CAAM,aAANA,CAAM,GAANA,GAAM,YAAgB;AACpB,MAAM,KAAK,GAAG,KAAK,IAAL,CAAU,CAAV,CAAd;AACE,SAAO,KAAK,GAAG,KAAK,CAAC,QAAT,GAAoB,KAAhC;AACD,CAHHA,C;;;;;AAQAA,oBAAAA,CAAM,WAANA,CAAM,GAANA,GAAM,YAAc;AAChB,OAAKH,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,IAAL,CAAU,MAA9B,EAAsC,CAAC,IAAI,CAA3C,EAA8C;AAC9C,QAAM,IAAI,GAAG,KAAK,IAAL,CAAU,CAAV,CAAb;;AACE,QAAI,EAAE,IAAI,CAAC,MAAL,IAAe,IAAI,CAAC,gBAAL,EAAjB,CAAJ,EAA6C;AAAE,aAAO,IAAP;AAAW;AAC3D;AACF,CALHG;;AAOA,YAAA,CAAA,SAAA,CAAE,UAAF,GAAE,SAAA,UAAA,CAAW,KAAX,EAAkB;AAChB,OAAKH,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,IAAL,CAAU,MAA9B,EAAsC,CAAC,IAAI,CAA3C,EACA;AAAE,SAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,IAAN,CAAW,MAA/B,EAAuC,CAAC,IAAI,CAA5C,EACA;AAAE,UAAI,KAAK,IAAL,CAAU,CAAV,KAAgB,KAAK,CAAC,IAAN,CAAW,CAAX,CAApB,EAAiC;AAAE,eAAO,IAAP;AAAO;AAAA;AAAI;;AAClD,SAAO,KAAP;AACD,CALH,C;;;;;;;;;AAcA,YAAA,CAAA,SAAA,CAAE,UAAF,GAAE,SAAA,UAAA,CAAW,KAAX,EAAkB,KAAlB,EAAiC,UAAjC,EAAiD;6BAA1B,GAAG,K;uCAAiB,GAAG,C;AAC5CA,MAAI,IAAI,GAAG,CAAC,IAAD,CAAXA;;AACA,WAAS,MAAT,CAAgB,KAAhB,EAAuB,KAAvB,EAA8B;AAC9B,QAAM,QAAQ,GAAG,KAAK,CAAC,aAAN,CAAoB,KAApB,EAA2B,UAA3B,CAAjB;;AACA,QAAM,QAAQ,KAAK,CAAC,KAAD,IAAU,QAAQ,CAAC,QAAxB,CAAd,EACE;AAAE,aAAO,QAAQ,CAAC,IAAT,CAAc,KAAK,CAAC,GAAN,CAAS,UAAC,EAAD,EAAI;AAAA,eAAG,EAAE,CAAC,aAAH,EAAH;AAAqB,OAAlC,CAAd,CAAP;AAAyD;;AAE3D,SAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,IAAN,CAAW,MAA/B,EAAuC,CAAC,IAAI,CAA5C,EAA+C;AAC/C,UAAM,IAAI,GAAG,KAAK,CAAC,IAAN,CAAW,CAAX,CAAb;AAAA,UAA4B,IAAI,GAAG,KAAK,CAAC,IAAN,CAAW,CAAC,GAAG,CAAf,CAAnC;;AACA,UAAM,EAAE,IAAI,CAAC,MAAL,IAAe,IAAI,CAAC,gBAAL,EAAjB,KAA6C,IAAI,CAAC,OAAL,CAAa,IAAb,KAAsB,CAAC,CAA1E,EAA6E;AACzE,QAAA,IAAI,CAAC,IAAL,CAAU,IAAV;AACAA,YAAI,KAAK,GAAG,MAAM,CAAC,IAAD,EAAO,KAAK,CAAC,MAAN,CAAa,IAAb,CAAP,CAAlBA;;AACA,YAAI,KAAJ,EAAS;AAAE,iBAAO,KAAP;AAAY;AACxB;AACF;AACF;;AAED,SAAO,MAAM,CAAC,IAAD,EAAO,EAAP,CAAb;AACD,CAlBH,C;;;;;;;AAyBA,YAAA,CAAA,SAAA,CAAE,YAAF,GAAE,SAAA,YAAA,CAAa,MAAb,EAAqB;AACnB,OAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,SAAL,CAAe,MAAnC,EAA2C,CAAC,IAAI,CAAhD,EACA;AAAE,QAAI,KAAK,SAAL,CAAe,CAAf,KAAqB,MAAzB,EAA+B;AAAE,aAAO,KAAK,SAAL,CAAe,CAAC,GAAG,CAAnB,CAAP;AAA2B;AAAC;;AACjE,MAAM,QAAQ,GAAG,KAAK,eAAL,CAAqB,MAArB,CAAjB;AACA,OAAO,SAAP,CAAiB,IAAjB,CAAsB,MAAtB,EAA8B,QAA9B;AACE,SAAO,QAAP;AACD,CANH;;AAQA,YAAA,CAAA,SAAA,CAAE,eAAF,GAAE,SAAA,eAAA,CAAgB,MAAhB,EAAwB;AACxB,MAAM,IAAI,GAAG,MAAM,CAAC,MAAP,CAAc,IAAd,CAAb;AAAA,MAAkC,MAAM,GAAG,CAAC;AAAC,IAAA,KAAK,EAAE,IAAR;AAAc,IAAA,IAAI,EAAE,IAApB;AAA0B,IAAA,GAAG,EAAE;AAA/B,GAAD,CAA3C;;AACE,SAAO,MAAM,CAAC,MAAd,EAAsB;AACpBA,QAAI,OAAO,GAAG,MAAM,CAAC,KAAP,EAAdA;AAAAA,QAA8B,KAAK,GAAG,OAAO,CAAC,KAA9CA;;AACA,QAAI,KAAK,CAAC,SAAN,CAAgB,MAAhB,CAAJ,EAA6B;AAC3BA,UAAI,MAAM,GAAG,EAAbA;;AACA,WAAKA,IAAI,GAAG,GAAG,OAAf,EAAwB,GAAG,CAAC,IAA5B,EAAkC,GAAG,GAAG,GAAG,CAAC,GAA5C,EACA;AAAE,QAAA,MAAM,CAAC,IAAP,CAAY,GAAG,CAAC,IAAhB;AAAqB;;AACvB,aAAO,MAAM,CAAC,OAAP,EAAP;AACD;;AACD,SAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,IAAN,CAAW,MAA/B,EAAuC,CAAC,IAAI,CAA5C,EAA+C;AAC/C,UAAM,IAAI,GAAG,KAAK,CAAC,IAAN,CAAW,CAAX,CAAb;;AACE,UAAI,CAAC,IAAI,CAAC,MAAN,IAAgB,CAAC,IAAI,CAAC,gBAAL,EAAjB,IAA4C,EAAE,IAAI,CAAC,IAAL,IAAa,IAAf,CAA5C,KAAqE,CAAC,OAAO,CAAC,IAAT,IAAiB,KAAK,CAAC,IAAN,CAAW,CAAC,GAAG,CAAf,EAAkB,QAAxG,CAAJ,EAAuH;AACrH,QAAA,MAAM,CAAC,IAAP,CAAY;AAAC,UAAA,KAAK,EAAE,IAAI,CAAC,YAAb;AAAyB,UAAA,IAAA,EAAE,IAA3B;AAAiC,UAAA,GAAG,EAAE;AAAtC,SAAZ;AACA,QAAA,IAAI,CAAC,IAAI,CAAC,IAAN,CAAJ,GAAkB,IAAlB;AACD;AACF;AACF;AACF,CAlBH,C;;;;;AAuBAG,oBAAAA,CAAM,SAANA,CAAM,GAANA,GAAM,YAAY;AACd,SAAO,KAAK,IAAL,CAAU,MAAV,IAAoB,CAA3B;AACD,CAFHA,C;;;;;AAOA,YAAA,CAAA,SAAA,CAAE,IAAF,GAAE,SAAA,IAAA,CAAK,CAAL,EAAQ;AACNH,MAAI,CAAC,GAAG,CAAC,IAAI,CAAbA;;AACA,MAAI,CAAC,IAAI,KAAK,IAAL,CAAU,MAAnB,EAAyB;AAAE,UAAM,IAAI,UAAJ,CAAc,gBAAe,CAAf,GAAgB,+BAA9B,CAAN;AAAoE;;AACjG,SAAS;AAAC,IAAA,IAAI,EAAE,KAAK,IAAL,CAAU,CAAV,CAAP;AAAqB,IAAA,IAAI,EAAE,KAAK,IAAL,CAAU,CAAC,GAAG,CAAd;AAA3B,GAAT;AACC,CAJH;;AAMA,YAAA,CAAA,SAAA,CAAE,QAAF,GAAE,SAAA,QAAA,GAAW;AACTA,MAAI,IAAI,GAAG,EAAXA;;AACA,WAAS,IAAT,CAAc,CAAd,EAAiB;AACf,IAAA,IAAI,CAAC,IAAL,CAAU,CAAV;;AACA,SAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,CAAC,CAAC,IAAF,CAAO,MAA3B,EAAmC,CAAC,IAAI,CAAxC,EACA;AAAE,UAAI,IAAI,CAAC,OAAL,CAAa,CAAC,CAAC,IAAF,CAAO,CAAP,CAAb,KAA2B,CAAC,CAAhC,EAAiC;AAAE,QAAA,IAAI,CAAC,CAAC,CAAC,IAAF,CAAO,CAAP,CAAD,CAAJ;AAAc;AAAC;AACrD;;AACH,EAAA,IAAM,CAAC,IAAD,CAAN;AACA,SAAS,IAAI,CAAC,GAAL,CAAQ,UAAE,CAAF,EAAK,CAAL,EAAQ;AACrBA,QAAI,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC,QAAF,GAAa,GAAb,GAAmB,GAAvB,CAAD,GAA+B,GAAzCA;;AACA,SAAKA,IAAIO,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAG,CAAC,CAAC,IAAF,CAAO,MAA3B,EAAmCA,GAAC,IAAI,CAAxC,EACA;AAAE,MAAA,GAAG,IAAI,CAACA,GAAC,GAAG,IAAH,GAAU,EAAZ,IAAkB,CAAC,CAAC,IAAF,CAAOA,GAAP,EAAU,IAA5B,GAAmC,IAAnC,GAA0C,IAAI,CAAC,OAAL,CAAa,CAAC,CAAC,IAAF,CAAOA,GAAC,GAAG,CAAX,CAAb,CAAjD;AAA4E;;AAC9E,WAAO,GAAP;AACD,GALM,EAKJ,IALI,CAKC,IALD,CAAT;AAMC,CAdH;;gDAeC,oB;AAED,YAAY,CAAC,KAAb,GAAqB,IAAI,YAAJ,CAAiB,IAAjB,CAArB;;AAEA,IAAM,WAAW,GACf,SAAA,WAAA,CAAY,MAAZ,EAAoB,SAApB,EAA+B;AAC7B,OAAK,MAAL,GAAc,MAAd;AACA,OAAK,SAAL,GAAiB,SAAjB;AACA,OAAK,MAAL,GAAc,IAAd;AACA,OAAK,GAAL,GAAW,CAAX;AACF,OAAO,MAAP,GAAgB,MAAM,CAAC,KAAP,CAAa,gBAAb,CAAhB;;AACA,MAAM,KAAK,MAAL,CAAY,KAAK,MAAL,CAAY,MAAZ,GAAqB,CAAjC,KAAuC,EAA7C,EAA+C;AAAE,SAAK,MAAL,CAAY,GAAZ;AAAiB;;AAChE,MAAI,KAAK,MAAL,CAAY,CAAZ,KAAkB,EAAtB,EAAwB;AAAE,SAAK,MAAL,CAAY,OAAZ;AAAqB;CARnD;;;;kBASG;;;;AAEDF,sBAAAA,CAAI,IAAJA,CAAI,GAAJA,GAAI,YAAO;AAAE,SAAO,KAAK,MAAL,CAAY,KAAK,GAAjB,CAAP;AAA4B,CAAzCA;;AAEF,WAAA,CAAA,SAAA,CAAE,GAAF,GAAE,SAAA,GAAA,CAAI,GAAJ,EAAS;AAAE,SAAO,KAAK,IAAL,IAAa,GAAb,KAAqB,KAAK,GAAL,MAAc,IAAnC,CAAP;AAA+C,CAA5D;;AAEA,WAAA,CAAA,SAAA,CAAE,GAAF,GAAE,SAAA,GAAA,CAAI,GAAJ,EAAS;AAAE,QAAM,IAAI,WAAJ,CAAgB,GAAG,GAAG,2BAAN,GAAoC,KAAK,MAAzC,GAAkD,IAAlE,CAAN;AAA+E,CAA5F;;+CACC,sB;;AAED,SAAS,SAAT,CAAmB,MAAnB,EAA2B;AACzBL,MAAI,KAAK,GAAG,EAAZA;;AACA,KAAG;AAAE,IAAA,KAAK,CAAC,IAAN,CAAW,YAAY,CAAC,MAAD,CAAvB;AAAkC,GAAvC,QACO,MAAM,CAAC,GAAP,CAAW,GAAX,CADP;;AAEA,SAAO,KAAK,CAAC,MAAN,IAAgB,CAAhB,GAAoB,KAAK,CAAC,CAAD,CAAzB,GAA+B;AAAC,IAAA,IAAI,EAAE,QAAP;AAAe,IAAA,KAAA,EAAE;AAAjB,GAAtC;AACD;;AAED,SAAS,YAAT,CAAsB,MAAtB,EAA8B;AAC5BA,MAAI,KAAK,GAAG,EAAZA;;AACA,KAAG;AAAE,IAAA,KAAK,CAAC,IAAN,CAAW,kBAAkB,CAAC,MAAD,CAA7B;AAAwC,GAA7C,QACO,MAAM,CAAC,IAAP,IAAe,MAAM,CAAC,IAAP,IAAe,GAA9B,IAAqC,MAAM,CAAC,IAAP,IAAe,GAD3D;;AAEA,SAAO,KAAK,CAAC,MAAN,IAAgB,CAAhB,GAAoB,KAAK,CAAC,CAAD,CAAzB,GAA+B;AAAC,IAAA,IAAI,EAAE,KAAP;AAAY,IAAA,KAAA,EAAE;AAAd,GAAtC;AACD;;AAED,SAAS,kBAAT,CAA4B,MAA5B,EAAoC;AAClCA,MAAI,IAAI,GAAG,aAAa,CAAC,MAAD,CAAxBA;;AACA,WAAS;AACP,QAAI,MAAM,CAAC,GAAP,CAAW,GAAX,CAAJ,E;AACE,MAAA,IAAI,GAAG;AAAC,QAAA,IAAI,EAAE,MAAP;AAAa,QAAA,IAAA,EAAE;AAAf,OAAP;AAA2B,KAD7B,MAEK,IAAI,MAAM,CAAC,GAAP,CAAW,GAAX,CAAJ,E;AACH,MAAA,IAAI,GAAG;AAAC,QAAA,IAAI,EAAE,MAAP;AAAa,QAAA,IAAA,EAAE;AAAf,OAAP;AAA2B,KADxB,MAEA,IAAI,MAAM,CAAC,GAAP,CAAW,GAAX,CAAJ,E;AACH,MAAA,IAAI,GAAG;AAAC,QAAA,IAAI,EAAE,KAAP;AAAY,QAAA,IAAA,EAAE;AAAd,OAAP;AAA0B,KADvB,MAEA,IAAI,MAAM,CAAC,GAAP,CAAW,GAAX,CAAJ,E;AACH,MAAA,IAAI,GAAG,cAAc,CAAC,MAAD,EAAS,IAAT,CAArB;AAAmC,KADhC,M;AAEA;AAAK;AACX;;AACD,SAAO,IAAP;AACD;;AAED,SAAS,QAAT,CAAkB,MAAlB,EAA0B;AACxB,MAAI,KAAK,IAAL,CAAU,MAAM,CAAC,IAAjB,CAAJ,EAA0B;AAAE,IAAA,MAAM,CAAC,GAAP,CAAW,2BAA2B,MAAM,CAAC,IAAlC,GAAyC,GAApD;AAAwD;;AACpFA,MAAI,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,IAAR,CAAnBA;AACA,EAAA,MAAM,CAAC,GAAP;AACA,SAAO,MAAP;AACD;;AAED,SAAS,cAAT,CAAwB,MAAxB,EAAgC,IAAhC,EAAsC;AACpCA,MAAI,GAAG,GAAG,QAAQ,CAAC,MAAD,CAAlBA;AAAAA,MAA4B,GAAG,GAAG,GAAlCA;;AACA,MAAI,MAAM,CAAC,GAAP,CAAW,GAAX,CAAJ,EAAqB;AACnB,QAAI,MAAM,CAAC,IAAP,IAAe,GAAnB,EAAsB;AAAE,MAAA,GAAG,GAAG,QAAQ,CAAC,MAAD,CAAd;AAAsB,KAA9C,M;AACK,MAAA,GAAG,GAAG,CAAC,CAAP;AAAQ;AACd;;AACD,MAAI,CAAC,MAAM,CAAC,GAAP,CAAW,GAAX,CAAL,EAAoB;AAAE,IAAA,MAAM,CAAC,GAAP,CAAW,uBAAX;AAAmC;;AACzD,SAAO;AAAC,IAAA,IAAI,EAAE,OAAP;AAAc,IAAA,GAAA,EAAE,GAAhB;AAAmB,IAAA,GAAA,EAAE,GAArB;AAAwB,IAAA,IAAA,EAAE;AAA1B,GAAP;AACD;;AAED,SAAS,WAAT,CAAqB,MAArB,EAA6B,IAA7B,EAAmC;AACjCA,MAAI,KAAK,GAAG,MAAM,CAAC,SAAnBA;AAAAA,MAA8B,IAAI,GAAG,KAAK,CAAC,IAAD,CAA1CA;;AACA,MAAI,IAAJ,EAAQ;AAAE,WAAO,CAAC,IAAD,CAAP;AAAa;;AACvBA,MAAI,MAAM,GAAG,EAAbA;;AACA,OAAKA,IAAI,QAAT,IAAqB,KAArB,EAA4B;AAC1BA,QAAIQ,MAAI,GAAG,KAAK,CAAC,QAAD,CAAhBR;;AACA,QAAIQ,MAAI,CAAC,MAALA,CAAY,OAAZA,CAAoB,IAApBA,IAA4B,CAAC,CAAjC,EAAkC;AAAE,MAAA,MAAM,CAAC,IAAP,CAAYA,MAAZ;AAAiB;AACtD;;AACD,MAAI,MAAM,CAAC,MAAP,IAAiB,CAArB,EAAsB;AAAE,IAAA,MAAM,CAAC,GAAP,CAAW,4BAA4B,IAA5B,GAAmC,SAA9C;AAAwD;;AAChF,SAAO,MAAP;AACD;;AAED,SAAS,aAAT,CAAuB,MAAvB,EAA+B;AAC7B,MAAI,MAAM,CAAC,GAAP,CAAW,GAAX,CAAJ,EAAqB;AACnBR,QAAI,IAAI,GAAG,SAAS,CAAC,MAAD,CAApBA;;AACA,QAAI,CAAC,MAAM,CAAC,GAAP,CAAW,GAAX,CAAL,EAAoB;AAAE,MAAA,MAAM,CAAC,GAAP,CAAW,uBAAX;AAAmC;;AACzD,WAAO,IAAP;AACD,GAJD,MAIO,IAAI,CAAC,KAAK,IAAL,CAAU,MAAM,CAAC,IAAjB,CAAL,EAA6B;AAClCA,QAAI,KAAK,GAAG,WAAW,CAAC,MAAD,EAAS,MAAM,CAAC,IAAhB,CAAX,CAAiC,GAAjC,CAAoC,UAAC,IAAD,EAAM;AACpD,UAAI,MAAM,CAAC,MAAP,IAAiB,IAArB,EAAyB;AAAE,QAAA,MAAM,CAAC,MAAP,GAAgB,IAAI,CAAC,QAArB;AAA6B,OAAxD,MACK,IAAI,MAAM,CAAC,MAAP,IAAiB,IAAI,CAAC,QAA1B,EAAkC;AAAE,QAAA,MAAM,CAAC,GAAP,CAAW,iCAAX;AAA6C;;AACtF,aAAO;AAAC,QAAA,IAAI,EAAE,MAAP;AAAe,QAAA,KAAK,EAAE;AAAtB,OAAP;AACD,KAJW,CAAZA;AAKA,IAAA,MAAM,CAAC,GAAP;AACA,WAAO,KAAK,CAAC,MAAN,IAAgB,CAAhB,GAAoB,KAAK,CAAC,CAAD,CAAzB,GAA+B;AAAC,MAAA,IAAI,EAAE,QAAP;AAAe,MAAA,KAAA,EAAE;AAAjB,KAAtC;AACD,GARM,MAQA;AACL,IAAA,MAAM,CAAC,GAAP,CAAW,uBAAuB,MAAM,CAAC,IAA9B,GAAqC,GAAhD;AACD;AACF,C;;;;;;;;;;;;;;AAeD,SAAS,GAAT,CAAa,IAAb,EAAmB;AACjBA,MAAI,GAAG,GAAG,CAAC,EAAD,CAAVA;AACA,EAAA,OAAO,CAAC,OAAO,CAAC,IAAD,EAAO,CAAP,CAAR,EAAmB,IAAI,EAAvB,CAAP;AACA,SAAO,GAAP;;AAEA,WAAS,IAAT,GAAgB;AAAE,WAAO,GAAG,CAAC,IAAJ,CAAS,EAAT,IAAe,CAAtB;AAAyB;;AAC3C,WAAS,IAAT,CAAc,IAAd,EAAoB,EAApB,EAAwB,IAAxB,EAA8B;AAC5BA,QAAI,IAAI,GAAG;AAAA,MAAA,IAAA,EAAC,IAAD;AAAK,MAAA,EAAA,EAAE;AAAP,KAAXA;AACA,IAAA,GAAG,CAAC,IAAD,CAAH,CAAU,IAAV,CAAe,IAAf;AACA,WAAO,IAAP;AACD;;AACD,WAAS,OAAT,CAAiB,KAAjB,EAAwB,EAAxB,EAA4B;AAAE,IAAA,KAAK,CAAC,OAAN,CAAa,UAAC,IAAD,EAAM;AAAA,aAAG,IAAI,CAAC,EAAL,GAAU,EAAb;AAAe,KAAlC;AAAqC;;AAEnE,WAAS,OAAT,CAAiB,IAAjB,EAAuB,IAAvB,EAA6B;AAC3B,QAAI,IAAI,CAAC,IAAL,IAAa,QAAjB,EAA2B;AACzB,aAAO,IAAI,CAAC,KAAL,CAAW,MAAX,CAAiB,UAAE,GAAF,EAAO,IAAP,EAAa;AAAA,eAAG,GAAG,CAAC,MAAJ,CAAW,OAAO,CAAC,IAAD,EAAO,IAAP,CAAlB,CAAH;AAAkC,OAAhE,EAAkE,EAAlE,CAAP;AACD,KAFD,MAEO,IAAI,IAAI,CAAC,IAAL,IAAa,KAAjB,EAAwB;AAC7B,WAAKA,IAAI,CAAC,GAAG,CAAb,GAAiB,CAAC,EAAlB,EAAsB;AACpBA,YAAI,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,KAAL,CAAW,CAAX,CAAD,EAAgB,IAAhB,CAAlBA;;AACA,YAAI,CAAC,IAAI,IAAI,CAAC,KAAL,CAAW,MAAX,GAAoB,CAA7B,EAA8B;AAAE,iBAAO,IAAP;AAAW;;AAC3C,QAAA,OAAO,CAAC,IAAD,EAAO,IAAI,GAAG,IAAI,EAAlB,CAAP;AACD;AACF,KANM,MAMA,IAAI,IAAI,CAAC,IAAL,IAAa,MAAjB,EAAyB;AAC9BA,UAAI,IAAI,GAAG,IAAI,EAAfA;AACA,MAAA,IAAI,CAAC,IAAD,EAAO,IAAP,CAAJ;AACA,MAAA,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,IAAN,EAAY,IAAZ,CAAR,EAA2B,IAA3B,CAAP;AACA,aAAO,CAAC,IAAI,CAAC,IAAD,CAAL,CAAP;AACD,KALM,MAKA,IAAI,IAAI,CAAC,IAAL,IAAa,MAAjB,EAAyB;AAC9BA,UAAIS,MAAI,GAAG,IAAI,EAAfT;AACA,MAAA,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,IAAN,EAAY,IAAZ,CAAR,EAA2BS,MAA3B,CAAP;AACA,MAAA,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,IAAN,EAAYA,MAAZ,CAAR,EAA2BA,MAA3B,CAAP;AACA,aAAO,CAAC,IAAI,CAACA,MAAD,CAAL,CAAP;AACD,KALM,MAKA,IAAI,IAAI,CAAC,IAAL,IAAa,KAAjB,EAAwB;AAC7B,aAAO,CAAC,IAAI,CAAC,IAAD,CAAL,EAAa,MAAb,CAAoB,OAAO,CAAC,IAAI,CAAC,IAAN,EAAY,IAAZ,CAA3B,CAAP;AACD,KAFM,MAEA,IAAI,IAAI,CAAC,IAAL,IAAa,OAAjB,EAA0B;AAC/BT,UAAI,GAAG,GAAG,IAAVA;;AACA,WAAKA,IAAIO,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAG,IAAI,CAAC,GAAzB,EAA8BA,GAAC,EAA/B,EAAmC;AACjCP,YAAIU,MAAI,GAAG,IAAI,EAAfV;AACA,QAAA,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,IAAN,EAAY,GAAZ,CAAR,EAA0BU,MAA1B,CAAP;AACA,QAAA,GAAG,GAAGA,MAAN;AACD;;AACD,UAAI,IAAI,CAAC,GAAL,IAAY,CAAC,CAAjB,EAAoB;AAClB,QAAA,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,IAAN,EAAY,GAAZ,CAAR,EAA0B,GAA1B,CAAP;AACD,OAFD,MAEO;AACL,aAAKV,IAAIO,GAAC,GAAG,IAAI,CAAC,GAAlB,EAAuBA,GAAC,GAAG,IAAI,CAAC,GAAhC,EAAqCA,GAAC,EAAtC,EAA0C;AACxCP,cAAIU,MAAI,GAAG,IAAI,EAAfV;AACA,UAAA,IAAI,CAAC,GAAD,EAAMU,MAAN,CAAJ;AACA,UAAA,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,IAAN,EAAY,GAAZ,CAAR,EAA0BA,MAA1B,CAAP;AACA,UAAA,GAAG,GAAGA,MAAN;AACD;AACF;;AACD,aAAO,CAAC,IAAI,CAAC,GAAD,CAAL,CAAP;AACD,KAlBM,MAkBA,IAAI,IAAI,CAAC,IAAL,IAAa,MAAjB,EAAyB;AAC9B,aAAO,CAAC,IAAI,CAAC,IAAD,EAAO,IAAP,EAAa,IAAI,CAAC,KAAlB,CAAL,CAAP;AACD;AACF;AACF;;AAED,SAAS,GAAT,CAAa,CAAb,EAAgB,CAAhB,EAAmB;AAAE,SAAO,CAAC,GAAG,CAAX;AAAc,C;;;;;AAKnC,SAAS,QAAT,CAAkB,GAAlB,EAAuB,IAAvB,EAA6B;AAC3BV,MAAI,MAAM,GAAG,EAAbA;AACA,EAAA,IAAI,CAAC,IAAD,CAAJ;AACA,SAAO,MAAM,CAAC,IAAP,CAAY,GAAZ,CAAP;;AAEA,WAAS,IAAT,CAAc,IAAd,EAAoB;AAClBA,QAAI,KAAK,GAAG,GAAG,CAAC,IAAD,CAAfA;;AACA,QAAI,KAAK,CAAC,MAAN,IAAgB,CAAhB,IAAqB,CAAC,KAAK,CAAC,CAAD,CAAL,CAAS,IAAnC,EAAuC;AAAE,aAAO,IAAI,CAAC,KAAK,CAAC,CAAD,CAAL,CAAS,EAAV,CAAX;AAAwB;;AACjE,IAAA,MAAM,CAAC,IAAP,CAAY,IAAZ;;AACA,SAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,EAAnC,EAAuC;AACrC,UAAA,GAAc,GAAG,KAAK,CAAC,CAAD,CAAtB;AAAK,UAAA,IAAA,GAAA,GAAA,CAAA,IAAA;AAAM,UAAA,EAAA,GAAA,GAAA,CAAA,EAAA;;AACX,UAAI,CAAC,IAAD,IAAS,MAAM,CAAC,OAAP,CAAe,EAAf,KAAsB,CAAC,CAApC,EAAqC;AAAE,QAAA,IAAI,CAAC,EAAD,CAAJ;AAAQ;AAChD;AACF;AACF,C;;;;;;AAMD,SAAS,GAAT,CAAa,GAAb,EAAkB;AAChBA,MAAI,OAAO,GAAG,MAAM,CAAC,MAAP,CAAc,IAAd,CAAdA;AACA,SAAO,OAAO,CAAC,QAAQ,CAAC,GAAD,EAAM,CAAN,CAAT,CAAd;;AAEA,WAAS,OAAT,CAAiB,MAAjB,EAAyB;AACvBA,QAAI,GAAG,GAAG,EAAVA;AACA,IAAA,MAAM,CAAC,OAAP,CAAc,UAAC,IAAD,EAAM;AAClB,MAAA,GAAG,CAAC,IAAD,CAAH,CAAU,OAAV,CAAiB,UAAE,GAAF,EAAiB;uBAAR,I;;;AACxB,YAAI,CAAC,IAAL,EAAS;AAAE;AAAM;;AACjBA,YAAI,KAAK,GAAG,GAAG,CAAC,OAAJ,CAAY,IAAZ,CAAZA;AAAAA,YAA+B,GAAG,GAAG,KAAK,GAAG,CAAC,CAAT,IAAc,GAAG,CAAC,KAAK,GAAG,CAAT,CAAtDA;AACA,QAAA,QAAQ,CAAC,GAAD,EAAM,EAAN,CAAR,CAAkB,OAAlB,CAAyB,UAAC,IAAD,EAAM;AAC7B,cAAI,CAAC,GAAL,EAAQ;AAAE,YAAA,GAAG,CAAC,IAAJ,CAAS,IAAT,EAAe,GAAG,GAAG,EAArB;AAAwB;;AAClC,cAAI,GAAG,CAAC,OAAJ,CAAY,IAAZ,KAAqB,CAAC,CAA1B,EAA2B;AAAE,YAAA,GAAG,CAAC,IAAJ,CAAS,IAAT;AAAc;AAC5C,SAHD;AAID,OAPD;AAQD,KATD;AAUAA,QAAI,KAAK,GAAG,OAAO,CAAC,MAAM,CAAC,IAAP,CAAY,GAAZ,CAAD,CAAP,GAA4B,IAAI,YAAJ,CAAiB,MAAM,CAAC,OAAP,CAAe,GAAG,CAAC,MAAJ,GAAa,CAA5B,IAAiC,CAAC,CAAnD,CAAxCA;;AACA,SAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAAG,CAAC,MAAxB,EAAgC,CAAC,IAAI,CAArC,EAAwC;AACtCA,UAAIW,QAAM,GAAG,GAAG,CAAC,CAAC,GAAG,CAAL,CAAH,CAAW,IAAX,CAAgB,GAAhB,CAAbX;AACA,MAAA,KAAK,CAAC,IAAN,CAAW,IAAX,CAAgB,GAAG,CAAC,CAAD,CAAnB,EAAwB,OAAO,CAACW,QAAM,CAAC,IAAPA,CAAY,GAAZA,CAAD,CAAP,IAA6B,OAAO,CAACA,QAAD,CAA5D;AACD;;AACD,WAAO,KAAP;AACD;AACF;;AAED,SAAS,gBAAT,CAA0B,KAA1B,EAAiC,MAAjC,EAAyC;AACvC,OAAKX,IAAI,CAAC,GAAG,CAARA,EAAW,IAAI,GAAG,CAAC,KAAD,CAAvB,EAAgC,CAAC,GAAG,IAAI,CAAC,MAAzC,EAAiD,CAAC,EAAlD,EAAsD;AACpDA,QAAI,KAAK,GAAG,IAAI,CAAC,CAAD,CAAhBA;AAAAA,QAAqB,IAAI,GAAG,CAAC,KAAK,CAAC,QAAnCA;AAAAA,QAA6C,KAAK,GAAG,EAArDA;;AACA,SAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,IAAN,CAAW,MAA/B,EAAuC,CAAC,IAAI,CAA5C,EAA+C;AAC7CA,UAAI,IAAI,GAAG,KAAK,CAAC,IAAN,CAAW,CAAX,CAAXA;AAAAA,UAA0B,IAAI,GAAG,KAAK,CAAC,IAAN,CAAW,CAAC,GAAG,CAAf,CAAjCA;AACA,MAAA,KAAK,CAAC,IAAN,CAAW,IAAI,CAAC,IAAhB;;AACA,UAAI,IAAI,IAAI,EAAE,IAAI,CAAC,MAAL,IAAe,IAAI,CAAC,gBAAL,EAAjB,CAAZ,EAAqD;AAAE,QAAA,IAAI,GAAG,KAAP;AAAY;;AACnE,UAAI,IAAI,CAAC,OAAL,CAAa,IAAb,KAAsB,CAAC,CAA3B,EAA4B;AAAE,QAAA,IAAI,CAAC,IAAL,CAAU,IAAV;AAAe;AAC9C;;AACD,QAAI,IAAJ,EAAQ;AAAE,MAAA,MAAM,CAAC,GAAP,CAAW,iCAAiC,KAAK,CAAC,IAAN,CAAW,IAAX,CAAjC,GAAoD,gFAA/D;AAAgJ;AAC3J;AACF,C;;;;;;ACzXD,SAAS,YAAT,CAAsB,KAAtB,EAA6B;AAC3BA,MAAI,QAAQ,GAAG,MAAM,CAAC,MAAP,CAAc,IAAd,CAAfA;;AACA,OAAKA,IAAI,QAAT,IAAqB,KAArB,EAA4B;AAC1BA,QAAI,IAAI,GAAG,KAAK,CAAC,QAAD,CAAhBA;;AACA,QAAI,CAAC,IAAI,CAAC,UAAV,EAAoB;AAAE,aAAO,IAAP;AAAW;;AACjC,IAAA,QAAQ,CAAC,QAAD,CAAR,GAAqB,IAAI,CAAC,OAA1B;AACD;;AACD,SAAO,QAAP;AACD;;AAED,SAAS,YAAT,CAAsB,KAAtB,EAA6B,KAA7B,EAAoC;AAClCA,MAAI,KAAK,GAAG,MAAM,CAAC,MAAP,CAAc,IAAd,CAAZA;;AACA,OAAKA,IAAI,IAAT,IAAiB,KAAjB,EAAwB;AACtBA,QAAI,KAAK,GAAG,KAAK,IAAI,KAAK,CAAC,IAAD,CAA1BA;;AACA,QAAI,KAAK,KAAK,SAAd,EAAyB;AACvBA,UAAI,IAAI,GAAG,KAAK,CAAC,IAAD,CAAhBA;;AACA,UAAI,IAAI,CAAC,UAAT,EAAmB;AAAE,QAAA,KAAK,GAAG,IAAI,CAAC,OAAb;AAAoB,OAAzC,M;AACK,cAAM,IAAI,UAAJ,CAAe,qCAAqC,IAApD,CAAN;AAA+D;AACrE;;AACD,IAAA,KAAK,CAAC,IAAD,CAAL,GAAc,KAAd;AACD;;AACD,SAAO,KAAP;AACD;;AAED,SAAS,SAAT,CAAmB,KAAnB,EAA0B;AACxBA,MAAI,MAAM,GAAG,MAAM,CAAC,MAAP,CAAc,IAAd,CAAbA;;AACA,MAAI,KAAJ,EAAS;AAAE,SAAKA,IAAI,IAAT,IAAiB,KAAjB,EAAsB;AAAE,MAAA,MAAM,CAAC,IAAD,CAAN,GAAe,IAAI,SAAJ,CAAc,KAAK,CAAC,IAAD,CAAnB,CAAf;AAAwC;AAAC;;AAC5E,SAAO,MAAP;AACD,C;;;;;;AAMD,IAAa,QAAQ,GACnB,SAAA,QAAA,CAAY,IAAZ,EAAkB,MAAlB,EAA0B,IAA1B,EAAgC;;;AAG9B,OAAK,IAAL,GAAY,IAAZ,CAH8B,C;;;AAO9B,OAAK,MAAL,GAAc,MAAd,CAP8B,C;;;AAW9B,OAAK,IAAL,GAAY,IAAZ;AAEA,OAAK,MAAL,GAAc,IAAI,CAAC,KAAL,GAAa,IAAI,CAAC,KAAL,CAAW,KAAX,CAAiB,GAAjB,CAAb,GAAqC,EAAnD;AACF,OAAO,KAAP,GAAe,SAAS,CAAC,IAAI,CAAC,KAAN,CAAxB;AAEA,OAAO,YAAP,GAAsB,YAAY,CAAC,KAAK,KAAN,CAAlC,CAhBgC,C;;;AAoB9B,OAAK,YAAL,GAAoB,IAApB,CApB8B,C;;;;AAyB9B,OAAK,OAAL,GAAe,IAAf,CAzB8B,C;;;AA6B9B,OAAK,aAAL,GAAqB,IAArB,CA7B8B,C;;;AAiC9B,OAAK,OAAL,GAAe,EAAE,IAAI,CAAC,MAAL,IAAe,IAAI,IAAI,MAAzB,CAAf,CAjC8B,C;;;AAqC9B,OAAK,MAAL,GAAc,IAAI,IAAI,MAAtB;CAtCJ;;;;;;;;;;;;;kBAuCG;;;;;AAIHG,oBAAAA,CAAM,QAANA,CAAM,GAANA,GAAM,YAAW;AAAE,SAAO,CAAC,KAAK,OAAb;AAAoB,CAAvCA,C;;;;;AAKEA,oBAAAA,CAAI,WAAJA,CAAI,GAAJA,GAAI,YAAc;AAAE,SAAO,KAAK,OAAL,IAAgB,KAAK,aAA5B;AAAyC,CAA7DA,C;;;;AAIAA,oBAAAA,CAAI,MAAJA,CAAI,GAAJA,GAAI,YAAS;AAAE,SAAO,KAAK,YAAL,IAAqB,YAAY,CAAC,KAAzC;AAA8C,CAA7DA,C;;;;;AAKAA,oBAAAA,CAAI,MAAJA,CAAI,GAAJA,GAAI,YAAS;AAAE,SAAO,KAAK,MAAL,IAAe,KAAK,IAAL,CAAU,IAAhC;AAAoC,CAAnDA,C;;;;AAIF,QAAA,CAAA,SAAA,CAAE,gBAAF,GAAE,SAAA,gBAAA,GAAmB;AACnB,OAAOH,IAAI,CAAX,IAAgB,KAAK,KAArB,EAA0B;AAAE,QAAI,KAAK,KAAL,CAAW,CAAX,EAAc,UAAlB,EAA4B;AAAE,aAAO,IAAP;AAAO;AAAI;;AACnE,SAAO,KAAP;AACD,CAHH;;AAKA,QAAA,CAAA,SAAA,CAAE,iBAAF,GAAE,SAAA,iBAAA,CAAkB,KAAlB,EAAyB;AACvB,SAAO,QAAQ,KAAR,IAAiB,KAAK,YAAL,CAAkB,UAAlB,CAA6B,KAAK,CAAC,YAAnC,CAAxB;AACD,CAFH;;AAIA,QAAA,CAAA,SAAA,CAAE,YAAF,GAAE,SAAA,cAAA,CAAa,KAAb,EAAoB;AACpB,MAAM,CAAC,KAAD,IAAU,KAAK,YAArB,EAAiC;AAAE,WAAO,KAAK,YAAZ;AAAwB,GAA3D,M;AACO,WAAO,YAAY,CAAC,KAAK,KAAN,EAAa,KAAb,CAAnB;AAAsC;AAC5C,CAHH,C;;;;;;;;;AAYA,QAAA,CAAA,SAAA,CAAE,MAAF,GAAE,SAAA,MAAA,CAAO,KAAP,EAAc,OAAd,EAAuB,KAAvB,EAA8B;AAC9B,MAAM,KAAK,MAAX,EAAiB;AAAE,UAAM,IAAI,KAAJ,CAAU,4CAAV,CAAN;AAA6D;;AAChF,SAAS,IAAI,IAAJ,CAAS,IAAT,EAAe,KAAK,YAAL,CAAkB,KAAlB,CAAf,EAAyC,QAAQ,CAAC,IAAT,CAAc,OAAd,CAAzC,EAAiE,IAAI,CAAC,OAAL,CAAa,KAAb,CAAjE,CAAT;AACC,CAHH,C;;;;;;AASA,QAAA,CAAA,SAAA,CAAE,aAAF,GAAE,SAAA,aAAA,CAAc,KAAd,EAAqB,OAArB,EAA8B,KAA9B,EAAqC;AACnC,EAAA,OAAO,GAAG,QAAQ,CAAC,IAAT,CAAc,OAAd,CAAV;;AACA,MAAI,CAAC,KAAK,YAAL,CAAkB,OAAlB,CAAL,EACA;AAAE,UAAM,IAAI,UAAJ,CAAe,8BAA8B,KAAK,IAAlD,CAAN;AAA6D;;AACjE,SAAS,IAAI,IAAJ,CAAS,IAAT,EAAe,KAAK,YAAL,CAAkB,KAAlB,CAAf,EAAyC,OAAzC,EAAkD,IAAI,CAAC,OAAL,CAAa,KAAb,CAAlD,CAAT;AACC,CALH,C;;;;;;;;;AAcA,QAAA,CAAA,SAAA,CAAE,aAAF,GAAE,SAAA,aAAA,CAAc,KAAd,EAAqB,OAArB,EAA8B,KAA9B,EAAqC;AACnC,EAAA,KAAK,GAAG,KAAK,YAAL,CAAkB,KAAlB,CAAR;AACA,EAAA,OAAO,GAAG,QAAQ,CAAC,IAAT,CAAc,OAAd,CAAV;;AACA,MAAI,OAAO,CAAC,IAAZ,EAAkB;AAClB,QAAM,MAAM,GAAG,KAAK,YAAL,CAAkB,UAAlB,CAA6B,OAA7B,CAAf;;AACE,QAAI,CAAC,MAAL,EAAW;AAAE,aAAO,IAAP;AAAW;;AACxB,IAAA,OAAO,GAAG,MAAM,CAAC,MAAP,CAAc,OAAd,CAAV;AACD;;AACH,MAAM,KAAK,GAAG,KAAK,YAAL,CAAkB,aAAlB,CAAgC,OAAhC,EAAyC,UAAzC,CAAoD,QAAQ,CAAC,KAA7D,EAAoE,IAApE,CAAd;;AACE,MAAI,CAAC,KAAL,EAAU;AAAE,WAAO,IAAP;AAAW;;AACzB,SAAS,IAAI,IAAJ,CAAS,IAAT,EAAe,KAAf,EAAsB,OAAO,CAAC,MAAR,CAAe,KAAf,CAAtB,EAA6C,IAAI,CAAC,OAAL,CAAa,KAAb,CAA7C,CAAT;AACC,CAXH,C;;;;;AAgBA,QAAA,CAAA,SAAA,CAAE,YAAF,GAAE,SAAA,YAAA,CAAa,OAAb,EAAsB;AACtB,MAAM,MAAM,GAAG,KAAK,YAAL,CAAkB,aAAlB,CAAgC,OAAhC,CAAf;;AACA,MAAM,CAAC,MAAD,IAAW,CAAC,MAAM,CAAC,QAAzB,EAAiC;AAAE,WAAO,KAAP;AAAY;;AAC7C,OAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,OAAO,CAAC,UAA5B,EAAwC,CAAC,EAAzC,EACA;AAAE,QAAI,CAAC,KAAK,WAAL,CAAiB,OAAO,CAAC,KAAR,CAAc,CAAd,EAAiB,KAAlC,CAAL,EAA6C;AAAE,aAAO,KAAP;AAAO;AAAK;;AAC7D,SAAO,IAAP;AACD,CANH,C;;;;AAUA,QAAA,CAAA,SAAA,CAAE,cAAF,GAAE,SAAA,cAAA,CAAe,QAAf,EAAyB;AACvB,SAAO,KAAK,OAAL,IAAgB,IAAhB,IAAwB,KAAK,OAAL,CAAa,OAAb,CAAqB,QAArB,IAAiC,CAAC,CAAjE;AACD,CAFH,C;;;;AAMA,QAAA,CAAA,SAAA,CAAE,WAAF,GAAE,SAAA,WAAA,CAAY,KAAZ,EAAmB;AACnB,MAAM,KAAK,OAAL,IAAgB,IAAtB,EAA0B;AAAE,WAAO,IAAP;AAAW;;AACrC,OAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,EAAnC,EAAqC;AAAE,QAAI,CAAC,KAAK,cAAL,CAAoB,KAAK,CAAC,CAAD,CAAL,CAAS,IAA7B,CAAL,EAAuC;AAAE,aAAO,KAAP;AAAO;AAAK;;AAC5F,SAAO,IAAP;AACD,CAJH,C;;;;AAQA,QAAA,CAAA,SAAA,CAAE,YAAF,GAAE,SAAA,YAAA,CAAa,KAAb,EAAoB;AACpB,MAAM,KAAK,OAAL,IAAgB,IAAtB,EAA0B;AAAE,WAAO,KAAP;AAAY;;AACxC,MAAM,IAAN;;AACE,OAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,EAAnC,EAAuC;AACrC,QAAI,CAAC,KAAK,cAAL,CAAoB,KAAK,CAAC,CAAD,CAAL,CAAS,IAA7B,CAAL,EAAyC;AACvC,UAAI,CAAC,IAAL,EAAS;AAAE,QAAA,IAAI,GAAG,KAAK,CAAC,KAAN,CAAY,CAAZ,EAAe,CAAf,CAAP;AAAwB;AACpC,KAFD,MAEO,IAAI,IAAJ,EAAU;AACjB,MAAA,IAAM,CAAC,IAAP,CAAY,KAAK,CAAC,CAAD,CAAjB;AACC;AACF;;AACD,SAAO,CAAC,IAAD,GAAQ,KAAR,GAAgB,IAAI,CAAC,MAAL,GAAc,IAAd,GAAqB,IAAI,CAAC,KAAjD;AACD,CAXH;;AAaE,QAAA,CAAO,OAAP,GAAO,SAAA,OAAA,CAAQ,KAAR,EAAe,MAAf,EAAuB;AAC9B,MAAM,MAAM,GAAG,MAAM,CAAC,MAAP,CAAc,IAAd,CAAf;AACA,EAAA,KAAO,CAAC,OAAR,CAAe,UAAE,IAAF,EAAQ,IAAR,EAAc;AAAA,WAAG,MAAM,CAAC,IAAD,CAAN,GAAe,IAAI,QAAJ,CAAa,IAAb,EAAmB,MAAnB,EAA2B,IAA3B,CAAlB;AAAkD,GAA/E;AAEA,MAAM,OAAO,GAAG,MAAM,CAAC,IAAP,CAAY,OAAZ,IAAuB,KAAvC;;AACE,MAAI,CAAC,MAAM,CAAC,OAAD,CAAX,EAAoB;AAAE,UAAM,IAAI,UAAJ,CAAe,2CAA2C,OAA3C,GAAqD,IAApE,CAAN;AAA+E;;AACvG,MAAM,CAAC,MAAM,CAAC,IAAd,EAAkB;AAAE,UAAM,IAAI,UAAJ,CAAe,kCAAf,CAAN;AAAwD;;AAC1E,OAAKA,IAAI,CAAT,IAAc,MAAM,CAAC,IAAP,CAAY,KAA1B,EAA+B;AAAE,UAAM,IAAI,UAAJ,CAAe,+CAAf,CAAN;AAAqE;;AAEtG,SAAO,MAAP;AACD,CAVD;;4CAWD,oB;;AAID,IAAM,SAAS,GACb,SAAA,SAAA,CAAY,OAAZ,EAAqB;AACnB,OAAK,UAAL,GAAkB,MAAM,CAAC,SAAP,CAAiB,cAAjB,CAAgC,IAAhC,CAAqC,OAArC,EAA8C,SAA9C,CAAlB;AACA,OAAK,OAAL,GAAe,OAAO,CAAC,OAAvB;CAHJ;;;;kBAIG;;;;AAEHK,sBAAAA,CAAM,UAANA,CAAM,GAANA,GAAM,YAAa;AACf,SAAO,CAAC,KAAK,UAAb;AACD,CAFHA;;6CAGC,sB;;;;;;AAQD,IAAa,QAAQ,GACnB,SAAA,QAAA,CAAY,IAAZ,EAAkB,IAAlB,EAAwB,MAAxB,EAAgC,IAAhC,EAAsC;;;AAGpC,OAAK,IAAL,GAAY,IAAZ,CAHoC,C;;;AAOpC,OAAK,MAAL,GAAc,MAAd,CAPoC,C;;;AAWpC,OAAK,IAAL,GAAY,IAAZ;AAEF,OAAO,KAAP,GAAe,SAAS,CAAC,IAAI,CAAC,KAAN,CAAxB;AAEE,OAAK,IAAL,GAAY,IAAZ;AACA,OAAK,QAAL,GAAgB,IAAhB;AACF,MAAM,QAAQ,GAAG,YAAY,CAAC,KAAK,KAAN,CAA7B;AACE,OAAK,QAAL,GAAgB,QAAQ,IAAI,IAAI,IAAJ,CAAS,IAAT,EAAe,QAAf,CAA5B;AACD,CApBH,C;;;;;;AA0BA,QAAA,CAAA,SAAA,CAAE,MAAF,GAAE,SAAA,MAAA,CAAO,KAAP,EAAc;AACd,MAAM,CAAC,KAAD,IAAU,KAAK,QAArB,EAA6B;AAAE,WAAO,KAAK,QAAZ;AAAoB;;AACjD,SAAO,IAAI,IAAJ,CAAS,IAAT,EAAe,YAAY,CAAC,KAAK,KAAN,EAAa,KAAb,CAA3B,CAAP;AACD,CAHH;;AAKE,QAAA,CAAO,OAAP,GAAO,SAAA,OAAA,CAAQ,KAAR,EAAe,MAAf,EAAuB;AAC5BL,MAAI,MAAM,GAAG,MAAM,CAAC,MAAP,CAAc,IAAd,CAAbA;AAAAA,MAAkC,IAAI,GAAG,CAAzCA;AACF,EAAA,KAAO,CAAC,OAAR,CAAe,UAAE,IAAF,EAAQ,IAAR,EAAc;AAAA,WAAG,MAAM,CAAC,IAAD,CAAN,GAAe,IAAI,QAAJ,CAAa,IAAb,EAAmB,IAAI,EAAvB,EAA2B,MAA3B,EAAmC,IAAnC,CAAlB;AAA0D,GAAvF;AACE,SAAO,MAAP;AACD,CAJD,C;;;;;AASF,QAAA,CAAA,SAAA,CAAE,aAAF,GAAE,SAAA,aAAA,CAAc,GAAd,EAAmB;AACjB,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAAG,CAAC,MAAxB,EAAgC,CAAC,EAAjC,EACA;AAAE,QAAI,GAAG,CAAC,CAAD,CAAH,CAAO,IAAP,IAAe,IAAnB,EACA;AAAE,aAAO,GAAG,CAAC,KAAJ,CAAU,CAAV,EAAa,CAAb,EAAgB,MAAhB,CAAuB,GAAG,CAAC,KAAJ,CAAU,CAAC,GAAG,CAAd,CAAvB,CAAP;AAA8C;AAAC;;AACnD,SAAO,GAAP;AACD,CALH,C;;;;AASA,QAAA,CAAA,SAAA,CAAE,OAAF,GAAE,SAAA,OAAA,CAAQ,GAAR,EAAa;AACX,OAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAAG,CAAC,MAAxB,EAAgC,CAAC,EAAjC,EACA;AAAE,QAAI,GAAG,CAAC,CAAD,CAAH,CAAO,IAAP,IAAe,IAAnB,EAAuB;AAAE,aAAO,GAAG,CAAC,CAAD,CAAV;AAAY;AAAC;AACzC,CAHH,C;;;;;AAQA,QAAA,CAAA,SAAA,CAAE,QAAF,GAAE,SAAA,QAAA,CAAS,KAAT,EAAgB;AAChB,SAAS,KAAK,QAAL,CAAc,OAAd,CAAsB,KAAtB,IAA+B,CAAC,CAAzC;AACC,CAFH,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0KA,IAAa,MAAM,GAGjB,SAAA,MAAA,CAAY,IAAZ,EAAkB;;;;;;;AAOhB,OAAK,IAAL,GAAY,EAAZ;;AACA,OAAKA,IAAI,IAAT,IAAiB,IAAjB,EAAqB;AAAE,SAAK,IAAL,CAAU,IAAV,IAAkB,IAAI,CAAC,IAAD,CAAtB;AAA4B;;AACnD,OAAK,IAAL,CAAU,KAAV,GAAkB,UAAU,CAAC,IAAX,CAAgB,IAAI,CAAC,KAArB,CAAlB;AACA,OAAK,IAAL,CAAU,KAAV,GAAkB,UAAU,CAAC,IAAX,CAAgB,IAAI,CAAC,KAArB,CAAlB,CAVgB,C;;;AAchB,OAAK,KAAL,GAAa,QAAQ,CAAC,OAAT,CAAiB,KAAK,IAAL,CAAU,KAA3B,EAAkC,IAAlC,CAAb,CAdgB,C;;;AAkBhB,OAAK,KAAL,GAAa,QAAQ,CAAC,OAAT,CAAiB,KAAK,IAAL,CAAU,KAA3B,EAAkC,IAAlC,CAAb;AAEF,MAAM,gBAAgB,GAAG,MAAM,CAAC,MAAP,CAAc,IAAd,CAAzB;;AACA,OAAOA,IAAIY,MAAX,IAAmB,KAAK,KAAxB,EAA+B;AAC3B,QAAIA,MAAI,IAAI,KAAK,KAAjB,EACA;AAAE,YAAM,IAAI,UAAJ,CAAeA,MAAI,GAAG,oCAAtB,CAAN;AAAiE;;AACrE,QAAM,IAAI,GAAG,KAAK,KAAL,CAAWA,MAAX,CAAb;AAAA,QAA+B,WAAW,GAAG,IAAI,CAAC,IAAL,CAAU,OAAV,IAAqB,EAAlE;AAAA,QAAsE,QAAQ,GAAG,IAAI,CAAC,IAAL,CAAU,KAA3F;AACE,IAAA,IAAI,CAAC,YAAL,GAAoB,gBAAgB,CAAC,WAAD,CAAhB,KACjB,gBAAgB,CAAC,WAAD,CAAhB,GAAgC,YAAY,CAAC,KAAb,CAAmB,WAAnB,EAAgC,KAAK,KAArC,CADf,CAApB;AAEF,IAAA,IAAM,CAAC,aAAP,GAAuB,IAAI,CAAC,YAAL,CAAkB,aAAzC;AACA,IAAA,IAAM,CAAC,OAAP,GAAiB,QAAQ,IAAI,GAAZ,GAAkB,IAAlB,GACb,QAAQ,GAAG,WAAW,CAAC,IAAD,EAAO,QAAQ,CAAC,KAAT,CAAe,GAAf,CAAP,CAAd,GACV,QAAU,IAAI,EAAd,IAAoB,CAAC,IAAI,CAAC,aAA1B,GAA0C,EAA1C,GAA+C,IAFjD;AAGC;;AACH,OAAOZ,IAAIY,MAAX,IAAmB,KAAK,KAAxB,EAA+B;AAC3BZ,QAAIQ,MAAI,GAAG,KAAK,KAAL,CAAWI,MAAX,CAAXZ;AAAAA,QAA6B,IAAI,GAAGQ,MAAI,CAAC,IAALA,CAAU,QAA9CR;AACAQ,IAAAA,MAAI,CAAC,QAALA,GAAgB,IAAI,IAAI,IAAR,GAAe,CAACA,MAAD,CAAf,GAAwB,IAAI,IAAI,EAAR,GAAa,EAAb,GAAkB,WAAW,CAAC,IAAD,EAAO,IAAI,CAAC,KAAL,CAAW,GAAX,CAAP,CAArEA;AACD;;AAEH,OAAO,YAAP,GAAsB,KAAK,YAAL,CAAkB,IAAlB,CAAuB,IAAvB,CAAtB;AACA,OAAO,YAAP,GAAsB,KAAK,YAAL,CAAkB,IAAlB,CAAuB,IAAvB,CAAtB,CAtCkB,C;;;;AA2ChB,OAAK,WAAL,GAAmB,KAAK,KAAL,CAAW,KAAK,IAAL,CAAU,OAAV,IAAqB,KAAhC,CAAnB,CA3CgB,C;;;;;AAiDlB,OAAO,MAAP,GAAgB,MAAM,CAAC,MAAP,CAAc,IAAd,CAAhB;AACA,OAAO,MAAP,CAAc,SAAd,GAA0B,MAAM,CAAC,MAAP,CAAc,IAAd,CAA1B;AACC,CAtDH,C;;;;;;;AA6DA,MAAA,CAAA,SAAA,CAAE,IAAF,GAAE,SAAA,IAAA,CAAK,IAAL,EAAW,KAAX,EAAkB,OAAlB,EAA2B,KAA3B,EAAkC;AAChC,MAAI,OAAO,IAAP,IAAe,QAAnB,EACA;AAAE,IAAA,IAAI,GAAG,KAAK,QAAL,CAAc,IAAd,CAAP;AAA0B,GAD5B,MAEK,IAAI,EAAE,IAAI,YAAY,QAAlB,CAAJ,EACL;AAAE,UAAM,IAAI,UAAJ,CAAe,wBAAwB,IAAvC,CAAN;AAAkD,GAD/C,MAEA,IAAI,IAAI,CAAC,MAAL,IAAe,IAAnB,EACL;AAAE,UAAM,IAAI,UAAJ,CAAe,2CAA2C,IAAI,CAAC,IAAhD,GAAuD,GAAtE,CAAN;AAAgF;;AAEpF,SAAS,IAAI,CAAC,aAAL,CAAmB,KAAnB,EAA0B,OAA1B,EAAmC,KAAnC,CAAT;AACC,CATH,C;;;;;AAcA,MAAA,CAAA,SAAA,CAAE,IAAF,GAAE,SAAA,IAAA,CAAKK,MAAL,EAAW,KAAX,EAAkB;AAClB,MAAM,IAAI,GAAG,KAAK,KAAL,CAAW,IAAxB;AACE,SAAO,IAAI,QAAJ,CAAa,IAAb,EAAmB,IAAI,CAAC,YAAxB,EAAsCA,MAAtC,EAA4C,IAAI,CAAC,OAAL,CAAa,KAAb,CAA5C,CAAP;AACD,CAHH,C;;;;AAOA,MAAA,CAAA,SAAA,CAAE,IAAF,GAAE,SAAA,IAAA,CAAK,IAAL,EAAW,KAAX,EAAkB;AAChB,MAAI,OAAO,IAAP,IAAe,QAAnB,EAA2B;AAAE,IAAA,IAAI,GAAG,KAAK,KAAL,CAAW,IAAX,CAAP;AAAuB;;AACpD,SAAO,IAAI,CAAC,MAAL,CAAY,KAAZ,CAAP;AACD,CAHH,C;;;;;AAQA,MAAA,CAAA,SAAA,CAAE,YAAF,GAAE,SAAA,YAAA,CAAa,IAAb,EAAmB;AACnB,SAAS,IAAI,CAAC,QAAL,CAAc,IAAd,EAAoB,IAApB,CAAT;AACC,CAFH,C;;;;;AAOA,MAAA,CAAA,SAAA,CAAE,YAAF,GAAE,SAAA,YAAA,CAAa,IAAb,EAAmB;AACnB,SAAS,IAAI,CAAC,QAAL,CAAc,IAAd,EAAoB,IAApB,CAAT;AACC,CAFH;;AAIA,MAAA,CAAA,SAAA,CAAE,QAAF,GAAE,SAAA,QAAA,CAAS,IAAT,EAAe;AACf,MAAM,KAAK,GAAG,KAAK,KAAL,CAAW,IAAX,CAAd;;AACA,MAAM,CAAC,KAAP,EAAY;AAAE,UAAM,IAAI,UAAJ,CAAe,wBAAwB,IAAvC,CAAN;AAAkD;;AAC9D,SAAO,KAAP;AACD,CAJH;;AAOA,SAAS,WAAT,CAAqB,MAArB,EAA6B,KAA7B,EAAoC;AAClCb,MAAI,KAAK,GAAG,EAAZA;;AACA,OAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,EAAnC,EAAuC;AACrCA,QAAI,IAAI,GAAG,KAAK,CAAC,CAAD,CAAhBA;AAAAA,QAAqB,IAAI,GAAG,MAAM,CAAC,KAAP,CAAa,IAAb,CAA5BA;AAAAA,QAAgD,EAAE,GAAG,IAArDA;;AACA,QAAI,IAAJ,EAAU;AACR,MAAA,KAAK,CAAC,IAAN,CAAW,IAAX;AACD,KAFD,MAEO;AACL,WAAKA,IAAI,IAAT,IAAiB,MAAM,CAAC,KAAxB,EAA+B;AAC7BA,YAAIc,MAAI,GAAG,MAAM,CAAC,KAAP,CAAa,IAAb,CAAXd;;AACA,YAAI,IAAI,IAAI,GAAR,IAAgBc,MAAI,CAAC,IAALA,CAAU,KAAVA,IAAmBA,MAAI,CAAC,IAALA,CAAU,KAAVA,CAAgB,KAAhBA,CAAsB,GAAtBA,EAA2B,OAA3BA,CAAmC,IAAnCA,IAA2C,CAAC,CAAnF,E;AACE,UAAA,KAAK,CAAC,IAAN,CAAW,EAAE,GAAGA,MAAhB;AAAqB;AACxB;AACF;;AACD,QAAI,CAAC,EAAL,EAAO;AAAE,YAAM,IAAI,WAAJ,CAAgB,yBAAyB,KAAK,CAAC,CAAD,CAA9B,GAAoC,GAApD,CAAN;AAA8D;AACxE;;AACD,SAAO,KAAP;AACD,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5bD,IAAa,SAAS,GAIpB,SAAA,SAAA,CAAY,MAAZ,EAAoB,KAApB,EAA2B;oBAAA,C;;;AAGzB,OAAK,MAAL,GAAc,MAAd,CAHyB,C;;;;AAOzB,OAAK,KAAL,GAAa,KAAb;AACA,OAAK,IAAL,GAAY,EAAZ;AACA,OAAK,MAAL,GAAc,EAAd;AAEA,EAAA,KAAK,CAAC,OAAN,CAAa,UAAC,IAAD,EAAM;AACjB,QAAI,IAAI,CAAC,GAAT,EAAY;AAAEC,MAAAA,MAAI,CAAC,IAALA,CAAU,IAAVA,CAAe,IAAfA;AAAoB,KAAlC,MACK,IAAI,IAAI,CAAC,KAAT,EAAc;AAAEA,MAAAA,MAAI,CAAC,MAALA,CAAY,IAAZA,CAAiB,IAAjBA;AAAsB;AAC5C,GAHD,EAXyB,C;;AAiBzB,OAAK,cAAL,GAAsB,CAAC,KAAK,IAAL,CAAU,IAAV,CAAc,UAAC,CAAD,EAAG;AACtC,QAAI,CAAC,aAAa,IAAb,CAAkB,CAAC,CAAC,GAApB,CAAD,IAA6B,CAAC,CAAC,CAAC,IAApC,EAAwC;AAAE,aAAO,KAAP;AAAY;;AACxD,QAAM,IAAI,GAAG,MAAM,CAAC,KAAP,CAAa,CAAC,CAAC,IAAf,CAAb;AACA,WAAS,IAAI,CAAC,YAAL,CAAkB,SAAlB,CAA4B,IAA5B,CAAT;AACC,GAJsB,CAAvB;AAKD,CA1BH,C;;;;AA8BA,SAAA,CAAA,SAAA,CAAE,KAAF,GAAE,SAAA,KAAA,CAAM,GAAN,EAAW,OAAX,EAAyB;iCAAP,GAAG,E;AACnBf,MAAI,OAAO,GAAG,IAAI,YAAJ,CAAiB,IAAjB,EAAuB,OAAvB,EAAgC,KAAhC,CAAdA;AACA,EAAA,OAAO,CAAC,MAAR,CAAe,GAAf,EAAoB,IAApB,EAA0B,OAAO,CAAC,IAAlC,EAAwC,OAAO,CAAC,EAAhD;AACA,SAAO,OAAO,CAAC,MAAR,EAAP;AACD,CAJH,C;;;;;;;;;AAaA,SAAA,CAAA,SAAA,CAAE,UAAF,GAAE,SAAA,UAAA,CAAW,GAAX,EAAgB,OAAhB,EAA8B;iCAAP,GAAG,E;AACxBA,MAAI,OAAO,GAAG,IAAI,YAAJ,CAAiB,IAAjB,EAAuB,OAAvB,EAAgC,IAAhC,CAAdA;AACA,EAAA,OAAO,CAAC,MAAR,CAAe,GAAf,EAAoB,IAApB,EAA0B,OAAO,CAAC,IAAlC,EAAwC,OAAO,CAAC,EAAhD;AACF,SAAS,KAAK,CAAC,OAAN,CAAc,OAAO,CAAC,MAAR,EAAd,CAAT;AACC,CAJH;;AAMA,SAAA,CAAA,SAAA,CAAE,QAAF,GAAE,SAAA,QAAA,CAAS,GAAT,EAAc,OAAd,EAAuB;AACrB,OAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,IAAL,CAAU,MAA9B,EAAsC,CAAC,EAAvC,EAA2C;AAC3C,QAAM,IAAI,GAAG,KAAK,IAAL,CAAU,CAAV,CAAb;;AACA,QAAM,OAAO,CAAC,GAAD,EAAM,IAAI,CAAC,GAAX,CAAP,KACC,IAAI,CAAC,SAAL,KAAmB,SAAnB,IAAgC,GAAG,CAAC,YAAJ,IAAoB,IAAI,CAAC,SAD1D,MAEC,CAAC,IAAI,CAAC,OAAN,IAAiB,OAAO,CAAC,cAAR,CAAuB,IAAI,CAAC,OAA5B,CAFlB,CAAN,EAE+D;AAC3D,UAAI,IAAI,CAAC,QAAT,EAAmB;AACnB,YAAM,MAAM,GAAG,IAAI,CAAC,QAAL,CAAc,GAAd,CAAf;;AACE,YAAI,MAAM,KAAK,KAAf,EAAoB;AAAE;AAAQ;;AAC9B,QAAA,IAAI,CAAC,KAAL,GAAa,MAAb;AACD;;AACD,aAAO,IAAP;AACD;AACF;AACF,CAdH;;AAgBA,SAAA,CAAA,SAAA,CAAE,UAAF,GAAE,SAAA,UAAA,CAAW,IAAX,EAAiB,KAAjB,EAAwB,OAAxB,EAAiC;AAC/B,OAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,MAAL,CAAY,MAAhC,EAAwC,CAAC,EAAzC,EAA6C;AAC7C,QAAM,IAAI,GAAG,KAAK,MAAL,CAAY,CAAZ,CAAb;;AACA,QAAM,IAAI,CAAC,KAAL,CAAW,OAAX,CAAmB,IAAnB,KAA4B,CAA5B,IACA,IAAI,CAAC,OAAL,IAAgB,CAAC,OAAO,CAAC,cAAR,CAAuB,IAAI,CAAC,OAA5B,CADjB,I;;;AAKF,IAAA,IAAM,CAAC,KAAP,CAAa,MAAb,GAAsB,IAAI,CAAC,MAA3B,KACG,IAAI,CAAC,KAAL,CAAW,UAAX,CAAsB,IAAI,CAAC,MAA3B,KAAsC,EAAtC,IAA4C,IAAI,CAAC,KAAL,CAAW,KAAX,CAAiB,IAAI,CAAC,MAAL,GAAc,CAA/B,KAAqC,KADpF,CALJ,EAOE;AAAE;AAAQ;;AACV,QAAI,IAAI,CAAC,QAAT,EAAmB;AACnB,UAAM,MAAM,GAAG,IAAI,CAAC,QAAL,CAAc,KAAd,CAAf;;AACE,UAAI,MAAM,KAAK,KAAf,EAAoB;AAAE;AAAQ;;AAC9B,MAAA,IAAI,CAAC,KAAL,GAAa,MAAb;AACD;;AACD,WAAO,IAAP;AACD;AACF,CAlBH,C;;;AAqBE,SAAA,CAAO,WAAP,GAAO,SAAA,WAAA,CAAY,MAAZ,EAAoB;AACzBA,MAAI,MAAM,GAAG,EAAbA;;AACA,WAAS,MAAT,CAAgB,IAAhB,EAAsB;AACpBA,QAAI,QAAQ,GAAG,IAAI,CAAC,QAAL,IAAiB,IAAjB,GAAwB,EAAxB,GAA6B,IAAI,CAAC,QAAjDA;AAAAA,QAA2D,CAAC,GAAG,CAA/DA;;AACF,WAAS,CAAC,GAAG,MAAM,CAAC,MAApB,EAA4B,CAAC,EAA7B,EAAiC;AAC/B,UAAM,IAAI,GAAG,MAAM,CAAC,CAAD,CAAnB;AAAA,UAAwB,YAAY,GAAG,IAAI,CAAC,QAAL,IAAiB,IAAjB,GAAwB,EAAxB,GAA6B,IAAI,CAAC,QAAzE;;AACE,UAAI,YAAY,GAAG,QAAnB,EAA2B;AAAE;AAAK;AACnC;;AACH,IAAA,MAAQ,CAAC,MAAT,CAAgB,CAAhB,EAAmB,CAAnB,EAAsB,IAAtB;AACC;;AAEH,MAAA,IAAA,GAAA,UAAA,IAAA,EAAiC;AAC7BA,QAAI,KAAK,GAAG,MAAM,CAAC,KAAP,CAAa,IAAb,EAAmB,IAAnB,CAAwB,QAApCA;;AACF,QAAM,KAAN,EAAW;AAAE,MAAA,KAAK,CAAC,OAAN,CAAa,UAAC,IAAD,EAAM;AAC9B,QAAA,MAAQ,CAAC,IAAI,GAAG,IAAI,CAAC,IAAD,CAAZ,CAAR;AACE,QAAA,IAAI,CAAC,IAAL,GAAY,IAAZ;AACD,OAHU;AAGT;GALN;;AAAE,OAAKA,IAAI,IAAT,IAAiB,MAAM,CAAC,KAAxB,EAA6B,IAAA,CAAA,IAAA,CAAA;;AAO/B,MAAA,MAAA,GAAA,UAAA,IAAA,EAAiC;AAC7BA,QAAIiB,OAAK,GAAG,MAAM,CAAC,KAAP,CAAaD,MAAb,EAAmB,IAAnB,CAAwB,QAApChB;;AACF,QAAMiB,OAAN,EAAW;AAAEA,MAAAA,OAAK,CAAC,OAANA,CAAa,UAAC,IAAD,EAAM;AAC9B,QAAA,MAAQ,CAAC,IAAI,GAAG,IAAI,CAAC,IAAD,CAAZ,CAAR;AACE,QAAA,IAAI,CAAC,IAAL,GAAYD,MAAZ;AACD,OAHUC;AAGT;GALN;;AAAE,OAAKjB,IAAIgB,MAAT,IAAiB,MAAM,CAAC,KAAxB,EAA6B,MAAA;;AAO7B,SAAO,MAAP;AACD,CA1BD,C;;;;;;AAgCA,SAAA,CAAO,UAAP,GAAO,SAAA,UAAA,CAAW,MAAX,EAAmB;AACxB,SAAO,MAAM,CAAC,MAAP,CAAc,SAAd,KACJ,MAAM,CAAC,MAAP,CAAc,SAAd,GAA0B,IAAI,SAAJ,CAAc,MAAd,EAAsB,SAAS,CAAC,WAAV,CAAsB,MAAtB,CAAtB,CADtB,CAAP;AAED,CAHD,C;;;AAOFf,IAAM,SAAS,GAAG;AAChB,EAAA,OAAO,EAAE,IADO;AACD,EAAA,OAAO,EAAE,IADR;AACc,EAAA,KAAK,EAAE,IADrB;AAC2B,EAAA,UAAU,EAAE,IADvC;AAC6C,EAAA,MAAM,EAAE,IADrD;AAEhB,EAAA,EAAE,EAAE,IAFY;AAEN,EAAA,GAAG,EAAE,IAFC;AAEK,EAAA,EAAE,EAAE,IAFT;AAEe,EAAA,QAAQ,EAAE,IAFzB;AAE+B,EAAA,UAAU,EAAE,IAF3C;AAEiD,EAAA,MAAM,EAAE,IAFzD;AAGhB,EAAA,MAAM,EAAE,IAHQ;AAGF,EAAA,IAAI,EAAE,IAHJ;AAGU,EAAA,EAAE,EAAE,IAHd;AAGoB,EAAA,EAAE,EAAE,IAHxB;AAG8B,EAAA,EAAE,EAAE,IAHlC;AAGwC,EAAA,EAAE,EAAE,IAH5C;AAGkD,EAAA,EAAE,EAAE,IAHtD;AAIhB,EAAA,EAAE,EAAE,IAJY;AAIN,EAAA,MAAM,EAAE,IAJF;AAIQ,EAAA,MAAM,EAAE,IAJhB;AAIsB,EAAA,EAAE,EAAE,IAJ1B;AAIgC,EAAA,EAAE,EAAE,IAJpC;AAI0C,EAAA,QAAQ,EAAE,IAJpD;AAI0D,EAAA,EAAE,EAAE,IAJ9D;AAKhB,EAAA,MAAM,EAAE,IALQ;AAKF,EAAA,CAAC,EAAE,IALD;AAKO,EAAA,GAAG,EAAE,IALZ;AAKkB,EAAA,OAAO,EAAE,IAL3B;AAKiC,EAAA,KAAK,EAAE,IALxC;AAK8C,EAAA,KAAK,EAAE,IALrD;AAK2D,EAAA,EAAE,EAAE;AAL/D,CAAlBA,C;;AASAA,IAAM,UAAU,GAAG;AACjB,EAAA,IAAI,EAAE,IADW;AACL,EAAA,QAAQ,EAAE,IADL;AACW,EAAA,MAAM,EAAE,IADnB;AACyB,EAAA,MAAM,EAAE,IADjC;AACuC,EAAA,KAAK,EAAE,IAD9C;AACoD,EAAA,KAAK,EAAE;AAD3D,CAAnBA,C;;AAKAA,IAAM,QAAQ,GAAG;AAAC,EAAA,EAAE,EAAE,IAAL;AAAW,EAAA,EAAE,EAAE;AAAf,CAAjBA,C;;AAGAA,IAAM,eAAe,GAAG,CAAxBA;AAAAA,IAA2B,oBAAoB,GAAG,CAAlDA;AAAAA,IAAqD,aAAa,GAAG,CAArEA;;AAEA,SAAS,YAAT,CAAsB,kBAAtB,EAA0C;AACxC,SAAO,CAAC,kBAAkB,GAAG,eAAH,GAAqB,CAAxC,KAA8C,kBAAkB,KAAK,MAAvB,GAAgC,oBAAhC,GAAuD,CAArG,CAAP;AACD;;AAED,IAAM,WAAW,GACf,SAAA,WAAA,CAAY,IAAZ,EAAkB,KAAlB,EAAyB,KAAzB,EAAgC,YAAhC,EAA8C,KAA9C,EAAqD,KAArD,EAA4D,OAA5D,EAAqE;AACnE,OAAK,IAAL,GAAY,IAAZ;AACA,OAAK,KAAL,GAAa,KAAb;AACA,OAAK,KAAL,GAAa,KAAb;AACA,OAAK,KAAL,GAAa,KAAK,KAAK,OAAO,GAAG,aAAV,GAA0B,IAA1B,GAAiC,IAAI,CAAC,YAA3C,CAAlB;AACA,OAAK,OAAL,GAAe,OAAf;AACA,OAAK,OAAL,GAAe,EAAf,CANmE,C;;AAQnE,OAAK,KAAL,GAAa,KAAb,CARmE,C;;AAUnE,OAAK,WAAL,GAAmB,IAAI,CAAC,IAAxB,CAVmE,C;;AAYnE,OAAK,YAAL,GAAoB,YAApB;AACD,CAdH;;AAgBA,WAAA,CAAA,SAAA,CAAE,YAAF,GAAE,SAAA,YAAA,CAAa,IAAb,EAAmB;AACjB,MAAI,CAAC,KAAK,KAAV,EAAiB;AACf,QAAI,CAAC,KAAK,IAAV,EAAc;AAAE,aAAO,EAAP;AAAS;;AACzBD,QAAI,IAAI,GAAG,KAAK,IAAL,CAAU,YAAV,CAAuB,UAAvB,CAAkC,QAAQ,CAAC,IAAT,CAAc,IAAd,CAAlC,CAAXA;;AACF,QAAM,IAAN,EAAY;AACR,WAAK,KAAL,GAAa,KAAK,IAAL,CAAU,YAAV,CAAuB,aAAvB,CAAqC,IAArC,CAAb;AACD,KAFH,MAES;AACP,UAAM,KAAK,GAAG,KAAK,IAAL,CAAU,YAAxB;AAAA,UAAsC,IAAtC;;AACA,UAAM,IAAI,GAAG,KAAK,CAAC,YAAN,CAAmB,IAAI,CAAC,IAAxB,CAAb,EAA4C;AACxC,aAAK,KAAL,GAAa,KAAb;AACA,eAAO,IAAP;AACD,OAHH,MAGS;AACL,eAAO,IAAP;AACD;AACF;AACF;;AACH,SAAS,KAAK,KAAL,CAAW,YAAX,CAAwB,IAAI,CAAC,IAA7B,CAAT;AACC,CAjBH;;AAmBA,WAAA,CAAA,SAAA,CAAE,MAAF,GAAE,SAAA,MAAA,CAAO,OAAP,EAAgB;AAChB,MAAM,EAAE,KAAK,OAAL,GAAe,eAAjB,CAAN,EAAyC;AAAA;AACrCA,QAAI,IAAI,GAAG,KAAK,OAAL,CAAa,KAAK,OAAL,CAAa,MAAb,GAAsB,CAAnC,CAAXA;AAAAA,QAAkD,CAAlDA;;AACA,QAAI,IAAI,IAAI,IAAI,CAAC,MAAb,KAAwB,CAAC,GAAG,oBAAoB,IAApB,CAAyB,IAAI,CAAC,IAA9B,CAA5B,CAAJ,EAAsE;AACpE,UAAI,IAAI,CAAC,IAAL,CAAU,MAAV,IAAoB,CAAC,CAAC,CAAD,CAAD,CAAK,MAA7B,EAAmC;AAAE,aAAK,OAAL,CAAa,GAAb;AAAkB,OAAvD,M;AACK,aAAK,OAAL,CAAa,KAAK,OAAL,CAAa,MAAb,GAAsB,CAAnC,IAAwC,IAAI,CAAC,QAAL,CAAc,IAAI,CAAC,IAAL,CAAU,KAAV,CAAgB,CAAhB,EAAmB,IAAI,CAAC,IAAL,CAAU,MAAV,GAAmB,CAAC,CAAC,CAAD,CAAD,CAAK,MAA3C,CAAd,CAAxC;AAAyG;AAC/G;AACF;;AACH,MAAM,OAAO,GAAG,QAAQ,CAAC,IAAT,CAAc,KAAK,OAAnB,CAAhB;;AACE,MAAI,CAAC,OAAD,IAAY,KAAK,KAArB,EACA;AAAE,IAAA,OAAO,GAAG,OAAO,CAAC,MAAR,CAAe,KAAK,KAAL,CAAW,UAAX,CAAsB,QAAQ,CAAC,KAA/B,EAAsC,IAAtC,CAAf,CAAV;AAAqE;;AACzE,SAAS,KAAK,IAAL,GAAY,KAAK,IAAL,CAAU,MAAV,CAAiB,KAAK,KAAtB,EAA6B,OAA7B,EAAsC,KAAK,KAA3C,CAAZ,GAAgE,OAAzE;AACC,CAZH;;AAcA,WAAA,CAAA,SAAA,CAAE,YAAF,GAAE,SAAA,YAAA,CAAa,QAAb,EAAuB;AACvB,OAAOA,IAAI,CAAC,GAAG,CAARA,EAAW,OAAO,GAAG,KAAK,YAAjC,EAA+C,CAAC,GAAG,OAAO,CAAC,MAA3D,EAAmE,CAAC,EAApE,EAAwE;AACpEA,QAAI,IAAI,GAAG,OAAO,CAAC,CAAD,CAAlBA;;AACF,QAAM,CAAC,KAAK,IAAL,GAAY,KAAK,IAAL,CAAU,cAAV,CAAyB,IAAI,CAAC,IAA9B,CAAZ,GAAkD,YAAY,CAAC,IAAI,CAAC,IAAN,EAAY,QAAZ,CAA/D,KACF,CAAG,IAAI,CAAC,OAAL,CAAa,KAAK,WAAlB,CADP,EACuC;AACrC,WAAO,WAAP,GAAqB,IAAI,CAAC,QAAL,CAAc,KAAK,WAAnB,CAArB;AACA,WAAO,YAAP,GAAsB,IAAI,CAAC,aAAL,CAAmB,KAAK,YAAxB,CAAtB;AACC;AACF;AACF,CATH;;AAYA,IAAM,YAAY,GAEhB,SAAA,YAAA,CAAY,MAAZ,EAAoB,OAApB,EAA6B,IAA7B,EAAmC;;AAEjC,OAAK,MAAL,GAAc,MAAd,CAFiC,C;;AAIjC,OAAK,OAAL,GAAe,OAAf;AACA,OAAK,MAAL,GAAc,IAAd;AACF,MAAM,OAAO,GAAG,OAAO,CAAC,OAAxB;AAAA,MAAiC,UAAjC;AACEA,MAAI,UAAU,GAAG,YAAY,CAAC,OAAO,CAAC,kBAAT,CAAZ,IAA4C,IAAI,GAAG,aAAH,GAAmB,CAAnE,CAAjBA;;AACA,MAAI,OAAJ,EACA;AAAE,IAAA,UAAU,GAAG,IAAI,WAAJ,CAAgB,OAAO,CAAC,IAAxB,EAA8B,OAAO,CAAC,KAAtC,EAA6C,IAAI,CAAC,IAAlD,EAAwD,IAAI,CAAC,IAA7D,EAAmE,IAAnE,EACc,OAAS,CAAC,QAAV,IAAsB,OAAO,CAAC,IAAR,CAAa,YADjD,EAC+D,UAD/D,CAAb;AACuF,GAFzF,MAGK,IAAI,IAAJ,EACL;AAAE,IAAA,UAAU,GAAG,IAAI,WAAJ,CAAgB,IAAhB,EAAsB,IAAtB,EAA4B,IAAI,CAAC,IAAjC,EAAuC,IAAI,CAAC,IAA5C,EAAkD,IAAlD,EAAwD,IAAxD,EAA8D,UAA9D,CAAb;AAAsF,GADnF,MAGL;AAAE,IAAA,UAAU,GAAG,IAAI,WAAJ,CAAgB,MAAM,CAAC,MAAP,CAAc,WAA9B,EAA2C,IAA3C,EAAiD,IAAI,CAAC,IAAtD,EAA4D,IAAI,CAAC,IAAjE,EAAuE,IAAvE,EAA6E,IAA7E,EAAmF,UAAnF,CAAb;AAA2G;;AAC7G,OAAK,KAAL,GAAa,CAAC,UAAD,CAAb,CAfiC,C;;AAiBjC,OAAK,IAAL,GAAY,CAAZ;AACA,OAAK,IAAL,GAAY,OAAO,CAAC,aAApB;AACA,OAAK,UAAL,GAAkB,KAAlB;CArBJ;;;;;;;kBAsBG;;;;AAEHG,oBAAAA,CAAM,GAANA,CAAM,GAANA,GAAM,YAAM;AACV,SAAS,KAAK,KAAL,CAAW,KAAK,IAAhB,CAAT;AACC,CAFHA,C;;;;;;AAQA,YAAA,CAAA,SAAA,CAAE,MAAF,GAAE,SAAA,MAAA,CAAO,GAAP,EAAY;AACV,MAAI,GAAG,CAAC,QAAJ,IAAgB,CAApB,EAAuB;AACrB,SAAK,WAAL,CAAiB,GAAjB;AACD,GAFD,MAEO,IAAI,GAAG,CAAC,QAAJ,IAAgB,CAApB,EAAuB;AAC9B,QAAM,KAAK,GAAG,GAAG,CAAC,YAAJ,CAAiB,OAAjB,CAAd;AACA,QAAM,KAAK,GAAG,KAAK,GAAG,KAAK,UAAL,CAAgB,WAAW,CAAC,KAAD,CAA3B,CAAH,GAAyC,IAA5D;AAAA,QAAkE,GAAG,GAAG,KAAK,GAA7E;;AACE,QAAI,KAAK,IAAI,IAAb,EAAiB;AAAE,WAAKH,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,EAAnC,EAAqC;AAAE,aAAK,cAAL,CAAoB,KAAK,CAAC,CAAD,CAAzB;AAA4B;AAAC;;AACvF,SAAK,UAAL,CAAgB,GAAhB;;AACA,QAAI,KAAK,IAAI,IAAb,EAAiB;AAAE,WAAKA,IAAIO,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAG,KAAK,CAAC,MAA1B,EAAkCA,GAAC,EAAnC,EAAqC;AAAE,aAAK,iBAAL,CAAuB,KAAK,CAACA,GAAD,CAA5B,EAAiC,GAAjC;AAAoC;AAAC;AAChG;AACF,CAVH;;AAYA,YAAA,CAAA,SAAA,CAAE,WAAF,GAAE,SAAA,WAAA,CAAY,GAAZ,EAAiB;AACfP,MAAI,KAAK,GAAG,GAAG,CAAC,SAAhBA;AACAA,MAAI,GAAG,GAAG,KAAK,GAAfA;;AACA,MAAI,CAAC,GAAG,CAAC,IAAJ,GAAW,GAAG,CAAC,IAAJ,CAAS,aAApB,GAAoC,GAAG,CAAC,OAAJ,CAAY,MAAZ,IAAsB,GAAG,CAAC,OAAJ,CAAY,CAAZ,EAAe,QAA1E,KAAuF,mBAAmB,IAAnB,CAAwB,KAAxB,CAA3F,EAA2H;AAC3H,QAAM,EAAE,GAAG,CAAC,OAAJ,GAAc,eAAhB,CAAN,EAAwC;AACtC,MAAA,KAAO,GAAG,KAAK,CAAC,OAAN,CAAc,mBAAd,EAAmC,GAAnC,CAAV,CADsC,C;;;;AAKpC,UAAI,mBAAmB,IAAnB,CAAwB,KAAxB,KAAkC,KAAK,IAAL,IAAa,KAAK,KAAL,CAAW,MAAX,GAAoB,CAAvE,EAA0E;AACxEA,YAAI,UAAU,GAAG,GAAG,CAAC,OAAJ,CAAY,GAAG,CAAC,OAAJ,CAAY,MAAZ,GAAqB,CAAjC,CAAjBA;AACAA,YAAI,aAAa,GAAG,GAAG,CAAC,eAAxBA;;AACF,YAAM,CAAC,UAAD,IACC,aAAa,IAAI,aAAa,CAAC,QAAd,IAA0B,IAD5C,IAEC,UAAU,CAAC,MAAX,IAAqB,mBAAmB,IAAnB,CAAwB,UAAU,CAAC,IAAnC,CAF5B,EAGE;AAAE,UAAA,KAAK,GAAG,KAAK,CAAC,KAAN,CAAY,CAAZ,CAAR;AAAsB;AACzB;AACF,KAbH,MAaS,IAAI,EAAE,GAAG,CAAC,OAAJ,GAAc,oBAAhB,CAAJ,EAA2C;AAClD,MAAA,KAAO,GAAG,KAAK,CAAC,OAAN,CAAc,WAAd,EAA2B,GAA3B,CAAV;AACC;;AACD,QAAI,KAAJ,EAAS;AAAE,WAAK,UAAL,CAAgB,KAAK,MAAL,CAAY,MAAZ,CAAmB,IAAnB,CAAwB,KAAxB,CAAhB;AAA+C;;AAC1D,SAAK,UAAL,CAAgB,GAAhB;AACD,GAnBD,MAmBO;AACL,SAAK,UAAL,CAAgB,GAAhB;AACD;AACF,CAzBH,C;;;;;AA8BA,YAAA,CAAA,SAAA,CAAE,UAAF,GAAE,SAAA,UAAA,CAAW,GAAX,EAAgB;AAChB,MAAM,IAAI,GAAG,GAAG,CAAC,QAAJ,CAAa,WAAb,EAAb;;AACE,MAAI,QAAQ,CAAC,cAAT,CAAwB,IAAxB,KAAiC,KAAK,MAAL,CAAY,cAAjD,EAA+D;AAAE,IAAA,aAAa,CAAC,GAAD,CAAb;AAAkB;;AACnFA,MAAI,IAAI,GAAI,KAAK,OAAL,CAAa,YAAb,IAA6B,KAAK,OAAL,CAAa,YAAb,CAA0B,GAA1B,CAA9B,IAAiE,KAAK,MAAL,CAAY,QAAZ,CAAqB,GAArB,EAA0B,IAA1B,CAA5EA;;AACA,MAAI,IAAI,GAAG,IAAI,CAAC,MAAR,GAAiB,UAAU,CAAC,cAAX,CAA0B,IAA1B,CAAzB,EAA0D;AACxD,SAAK,UAAL,CAAgB,GAAhB;AACD,GAFD,MAEO,IAAI,CAAC,IAAD,IAAS,IAAI,CAAC,IAAd,IAAsB,IAAI,CAAC,WAA/B,EAA4C;AACnD,QAAM,IAAI,IAAI,IAAI,CAAC,WAAnB,EAA8B;AAAE,WAAK,IAAL,GAAY,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,KAAK,IAAL,GAAY,CAAxB,CAAZ;AAAsC,KAAtE,MACO,IAAI,IAAI,IAAI,IAAI,CAAC,IAAL,CAAU,QAAtB,EAA8B;AAAE,MAAA,GAAG,GAAG,IAAI,CAAC,IAAX;AAAe;;AACpDA,QAAI,IAAJA;AAAAA,QAAU,GAAG,GAAG,KAAK,GAArBA;AAAAA,QAA0B,aAAa,GAAG,KAAK,UAA/CA;;AACA,QAAI,SAAS,CAAC,cAAV,CAAyB,IAAzB,CAAJ,EAAoC;AACpC,MAAA,IAAM,GAAG,IAAT;;AACA,UAAM,CAAC,GAAG,CAAC,IAAX,EAAe;AAAE,aAAK,UAAL,GAAkB,IAAlB;AAAsB;AACtC,KAHD,MAGO,IAAI,CAAC,GAAG,CAAC,UAAT,EAAqB;AAC1B,WAAK,YAAL,CAAkB,GAAlB;AACA;AACD;;AACD,SAAK,MAAL,CAAY,GAAZ;;AACF,QAAM,IAAN,EAAU;AAAE,WAAK,IAAL,CAAU,GAAV;AAAc;;AACxB,SAAK,UAAL,GAAkB,aAAlB;AACD,GAdM,MAcA;AACL,SAAK,gBAAL,CAAsB,GAAtB,EAA2B,IAA3B;AACD;AACF,CAvBH,C;;;AA0BA,YAAA,CAAA,SAAA,CAAE,YAAF,GAAE,SAAA,YAAA,CAAa,GAAb,EAAkB;AAChB,MAAI,GAAG,CAAC,QAAJ,IAAgB,IAAhB,IAAwB,KAAK,GAAL,CAAS,IAAjC,IAAyC,KAAK,GAAL,CAAS,IAAT,CAAc,aAA3D,EACA;AAAE,SAAK,WAAL,CAAiB,GAAG,CAAC,aAAJ,CAAkB,cAAlB,CAAiC,IAAjC,CAAjB;AAAwD;AAC3D,CAHH,C;;;;;AAQA,YAAA,CAAA,SAAA,CAAE,UAAF,GAAE,SAAA,UAAA,CAAW,MAAX,EAAmB;AACjBA,MAAI,KAAK,GAAG,IAAI,CAAC,IAAjBA;;AACA,OAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAAM,CAAC,MAA3B,EAAmC,CAAC,IAAI,CAAxC,EAA2C;AAC3C,QAAM,IAAI,GAAG,KAAK,MAAL,CAAY,UAAZ,CAAuB,MAAM,CAAC,CAAD,CAA7B,EAAkC,MAAM,CAAC,CAAC,GAAG,CAAL,CAAxC,EAAiD,IAAjD,CAAb;;AACE,QAAI,CAAC,IAAL,EAAS;AAAE;AAAQ;;AACnB,QAAI,IAAI,CAAC,MAAT,EAAe;AAAE,aAAO,IAAP;AAAW;;AAC9B,IAAA,KAAO,GAAG,KAAK,MAAL,CAAY,MAAZ,CAAmB,KAAnB,CAAyB,IAAI,CAAC,IAA9B,EAAoC,MAApC,CAA2C,IAAI,CAAC,KAAhD,EAAuD,QAAvD,CAAgE,KAAhE,CAAV;AACC;;AACD,SAAO,KAAP;AACD,CATH,C;;;;;;AAeA,YAAA,CAAA,SAAA,CAAE,gBAAF,GAAE,SAAA,gBAAA,CAAiB,GAAjB,EAAsB,IAAtB,EAA4B;;AAC5B,MAAM,IAAN,EAAY,QAAZ,EAAsB,QAAtB,EAAgC,IAAhC;;AACE,MAAI,IAAI,CAAC,IAAT,EAAe;AACb,IAAA,QAAQ,GAAG,KAAK,MAAL,CAAY,MAAZ,CAAmB,KAAnB,CAAyB,IAAI,CAAC,IAA9B,CAAX;;AACA,QAAI,CAAC,QAAQ,CAAC,MAAd,EAAsB;AACpB,MAAA,IAAI,GAAG,KAAK,KAAL,CAAW,QAAX,EAAqB,IAAI,CAAC,KAA1B,EAAiC,IAAI,CAAC,kBAAtC,CAAP;AACD,KAFD,MAEO,IAAI,CAAC,KAAK,UAAL,CAAgB,QAAQ,CAAC,MAAT,CAAgB,IAAI,CAAC,KAArB,CAAhB,CAAL,EAAmD;AACxD,WAAK,YAAL,CAAkB,GAAlB;AACD;AACF,GAPD,MAOO;AACL,IAAA,QAAQ,GAAG,KAAK,MAAL,CAAY,MAAZ,CAAmB,KAAnB,CAAyB,IAAI,CAAC,IAA9B,CAAX;AACF,IAAA,IAAM,GAAG,QAAQ,CAAC,MAAT,CAAgB,IAAI,CAAC,KAArB,CAAT;AACE,SAAK,cAAL,CAAoB,IAApB;AACD;;AACDA,MAAI,OAAO,GAAG,KAAK,GAAnBA;;AAEA,MAAI,QAAQ,IAAI,QAAQ,CAAC,MAAzB,EAAiC;AAC/B,SAAK,UAAL,CAAgB,GAAhB;AACD,GAFD,MAEO,IAAI,IAAI,CAAC,UAAT,EAAqB;AAC1B,SAAK,UAAL,CAAgB,GAAhB;AACF,IAAA,IAAM,CAAC,UAAP,CAAkB,GAAlB,EAAuB,KAAK,MAAL,CAAY,MAAnC,EAA2C,OAA3C,CAAkD,UAAC,IAAD,EAAM;AAAA,aAAGe,MAAI,CAAC,UAALA,CAAgB,IAAhBA,CAAH;AAAwB,KAAhF;AACC,GAHM,MAGA;AACLf,QAAI,UAAU,GAAG,IAAI,CAAC,cAAtBA;;AACA,QAAI,OAAO,UAAP,IAAqB,QAAzB,EAAiC;AAAE,MAAA,UAAU,GAAG,GAAG,CAAC,aAAJ,CAAkB,UAAlB,CAAb;AAA0C,KAA7E,MACK,IAAI,OAAO,UAAP,IAAqB,UAAzB,EAAmC;AAAE,MAAA,UAAU,GAAG,UAAU,CAAC,GAAD,CAAvB;AAA4B;;AACtE,QAAI,CAAC,UAAL,EAAe;AAAE,MAAA,UAAU,GAAG,GAAb;AAAgB;;AACnC,SAAO,UAAP,CAAkB,GAAlB,EAAuB,UAAvB,EAAmC,IAAnC;AACE,SAAK,MAAL,CAAY,UAAZ,EAAwB,IAAxB;AACD;;AACD,MAAI,IAAJ,EAAU;AAAE,SAAK,IAAL,CAAU,OAAV;AAAoB,SAAK,IAAL;AAAa;;AAC/C,MAAM,IAAN,EAAU;AAAE,SAAK,iBAAL,CAAuB,IAAvB,EAA6B,OAA7B;AAAqC;AAChD,CA/BH,C;;;;;;AAqCA,YAAA,CAAA,SAAA,CAAE,MAAF,GAAE,SAAA,MAAA,CAAO,MAAP,EAAe,IAAf,EAAqB,UAArB,EAAiC,QAAjC,EAA2C;AACzCA,MAAI,KAAK,GAAG,UAAU,IAAI,CAA1BA;;AACA,OAAKA,IAAI,GAAG,GAAG,UAAU,GAAG,MAAM,CAAC,UAAP,CAAkB,UAAlB,CAAH,GAAmC,MAAM,CAAC,UAA9DA,EACI,GAAG,GAAG,QAAQ,IAAI,IAAZ,GAAmB,IAAnB,GAA0B,MAAM,CAAC,UAAP,CAAkB,QAAlB,CADzC,EAEK,GAAG,IAAI,GAFZ,EAEiB,GAAG,GAAG,GAAG,CAAC,WAAV,EAAuB,EAAE,KAF1C,EAEiD;AAC/C,SAAK,WAAL,CAAiB,MAAjB,EAAyB,KAAzB;AACA,SAAK,MAAL,CAAY,GAAZ;;AACA,QAAI,IAAI,IAAI,SAAS,CAAC,cAAV,CAAyB,GAAG,CAAC,QAAJ,CAAa,WAAb,EAAzB,CAAZ,EACA;AAAE,WAAK,IAAL,CAAU,IAAV;AAAe;AAClB;;AACD,OAAK,WAAL,CAAiB,MAAjB,EAAyB,KAAzB;AACD,CAXH,C;;;;;AAgBA,YAAA,CAAA,SAAA,CAAE,SAAF,GAAE,SAAA,SAAA,CAAU,IAAV,EAAgB;AACdA,MAAI,KAAJA,EAAW,IAAXA;;AACA,OAAKA,IAAI,KAAK,GAAG,KAAK,IAAtB,EAA4B,KAAK,IAAI,CAArC,EAAwC,KAAK,EAA7C,EAAiD;AACjD,QAAM,EAAE,GAAG,KAAK,KAAL,CAAW,KAAX,CAAX;AACA,QAAM,KAAK,GAAG,EAAE,CAAC,YAAH,CAAgB,IAAhB,CAAd;;AACE,QAAI,KAAK,KAAK,CAAC,KAAD,IAAU,KAAK,CAAC,MAAN,GAAe,KAAK,CAAC,MAApC,CAAT,EAAsD;AACtD,MAAA,KAAO,GAAG,KAAV;AACA,MAAA,IAAM,GAAG,EAAT;;AACE,UAAI,CAAC,KAAK,CAAC,MAAX,EAAiB;AAAE;AAAK;AACzB;;AACD,QAAI,EAAE,CAAC,KAAP,EAAY;AAAE;AAAK;AACpB;;AACD,MAAI,CAAC,KAAL,EAAU;AAAE,WAAO,KAAP;AAAY;;AACxB,OAAK,IAAL,CAAU,IAAV;;AACA,OAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,EAAnC,EACA;AAAE,SAAK,UAAL,CAAgB,KAAK,CAAC,CAAD,CAArB,EAA0B,IAA1B,EAAgC,KAAhC;AAAsC;;AACxC,SAAO,IAAP;AACD,CAjBH,C;;;;AAqBA,YAAA,CAAA,SAAA,CAAE,UAAF,GAAE,SAAA,UAAA,CAAW,IAAX,EAAiB;AACf,MAAI,IAAI,CAAC,QAAL,IAAiB,KAAK,UAAtB,IAAoC,CAAC,KAAK,GAAL,CAAS,IAAlD,EAAwD;AACtDA,QAAI,KAAK,GAAG,KAAK,oBAAL,EAAZA;;AACF,QAAM,KAAN,EAAW;AAAE,WAAK,UAAL,CAAgB,KAAhB;AAAsB;AAClC;;AACD,MAAI,KAAK,SAAL,CAAe,IAAf,CAAJ,EAA0B;AAC1B,SAAO,UAAP;AACEA,QAAI,GAAG,GAAG,KAAK,GAAfA;AACA,IAAA,GAAG,CAAC,YAAJ,CAAiB,IAAI,CAAC,IAAtB;;AACA,QAAI,GAAG,CAAC,KAAR,EAAa;AAAE,MAAA,GAAG,CAAC,KAAJ,GAAY,GAAG,CAAC,KAAJ,CAAU,SAAV,CAAoB,IAAI,CAAC,IAAzB,CAAZ;AAA0C;;AACzDA,QAAI,KAAK,GAAG,GAAG,CAAC,WAAhBA;;AACA,SAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,IAAI,CAAC,KAAL,CAAW,MAA/B,EAAuC,CAAC,EAAxC,EACA;AAAE,UAAI,CAAC,GAAG,CAAC,IAAL,IAAa,GAAG,CAAC,IAAJ,CAAS,cAAT,CAAwB,IAAI,CAAC,KAAL,CAAW,CAAX,EAAc,IAAtC,CAAjB,EACA;AAAE,QAAA,KAAK,GAAG,IAAI,CAAC,KAAL,CAAW,CAAX,EAAc,QAAd,CAAuB,KAAvB,CAAR;AAAoC;AAAC;;AACzC,IAAA,GAAG,CAAC,OAAJ,CAAY,IAAZ,CAAiB,IAAI,CAAC,IAAL,CAAU,KAAV,CAAjB;AACA,WAAO,IAAP;AACD;;AACD,SAAO,KAAP;AACD,CAlBH,C;;;;;AAuBA,YAAA,CAAA,SAAA,CAAE,KAAF,GAAE,SAAA,KAAA,CAAM,IAAN,EAAY,KAAZ,EAAmB,UAAnB,EAA+B;AAC7BA,MAAI,EAAE,GAAG,KAAK,SAAL,CAAe,IAAI,CAAC,MAAL,CAAY,KAAZ,CAAf,CAATA;;AACA,MAAI,EAAJ,EAAM;AAAE,SAAK,UAAL,CAAgB,IAAhB,EAAsB,KAAtB,EAA6B,IAA7B,EAAmC,UAAnC;AAA8C;;AACtD,SAAO,EAAP;AACD,CAJH,C;;;AAOA,YAAA,CAAA,SAAA,CAAE,UAAF,GAAE,SAAA,UAAA,CAAW,IAAX,EAAiB,KAAjB,EAAwB,KAAxB,EAA+B,UAA/B,EAA2C;AAC3C,OAAO,UAAP;AACEA,MAAI,GAAG,GAAG,KAAK,GAAfA;AACA,EAAA,GAAG,CAAC,YAAJ,CAAiB,IAAjB;AACA,EAAA,GAAG,CAAC,KAAJ,GAAY,GAAG,CAAC,KAAJ,IAAa,GAAG,CAAC,KAAJ,CAAU,SAAV,CAAoB,IAApB,EAA0B,KAA1B,CAAzB;AACAA,MAAI,OAAO,GAAG,UAAU,IAAI,IAAd,GAAqB,GAAG,CAAC,OAAJ,GAAc,CAAC,aAApC,GAAoD,YAAY,CAAC,UAAD,CAA9EA;;AACA,MAAK,GAAG,CAAC,OAAJ,GAAc,aAAf,IAAiC,GAAG,CAAC,OAAJ,CAAY,MAAZ,IAAsB,CAA3D,EAA4D;AAAE,IAAA,OAAO,IAAI,aAAX;AAAwB;;AACxF,OAAO,KAAP,CAAa,IAAb,CAAkB,IAAI,WAAJ,CAAgB,IAAhB,EAAsB,KAAtB,EAA6B,GAAG,CAAC,WAAjC,EAA8C,GAAG,CAAC,YAAlD,EAAgE,KAAhE,EAAuE,IAAvE,EAA6E,OAA7E,CAAlB;AACA,OAAO,IAAP;AACC,CATH,C;;;;AAaA,YAAA,CAAA,SAAA,CAAE,UAAF,GAAE,SAAA,UAAA,CAAW,OAAX,EAAoB;AACpB,MAAM,CAAC,GAAG,KAAK,KAAL,CAAW,MAAX,GAAoB,CAA9B;;AACE,MAAI,CAAC,GAAG,KAAK,IAAb,EAAmB;AACjB,WAAO,CAAC,GAAG,KAAK,IAAhB,EAAsB,CAAC,EAAvB,EAAyB;AAAE,WAAK,KAAL,CAAW,CAAC,GAAG,CAAf,EAAkB,OAAlB,CAA0B,IAA1B,CAA+B,KAAK,KAAL,CAAW,CAAX,EAAc,MAAd,CAAqB,OAArB,CAA/B;AAA6D;;AAC1F,SAAO,KAAP,CAAa,MAAb,GAAsB,KAAK,IAAL,GAAY,CAAlC;AACC;AACF,CANH;;AAQA,YAAA,CAAA,SAAA,CAAE,MAAF,GAAE,SAAA,MAAA,GAAS;AACP,OAAK,IAAL,GAAY,CAAZ;AACA,OAAK,UAAL,CAAgB,KAAK,MAArB;AACA,SAAO,KAAK,KAAL,CAAW,CAAX,EAAc,MAAd,CAAqB,KAAK,MAAL,IAAe,KAAK,OAAL,CAAa,OAAjD,CAAP;AACD,CAJH;;AAMA,YAAA,CAAA,SAAA,CAAE,IAAF,GAAE,SAAA,IAAA,CAAK,EAAL,EAAS;AACT,OAAOA,IAAI,CAAC,GAAG,KAAK,IAApB,EAA0B,CAAC,IAAI,CAA/B,EAAkC,CAAC,EAAnC,EAAqC;AAAE,QAAI,KAAK,KAAL,CAAW,CAAX,KAAiB,EAArB,EAAyB;AAC5D,WAAK,IAAL,GAAY,CAAZ;AACA;;AACD;AACF,CALH;;AAOAG,oBAAAA,CAAM,UAANA,CAAM,GAANA,GAAM,YAAa;AACjB,OAAO,UAAP;AACEH,MAAI,GAAG,GAAG,CAAVA;;AACA,OAAKA,IAAI,CAAC,GAAG,KAAK,IAAlB,EAAwB,CAAC,IAAI,CAA7B,EAAgC,CAAC,EAAjC,EAAqC;AACrC,QAAM,OAAO,GAAG,KAAK,KAAL,CAAW,CAAX,EAAc,OAA9B;;AACE,SAAKA,IAAI,CAAC,GAAG,OAAO,CAAC,MAAR,GAAiB,CAA9B,EAAiC,CAAC,IAAI,CAAtC,EAAyC,CAAC,EAA1C,EACA;AAAE,MAAA,GAAG,IAAI,OAAO,CAAC,CAAD,CAAP,CAAW,QAAlB;AAA0B;;AAC5B,QAAI,CAAJ,EAAK;AAAE,MAAA,GAAG;AAAE;AACb;;AACD,SAAO,GAAP;AACD,CAVHG;;AAYA,YAAA,CAAA,SAAA,CAAE,WAAF,GAAE,SAAA,WAAA,CAAY,MAAZ,EAAoB,MAApB,EAA4B;AAC5B,MAAM,KAAK,IAAX,EAAe;AAAE,SAAKH,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,IAAL,CAAU,MAA9B,EAAsC,CAAC,EAAvC,EAA2C;AAC1D,UAAM,KAAK,IAAL,CAAU,CAAV,EAAa,IAAb,IAAqB,MAArB,IAA+B,KAAK,IAAL,CAAU,CAAV,EAAa,MAAb,IAAuB,MAA5D,EACE;AAAE,aAAK,IAAL,CAAU,CAAV,EAAa,GAAb,GAAmB,KAAK,UAAxB;AAAkC;;AACrC;AACF,CALH;;AAOA,YAAA,CAAA,SAAA,CAAE,UAAF,GAAE,SAAA,UAAA,CAAW,MAAX,EAAmB;AACnB,MAAM,KAAK,IAAX,EAAe;AAAE,SAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,IAAL,CAAU,MAA9B,EAAsC,CAAC,EAAvC,EAA2C;AACxD,UAAI,KAAK,IAAL,CAAU,CAAV,EAAa,GAAb,IAAoB,IAApB,IAA4B,MAAM,CAAC,QAAP,IAAmB,CAA/C,IAAoD,MAAM,CAAC,QAAP,CAAgB,KAAK,IAAL,CAAU,CAAV,EAAa,IAA7B,CAAxD,EACA;AAAE,aAAK,IAAL,CAAU,CAAV,EAAa,GAAb,GAAmB,KAAK,UAAxB;AAAkC;;AACrC;AACF,CALH;;AAOA,YAAA,CAAA,SAAA,CAAE,UAAF,GAAE,SAAA,UAAA,CAAW,MAAX,EAAmB,OAAnB,EAA4B,MAA5B,EAAoC;AACpC,MAAM,MAAM,IAAI,OAAV,IAAqB,KAAK,IAAhC,EAAoC;AAAE,SAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,IAAL,CAAU,MAA9B,EAAsC,CAAC,EAAvC,EAA2C;AAC7E,UAAI,KAAK,IAAL,CAAU,CAAV,EAAa,GAAb,IAAoB,IAApB,IAA4B,MAAM,CAAC,QAAP,IAAmB,CAA/C,IAAoD,MAAM,CAAC,QAAP,CAAgB,KAAK,IAAL,CAAU,CAAV,EAAa,IAA7B,CAAxD,EAA4F;AAC1FA,YAAI,GAAG,GAAG,OAAO,CAAC,uBAAR,CAAgC,KAAK,IAAL,CAAU,CAAV,EAAa,IAA7C,CAAVA;;AACF,YAAM,GAAG,IAAI,MAAM,GAAG,CAAH,GAAO,CAAjB,CAAT,EACE;AAAE,eAAK,IAAL,CAAU,CAAV,EAAa,GAAb,GAAmB,KAAK,UAAxB;AAAkC;AACrC;;AACF;AACF,CARH;;AAUA,YAAA,CAAA,SAAA,CAAE,UAAF,GAAE,SAAA,UAAA,CAAW,QAAX,EAAqB;AACrB,MAAM,KAAK,IAAX,EAAe;AAAE,SAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,IAAL,CAAU,MAA9B,EAAsC,CAAC,EAAvC,EAA2C;AAC1D,UAAM,KAAK,IAAL,CAAU,CAAV,EAAa,IAAb,IAAqB,QAA3B,EACE;AAAE,aAAK,IAAL,CAAU,CAAV,EAAa,GAAb,GAAmB,KAAK,UAAL,IAAmB,QAAQ,CAAC,SAAT,CAAmB,MAAnB,GAA4B,KAAK,IAAL,CAAU,CAAV,EAAa,MAA5D,CAAnB;AAAsF;;AACzF;AACF,CALH,C;;;;;AAUA,YAAA,CAAA,SAAA,CAAE,cAAF,GAAE,SAAA,cAAA,CAAe,OAAf,EAAwB;;;AACxB,MAAM,OAAO,CAAC,OAAR,CAAgB,GAAhB,IAAuB,CAAC,CAA9B,EACE;AAAE,WAAO,OAAO,CAAC,KAAR,CAAc,UAAd,EAA0B,IAA1B,CAA+B,KAAK,cAApC,EAAoD,IAApD,CAAP;AAAgE;;AAEpE,MAAM,KAAK,GAAG,OAAO,CAAC,KAAR,CAAc,GAAd,CAAd;AACA,MAAM,MAAM,GAAG,KAAK,OAAL,CAAa,OAA5B;AACA,MAAM,OAAO,GAAG,CAAC,KAAK,MAAN,KAAiB,CAAC,MAAD,IAAW,MAAM,CAAC,MAAP,CAAc,IAAd,IAAsB,KAAK,KAAL,CAAW,CAAX,EAAc,IAAhE,CAAhB;AACA,MAAM,QAAQ,GAAG,EAAE,MAAM,GAAG,MAAM,CAAC,KAAP,GAAe,CAAlB,GAAsB,CAA9B,KAAoC,OAAO,GAAG,CAAH,GAAO,CAAlD,CAAjB;;AACA,MAAM,KAAK,GAAA,UAAI,CAAJ,EAAO,KAAP,EAAc;AACrB,WAAO,CAAC,IAAI,CAAZ,EAAe,CAAC,EAAhB,EAAoB;AAClBA,UAAI,IAAI,GAAG,KAAK,CAAC,CAAD,CAAhBA;;AACA,UAAI,IAAI,IAAI,EAAZ,EAAgB;AACd,YAAI,CAAC,IAAI,KAAK,CAAC,MAAN,GAAe,CAApB,IAAyB,CAAC,IAAI,CAAlC,EAAmC;AAAE;AAAQ;;AAC7C,eAAO,KAAK,IAAI,QAAhB,EAA0B,KAAK,EAA/B,EACA;AAAE,cAAI,KAAK,CAAC,CAAC,GAAG,CAAL,EAAQ,KAAR,CAAT,EAAuB;AAAE,mBAAO,IAAP;AAAO;AAAI;;AACtC,eAAO,KAAP;AACD,OALD,MAKO;AACP,YAAM,IAAI,GAAG,KAAK,GAAG,CAAR,IAAc,KAAK,IAAI,CAAT,IAAc,OAA5B,GAAuCe,MAAI,CAAC,KAALA,CAAW,KAAXA,EAAkB,IAAzD,GACL,MAAM,IAAI,KAAK,IAAI,QAAnB,GAA8B,MAAM,CAAC,IAAP,CAAY,KAAK,GAAG,QAApB,EAA8B,IAA5D,GACA,IAFR;;AAGA,YAAM,CAAC,IAAD,IAAU,IAAI,CAAC,IAAL,IAAa,IAAb,IAAqB,IAAI,CAAC,MAAL,CAAY,OAAZ,CAAoB,IAApB,KAA6B,CAAC,CAAnE,EACE;AAAE,iBAAO,KAAP;AAAY;;AACd,QAAA,KAAK;AACN;AACF;;AACD,WAAO,IAAP;AACD,GAlBH;;AAmBE,SAAO,KAAK,CAAC,KAAK,CAAC,MAAN,GAAe,CAAhB,EAAmB,KAAK,IAAxB,CAAZ;AACD,CA5BH;;AA8BA,YAAA,CAAA,SAAA,CAAE,oBAAF,GAAE,SAAA,oBAAA,GAAuB;AACvB,MAAM,QAAQ,GAAG,KAAK,OAAL,CAAa,OAA9B;;AACE,MAAI,QAAJ,EAAY;AAAE,SAAKf,IAAI,CAAC,GAAG,QAAQ,CAAC,KAAtB,EAA6B,CAAC,IAAI,CAAlC,EAAqC,CAAC,EAAtC,EAA0C;AACxD,UAAM,KAAK,GAAG,QAAQ,CAAC,IAAT,CAAc,CAAd,EAAiB,cAAjB,CAAgC,QAAQ,CAAC,UAAT,CAAoB,CAApB,CAAhC,EAAwD,WAAtE;;AACE,UAAI,KAAK,IAAI,KAAK,CAAC,WAAf,IAA8B,KAAK,CAAC,YAAxC,EAAoD;AAAE,eAAO,KAAP;AAAY;;AACnE;;AACD,OAAKA,IAAI,IAAT,IAAiB,KAAK,MAAL,CAAY,MAAZ,CAAmB,KAApC,EAA2C;AACzCA,QAAI,IAAI,GAAG,KAAK,MAAL,CAAY,MAAZ,CAAmB,KAAnB,CAAyB,IAAzB,CAAXA;;AACF,QAAM,IAAI,CAAC,WAAL,IAAoB,IAAI,CAAC,YAA/B,EAA2C;AAAE,aAAO,IAAP;AAAW;AACvD;AACF,CAVH;;AAYA,YAAA,CAAA,SAAA,CAAE,cAAF,GAAE,SAAA,cAAA,CAAe,IAAf,EAAqB;AACnB,OAAK,GAAL,CAAS,YAAT,GAAwB,IAAI,CAAC,QAAL,CAAc,KAAK,GAAL,CAAS,YAAvB,CAAxB;AACD,CAFH;;AAIA,YAAA,CAAA,SAAA,CAAE,iBAAF,GAAE,SAAA,iBAAA,CAAkB,IAAlB,EAAwB,IAAxB,EAA8B;AAC5B,OAAKA,IAAI,KAAK,GAAG,KAAK,IAAtB,EAA4B,KAAK,IAAI,CAArC,EAAwC,KAAK,EAA7C,EAAiD;AACjD,QAAM,KAAK,GAAG,KAAK,KAAL,CAAW,KAAX,CAAd;AACA,QAAM,KAAK,GAAG,KAAK,CAAC,YAAN,CAAmB,WAAnB,CAA+B,IAA/B,CAAd;;AACE,QAAI,KAAK,GAAG,CAAC,CAAb,EAAc;AAAE,MAAA,KAAK,CAAC,YAAN,GAAqB,IAAI,CAAC,aAAL,CAAmB,KAAK,CAAC,YAAzB,CAArB;AAA2D,KAA3E,M;AACK,MAAA,KAAK,CAAC,WAAN,GAAoB,IAAI,CAAC,aAAL,CAAmB,KAAK,CAAC,WAAzB,CAApB;AAAyD;;AAC9D,QAAI,KAAK,IAAI,IAAb,EAAiB;AAAE;AAAK;AACzB;AACF,CARH;;gDASC,oB;;;;AAKD,SAAS,aAAT,CAAuB,GAAvB,EAA4B;AAC1B,OAAKA,IAAI,KAAK,GAAG,GAAG,CAAC,UAAhBA,EAA4B,QAAQ,GAAG,IAA5C,EAAkD,KAAlD,EAAyD,KAAK,GAAG,KAAK,CAAC,WAAvE,EAAoF;AAClFA,QAAI,IAAI,GAAG,KAAK,CAAC,QAAN,IAAkB,CAAlB,GAAsB,KAAK,CAAC,QAAN,CAAe,WAAf,EAAtB,GAAqD,IAAhEA;;AACA,QAAI,IAAI,IAAI,QAAQ,CAAC,cAAT,CAAwB,IAAxB,CAAR,IAAyC,QAA7C,EAAuD;AACrD,MAAA,QAAQ,CAAC,WAAT,CAAqB,KAArB;AACA,MAAA,KAAK,GAAG,QAAR;AACD,KAHD,MAGO,IAAI,IAAI,IAAI,IAAZ,EAAkB;AACvB,MAAA,QAAQ,GAAG,KAAX;AACD,KAFM,MAEA,IAAI,IAAJ,EAAU;AACf,MAAA,QAAQ,GAAG,IAAX;AACD;AACF;AACF,C;;;AAGD,SAAS,OAAT,CAAiB,GAAjB,EAAsB,QAAtB,EAAgC;AAC9B,SAAO,CAAC,GAAG,CAAC,OAAJ,IAAe,GAAG,CAAC,iBAAnB,IAAwC,GAAG,CAAC,qBAA5C,IAAqE,GAAG,CAAC,kBAA1E,EAA8F,IAA9F,CAAmG,GAAnG,EAAwG,QAAxG,CAAP;AACD,C;;;;AAID,SAAS,WAAT,CAAqB,KAArB,EAA4B;AAC1BA,MAAI,EAAE,GAAG,4BAATA;AAAAA,MAAuC,CAAvCA;AAAAA,MAA0C,MAAM,GAAG,EAAnDA;;AACA,SAAO,CAAC,GAAG,EAAE,CAAC,IAAH,CAAQ,KAAR,CAAX,EAAyB;AAAE,IAAA,MAAM,CAAC,IAAP,CAAY,CAAC,CAAC,CAAD,CAAb,EAAkB,CAAC,CAAC,CAAD,CAAD,CAAK,IAAL,EAAlB;AAA8B;;AACzD,SAAO,MAAP;AACD;;AAED,SAAS,IAAT,CAAc,GAAd,EAAmB;AACjBA,MAAI,IAAI,GAAG,EAAXA;;AACA,OAAKA,IAAI,IAAT,IAAiB,GAAjB,EAAoB;AAAE,IAAA,IAAI,CAAC,IAAD,CAAJ,GAAa,GAAG,CAAC,IAAD,CAAhB;AAAsB;;AAC5C,SAAO,IAAP;AACD,C;;;;;AAKD,SAAS,YAAT,CAAsB,QAAtB,EAAgC,QAAhC,EAA0C;AACxCA,MAAI,KAAK,GAAG,QAAQ,CAAC,MAAT,CAAgB,KAA5BA;;6BACwB;AACtBA,QAAI,MAAM,GAAG,KAAK,CAAC,IAAD,CAAlBA;;AACA,QAAI,CAAC,MAAM,CAAC,cAAP,CAAsB,QAAtB,CAAL,EAAoC;AAAE;AAAQ;;AAC9CA,QAAI,IAAI,GAAG,EAAXA;AAAAA,QAAe,IAAI,GAAA,UAAG,KAAH,EAAS;AAC1B,MAAA,IAAI,CAAC,IAAL,CAAU,KAAV;;AACA,WAAKA,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,SAA1B,EAAqC,CAAC,EAAtC,EAA0C;AACxC,YAAA,GAAgB,GAAG,KAAK,CAAC,IAAN,CAAW,CAAX,CAAnB;AAAK,YAAA,IAAA,GAAA,GAAA,CAAA,IAAA;AAAM,YAAA,IAAA,GAAA,GAAA,CAAA,IAAA;;AACX,YAAI,IAAI,IAAI,QAAZ,EAAoB;AAAE,iBAAO,IAAP;AAAW;;AACjC,YAAI,IAAI,CAAC,OAAL,CAAa,IAAb,IAAqB,CAArB,IAA0B,IAAI,CAAC,IAAD,CAAlC,EAAwC;AAAE,iBAAO,IAAP;AAAW;AACtD;AACF,KAPDA;;AAQA,QAAI,IAAI,CAAC,MAAM,CAAC,YAAR,CAAR,EAA6B;AAAE,aAAA;AAAA,QAAA,CAAA,EAAO;AAAP,OAAA;AAAW;;;AAX5C,OAAKA,IAAI,IAAT,IAAiB,KAAjB,EAAsB;;;AAYrB;AACF,C,CCjwBD;;;;;;;;;;;;;;;;;;;;;AAoBA,IAAa,aAAa,GASxB,SAAA,aAAA,CAAY,KAAZ,EAAmB,KAAnB,EAA0B;;;AAGxB,OAAK,KAAL,GAAa,KAAK,IAAI,EAAtB,CAHwB,C;;;AAMxB,OAAK,KAAL,GAAa,KAAK,IAAI,EAAtB;AACD,CAhBH,C;;;;;;;AAuBA,aAAA,CAAA,SAAA,CAAE,iBAAF,GAAE,SAAA,iBAAA,CAAkB,QAAlB,EAA4B,OAA5B,EAA0C,MAA1C,EAAkD;;iCAAf,GAAG,E;;AACpC,MAAI,CAAC,MAAL,EAAW;AAAE,IAAA,MAAM,GAAG,GAAG,CAAC,OAAD,CAAH,CAAa,sBAAb,EAAT;AAA8C;;AAE7D,MAAM,GAAG,GAAG,MAAZ;AAAA,MAAoB,MAAM,GAAG,IAA7B;AACE,EAAA,QAAQ,CAAC,OAAT,CAAgB,UAAC,IAAD,EAAM;AACtB,QAAM,MAAM,IAAI,IAAI,CAAC,KAAL,CAAW,MAA3B,EAAmC;AAC/B,UAAI,CAAC,MAAL,EAAW;AAAE,QAAA,MAAM,GAAG,EAAT;AAAW;;AAC1B,UAAM,IAAI,GAAG,CAAb;AAAA,UAAgB,QAAQ,GAAG,CAA3B;;AACE,aAAO,IAAI,GAAG,MAAM,CAAC,MAAd,IAAwB,QAAQ,GAAG,IAAI,CAAC,KAAL,CAAW,MAArD,EAA6D;AAC7D,YAAM,IAAI,GAAG,IAAI,CAAC,KAAL,CAAW,QAAX,CAAb;;AACE,YAAI,CAACe,MAAI,CAAC,KAALA,CAAW,IAAI,CAAC,IAAL,CAAU,IAArBA,CAAL,EAAiC;AAAE,UAAA,QAAQ;AAAI;AAAU;;AAC3D,YAAM,CAAC,IAAI,CAAC,EAAL,CAAQ,MAAM,CAAC,IAAD,CAAd,CAAD,IAA0B,IAAI,CAAC,IAAL,CAAU,IAAV,CAAe,QAAf,KAA4B,KAA5D,EAAiE;AAAE;AAAK;;AACtE,QAAA,IAAI,IAAI,CAAR;AAAW,QAAA,QAAQ;AACpB;;AACD,aAAO,IAAI,GAAG,MAAM,CAAC,MAArB,EAA6B;AAC3B,QAAA,GAAG,GAAG,MAAM,CAAC,GAAP,EAAN;AACF,QAAA,MAAQ,CAAC,GAAT;AACC;;AACH,aAAS,QAAQ,GAAG,IAAI,CAAC,KAAL,CAAW,MAA/B,EAAuC;AACrC,YAAM,GAAG,GAAG,IAAI,CAAC,KAAL,CAAW,QAAQ,EAAnB,CAAZ;AACEf,YAAI,OAAO,GAAGe,MAAI,CAAC,aAALA,CAAmB,GAAnBA,EAAwB,IAAI,CAAC,QAA7BA,EAAuC,OAAvCA,CAAdf;;AACF,YAAM,OAAN,EAAe;AACX,UAAA,MAAM,CAAC,IAAP,CAAY,GAAZ,EAAiB,GAAjB;AACA,UAAA,GAAG,CAAC,WAAJ,CAAgB,OAAO,CAAC,GAAxB;AACF,UAAA,GAAK,GAAG,OAAO,CAAC,UAAR,IAAsB,OAAO,CAAC,GAAtC;AACC;AACF;AACF;;AACD,IAAA,GAAG,CAAC,WAAJ,CAAgBe,MAAI,CAAC,aAALA,CAAmB,IAAnBA,EAAyB,OAAzBA,CAAhB;AACD,GAzBD;AA2BA,SAAO,MAAP;AACD,CAhCH,C;;;;;;;;AAwCA,aAAA,CAAA,SAAA,CAAE,aAAF,GAAE,SAAA,aAAA,CAAc,IAAd,EAAoB,OAApB,EAAkC;iCAAP,GAAG,E;AAC9B,MAAA,GAAuB,GACnB,aAAe,CAAC,UAAhB,CAA2B,GAAG,CAAC,OAAD,CAA9B,EAAyC,KAAK,KAAL,CAAW,IAAI,CAAC,IAAL,CAAU,IAArB,EAA2B,IAA3B,CAAzC,CADJ;AAAO,MAAA,GAAA,GAAA,GAAA,CAAA,GAAA;AAAK,MAAA,UAAA,GAAA,GAAA,CAAA,UAAA;;AAEZ,MAAM,UAAN,EAAkB;AAChB,QAAM,IAAI,CAAC,MAAX,EACE;AAAE,YAAM,IAAI,UAAJ,CAAe,8CAAf,CAAN;AAAoE;;AACxE,QAAM,OAAO,CAAC,SAAd,EACE;AAAE,MAAA,OAAO,CAAC,SAAR,CAAkB,IAAlB,EAAwB,UAAxB,EAAoC,OAApC;AAA4C,KADhD,MAGE;AAAE,WAAK,iBAAL,CAAuB,IAAI,CAAC,OAA5B,EAAqC,OAArC,EAA8C,UAA9C;AAAyD;AAC5D;;AACD,SAAO,GAAP;AACD,CAZH;;AAcA,aAAA,CAAA,SAAA,CAAE,qBAAF,GAAE,SAAA,qBAAA,CAAsB,IAAtB,EAA4B,OAA5B,EAA0C;iCAAP,GAAG,E;AACtC,MAAM,GAAG,GAAG,KAAK,aAAL,CAAmB,IAAnB,EAAyB,OAAzB,CAAZ;;AACE,OAAKf,IAAI,CAAC,GAAG,IAAI,CAAC,KAAL,CAAW,MAAX,GAAoB,CAAjC,EAAoC,CAAC,IAAI,CAAzC,EAA4C,CAAC,EAA7C,EAAiD;AACjD,QAAM,IAAI,GAAG,KAAK,aAAL,CAAmB,IAAI,CAAC,KAAL,CAAW,CAAX,CAAnB,EAAkC,IAAI,CAAC,QAAvC,EAAiD,OAAjD,CAAb;;AACA,QAAM,IAAN,EAAY;AACP,OAAC,IAAI,CAAC,UAAL,IAAmB,IAAI,CAAC,GAAzB,EAA8B,WAA9B,CAA0C,GAA1C;AACD,MAAA,GAAG,GAAG,IAAI,CAAC,GAAX;AACD;AACF;;AACD,SAAO,GAAP;AACD,CAVH;;AAYA,aAAA,CAAA,SAAA,CAAE,aAAF,GAAE,SAAA,aAAA,CAAc,IAAd,EAAoB,MAApB,EAA4B,OAA5B,EAA0C;iCAAP,GAAG,E;AACpCA,MAAI,KAAK,GAAG,KAAK,KAAL,CAAW,IAAI,CAAC,IAAL,CAAU,IAArB,CAAZA;AACA,SAAO,KAAK,IAAI,aAAa,CAAC,UAAd,CAAyB,GAAG,CAAC,OAAD,CAA5B,EAAuC,KAAK,CAAC,IAAD,EAAO,MAAP,CAA5C,CAAhB;AACD,CAHH,C;;;;;;AASA,aAAA,CAAS,UAAT,GAAS,SAAA,UAAA,CAAW,GAAX,EAAgB,SAAhB,EAA2B,KAA3B,EAAyC;6BAAT,GAAG,I;;AACxC,MAAI,OAAO,SAAP,IAAoB,QAAxB,EACA;AAAE,WAAO;AAAC,MAAA,GAAG,EAAE,GAAG,CAAC,cAAJ,CAAmB,SAAnB;AAAN,KAAP;AAA2C;;AAC7C,MAAI,SAAS,CAAC,QAAV,IAAsB,IAA1B,EACA;AAAE,WAAO;AAAC,MAAA,GAAG,EAAE;AAAN,KAAP;AAAuB;;AACzBA,MAAI,OAAO,GAAG,SAAS,CAAC,CAAD,CAAvBA;AAAAA,MAA4B,KAAK,GAAG,OAAO,CAAC,OAAR,CAAgB,GAAhB,CAApCA;;AACA,MAAI,KAAK,GAAG,CAAZ,EAAe;AACf,IAAA,KAAO,GAAG,OAAO,CAAC,KAAR,CAAc,CAAd,EAAiB,KAAjB,CAAV;AACA,IAAA,OAAS,GAAG,OAAO,CAAC,KAAR,CAAc,KAAK,GAAG,CAAtB,CAAZ;AACC;;AACH,MAAM,UAAU,GAAG,IAAnB;AAAA,MAAyB,GAAG,GAAG,KAAK,GAAG,GAAG,CAAC,eAAJ,CAAoB,KAApB,EAA2B,OAA3B,CAAH,GAAyC,GAAG,CAAC,aAAJ,CAAkB,OAAlB,CAA7E;AACA,MAAM,KAAK,GAAG,SAAS,CAAC,CAAD,CAAvB;AAAA,MAA4B,KAAK,GAAG,CAApC;;AACA,MAAM,KAAK,IAAI,OAAO,KAAP,IAAgB,QAAzB,IAAqC,KAAK,CAAC,QAAN,IAAkB,IAAvD,IAA+D,CAAC,KAAK,CAAC,OAAN,CAAc,KAAd,CAAtE,EAA4F;AAC1F,IAAA,KAAO,GAAG,CAAV;;AACE,SAAKA,IAAI,IAAT,IAAiB,KAAjB,EAAsB;AAAE,UAAI,KAAK,CAAC,IAAD,CAAL,IAAe,IAAnB,EAAyB;AACjD,YAAMkB,OAAK,GAAG,IAAI,CAAC,OAAL,CAAa,GAAb,CAAd;;AACE,YAAIA,OAAK,GAAG,CAAZ,EAAa;AAAE,UAAA,GAAG,CAAC,cAAJ,CAAmB,IAAI,CAAC,KAAL,CAAW,CAAX,EAAcA,OAAd,CAAnB,EAAyC,IAAI,CAAC,KAAL,CAAWA,OAAK,GAAG,CAAnB,CAAzC,EAAgE,KAAK,CAAC,IAAD,CAArE;AAA4E,SAA3F,M;AACK,UAAA,GAAG,CAAC,YAAJ,CAAiB,IAAjB,EAAuB,KAAK,CAAC,IAAD,CAA5B;AAAmC;;AACzC;AACF;;AACD,OAAKlB,IAAI,CAAC,GAAG,KAAb,EAAoB,CAAC,GAAG,SAAS,CAAC,MAAlC,EAA0C,CAAC,EAA3C,EAA+C;AAC7CA,QAAI,KAAK,GAAG,SAAS,CAAC,CAAD,CAArBA;;AACA,QAAI,KAAK,KAAK,CAAd,EAAiB;AACjB,UAAM,CAAC,GAAG,SAAS,CAAC,MAAV,GAAmB,CAAvB,IAA4B,CAAC,GAAG,KAAtC,EACE;AAAE,cAAM,IAAI,UAAJ,CAAe,wDAAf,CAAN;AAA8E;;AAChF,aAAO;AAAA,QAAA,GAAA,EAAC,GAAD;AAAM,QAAA,UAAU,EAAE;AAAlB,OAAP;AACD,KAJD,MAIO;AACP,UAAA,GAA4C,GAAG,aAAa,CAAC,UAAd,CAAyB,GAAzB,EAA8B,KAA9B,EAAqC,KAArC,CAA/C;AAAY,UAAA,KAAA,GAAA,GAAA,CAAA,GAAA;AAAmB,UAAA,YAAA,GAAA,GAAA,CAAA,UAAA;AAC7B,MAAA,GAAG,CAAC,WAAJ,CAAgB,KAAhB;;AACF,UAAM,YAAN,EAAoB;AAClB,YAAM,UAAN,EAAgB;AAAE,gBAAM,IAAI,UAAJ,CAAe,wBAAf,CAAN;AAA8C;;AAChE,QAAA,UAAY,GAAG,YAAf;AACC;AACF;AACF;;AACD,SAAO;AAAA,IAAA,GAAA,EAAC,GAAD;AAAI,IAAA,UAAA,EAAE;AAAN,GAAP;AACD,CApCH,C;;;;;AAyCE,aAAA,CAAO,UAAP,GAAO,SAAA,UAAA,CAAW,MAAX,EAAmB;AACxB,SAAO,MAAM,CAAC,MAAP,CAAc,aAAd,KACJ,MAAM,CAAC,MAAP,CAAc,aAAd,GAA8B,IAAI,aAAJ,CAAkB,KAAK,eAAL,CAAqB,MAArB,CAAlB,EAAgD,KAAK,eAAL,CAAqB,MAArB,CAAhD,CAD1B,CAAP;AAED,CAHD,C;;;;;AAQA,aAAA,CAAO,eAAP,GAAO,SAAA,eAAA,CAAgB,MAAhB,EAAwB;AAC/B,MAAM,MAAM,GAAG,WAAW,CAAC,MAAM,CAAC,KAAR,CAA1B;;AACE,MAAI,CAAC,MAAM,CAAC,IAAZ,EAAgB;AAAE,IAAA,MAAM,CAAC,IAAP,GAAW,UAAG,IAAH,EAAQ;AAAA,aAAG,IAAI,CAAC,IAAR;AAAQ,KAA3B;AAA+B;;AACjD,SAAO,MAAP;AACD,CAJD,C;;;;AAQA,aAAA,CAAO,eAAP,GAAO,SAAA,eAAA,CAAgB,MAAhB,EAAwB;AAC7B,SAAO,WAAW,CAAC,MAAM,CAAC,KAAR,CAAlB;AACD,CAFD;;AAKF,SAAS,WAAT,CAAqB,GAArB,EAA0B;AACxBA,MAAI,MAAM,GAAG,EAAbA;;AACA,OAAKA,IAAI,IAAT,IAAiB,GAAjB,EAAsB;AACpBA,QAAI,KAAK,GAAG,GAAG,CAAC,IAAD,CAAH,CAAU,IAAV,CAAe,KAA3BA;;AACA,QAAI,KAAJ,EAAS;AAAE,MAAA,MAAM,CAAC,IAAD,CAAN,GAAe,KAAf;AAAoB;AAChC;;AACD,SAAO,MAAP;AACD;;AAED,SAAS,GAAT,CAAa,OAAb,EAAsB;;AAEpB,SAAO,OAAO,CAAC,QAAR,IAAoB,MAAM,CAAC,QAAlC;AACD","sourcesContent":["export function findDiffStart(a, b, pos) {\n  for (let i = 0;; i++) {\n    if (i == a.childCount || i == b.childCount)\n      return a.childCount == b.childCount ? null : pos\n\n    let childA = a.child(i), childB = b.child(i)\n    if (childA == childB) { pos += childA.nodeSize; continue }\n\n    if (!childA.sameMarkup(childB)) return pos\n\n    if (childA.isText && childA.text != childB.text) {\n      for (let j = 0; childA.text[j] == childB.text[j]; j++)\n        pos++\n      return pos\n    }\n    if (childA.content.size || childB.content.size) {\n      let inner = findDiffStart(childA.content, childB.content, pos + 1)\n      if (inner != null) return inner\n    }\n    pos += childA.nodeSize\n  }\n}\n\nexport function findDiffEnd(a, b, posA, posB) {\n  for (let iA = a.childCount, iB = b.childCount;;) {\n    if (iA == 0 || iB == 0)\n      return iA == iB ? null : {a: posA, b: posB}\n\n    let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize\n    if (childA == childB) {\n      posA -= size; posB -= size\n      continue\n    }\n\n    if (!childA.sameMarkup(childB)) return {a: posA, b: posB}\n\n    if (childA.isText && childA.text != childB.text) {\n      let same = 0, minSize = Math.min(childA.text.length, childB.text.length)\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++; posA--; posB--\n      }\n      return {a: posA, b: posB}\n    }\n    if (childA.content.size || childB.content.size) {\n      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1)\n      if (inner) return inner\n    }\n    posA -= size; posB -= size\n  }\n}\n","import {findDiffStart, findDiffEnd} from \"./diff\"\n\n// ::- A fragment represents a node's collection of child nodes.\n//\n// Like nodes, fragments are persistent data structures, and you\n// should not mutate them or their content. Rather, you create new\n// instances whenever needed. The API tries to make this easy.\nexport class Fragment {\n  constructor(content, size) {\n    this.content = content\n    // :: number\n    // The size of the fragment, which is the total of the size of its\n    // content nodes.\n    this.size = size || 0\n    if (size == null) for (let i = 0; i < content.length; i++)\n      this.size += content[i].nodeSize\n  }\n\n  // :: (number, number, (node: Node, start: number, parent: Node, index: number) → ?bool, ?number)\n  // Invoke a callback for all descendant nodes between the given two\n  // positions (relative to start of this fragment). Doesn't descend\n  // into a node when the callback returns `false`.\n  nodesBetween(from, to, f, nodeStart = 0, parent) {\n    for (let i = 0, pos = 0; pos < to; i++) {\n      let child = this.content[i], end = pos + child.nodeSize\n      if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {\n        let start = pos + 1\n        child.nodesBetween(Math.max(0, from - start),\n                           Math.min(child.content.size, to - start),\n                           f, nodeStart + start)\n      }\n      pos = end\n    }\n  }\n\n  // :: ((node: Node, pos: number, parent: Node) → ?bool)\n  // Call the given callback for every descendant node. The callback\n  // may return `false` to prevent traversal of a given node's children.\n  descendants(f) {\n    this.nodesBetween(0, this.size, f)\n  }\n\n  // : (number, number, ?string, ?string) → string\n  textBetween(from, to, blockSeparator, leafText) {\n    let text = \"\", separated = true\n    this.nodesBetween(from, to, (node, pos) => {\n      if (node.isText) {\n        text += node.text.slice(Math.max(from, pos) - pos, to - pos)\n        separated = !blockSeparator\n      } else if (node.isLeaf && leafText) {\n        text += leafText\n        separated = !blockSeparator\n      } else if (!separated && node.isBlock) {\n        text += blockSeparator\n        separated = true\n      }\n    }, 0)\n    return text\n  }\n\n  // :: (Fragment) → Fragment\n  // Create a new fragment containing the combined content of this\n  // fragment and the other.\n  append(other) {\n    if (!other.size) return this\n    if (!this.size) return other\n    let last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0\n    if (last.isText && last.sameMarkup(first)) {\n      content[content.length - 1] = last.withText(last.text + first.text)\n      i = 1\n    }\n    for (; i < other.content.length; i++) content.push(other.content[i])\n    return new Fragment(content, this.size + other.size)\n  }\n\n  // :: (number, ?number) → Fragment\n  // Cut out the sub-fragment between the two given positions.\n  cut(from, to) {\n    if (to == null) to = this.size\n    if (from == 0 && to == this.size) return this\n    let result = [], size = 0\n    if (to > from) for (let i = 0, pos = 0; pos < to; i++) {\n      let child = this.content[i], end = pos + child.nodeSize\n      if (end > from) {\n        if (pos < from || end > to) {\n          if (child.isText)\n            child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos))\n          else\n            child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1))\n        }\n        result.push(child)\n        size += child.nodeSize\n      }\n      pos = end\n    }\n    return new Fragment(result, size)\n  }\n\n  cutByIndex(from, to) {\n    if (from == to) return Fragment.empty\n    if (from == 0 && to == this.content.length) return this\n    return new Fragment(this.content.slice(from, to))\n  }\n\n  // :: (number, Node) → Fragment\n  // Create a new fragment in which the node at the given index is\n  // replaced by the given node.\n  replaceChild(index, node) {\n    let current = this.content[index]\n    if (current == node) return this\n    let copy = this.content.slice()\n    let size = this.size + node.nodeSize - current.nodeSize\n    copy[index] = node\n    return new Fragment(copy, size)\n  }\n\n  // : (Node) → Fragment\n  // Create a new fragment by prepending the given node to this\n  // fragment.\n  addToStart(node) {\n    return new Fragment([node].concat(this.content), this.size + node.nodeSize)\n  }\n\n  // : (Node) → Fragment\n  // Create a new fragment by appending the given node to this\n  // fragment.\n  addToEnd(node) {\n    return new Fragment(this.content.concat(node), this.size + node.nodeSize)\n  }\n\n  // :: (Fragment) → bool\n  // Compare this fragment to another one.\n  eq(other) {\n    if (this.content.length != other.content.length) return false\n    for (let i = 0; i < this.content.length; i++)\n      if (!this.content[i].eq(other.content[i])) return false\n    return true\n  }\n\n  // :: ?Node\n  // The first child of the fragment, or `null` if it is empty.\n  get firstChild() { return this.content.length ? this.content[0] : null }\n\n  // :: ?Node\n  // The last child of the fragment, or `null` if it is empty.\n  get lastChild() { return this.content.length ? this.content[this.content.length - 1] : null }\n\n  // :: number\n  // The number of child nodes in this fragment.\n  get childCount() { return this.content.length }\n\n  // :: (number) → Node\n  // Get the child node at the given index. Raise an error when the\n  // index is out of range.\n  child(index) {\n    let found = this.content[index]\n    if (!found) throw new RangeError(\"Index \" + index + \" out of range for \" + this)\n    return found\n  }\n\n  // :: (number) → ?Node\n  // Get the child node at the given index, if it exists.\n  maybeChild(index) {\n    return this.content[index]\n  }\n\n  // :: ((node: Node, offset: number, index: number))\n  // Call `f` for every child node, passing the node, its offset\n  // into this parent node, and its index.\n  forEach(f) {\n    for (let i = 0, p = 0; i < this.content.length; i++) {\n      let child = this.content[i]\n      f(child, p, i)\n      p += child.nodeSize\n    }\n  }\n\n  // :: (Fragment) → ?number\n  // Find the first position at which this fragment and another\n  // fragment differ, or `null` if they are the same.\n  findDiffStart(other, pos = 0) {\n    return findDiffStart(this, other, pos)\n  }\n\n  // :: (Fragment) → ?{a: number, b: number}\n  // Find the first position, searching from the end, at which this\n  // fragment and the given fragment differ, or `null` if they are the\n  // same. Since this position will not be the same in both nodes, an\n  // object with two separate positions is returned.\n  findDiffEnd(other, pos = this.size, otherPos = other.size) {\n    return findDiffEnd(this, other, pos, otherPos)\n  }\n\n  // : (number, ?number) → {index: number, offset: number}\n  // Find the index and inner offset corresponding to a given relative\n  // position in this fragment. The result object will be reused\n  // (overwritten) the next time the function is called. (Not public.)\n  findIndex(pos, round = -1) {\n    if (pos == 0) return retIndex(0, pos)\n    if (pos == this.size) return retIndex(this.content.length, pos)\n    if (pos > this.size || pos < 0) throw new RangeError(`Position ${pos} outside of fragment (${this})`)\n    for (let i = 0, curPos = 0;; i++) {\n      let cur = this.child(i), end = curPos + cur.nodeSize\n      if (end >= pos) {\n        if (end == pos || round > 0) return retIndex(i + 1, end)\n        return retIndex(i, curPos)\n      }\n      curPos = end\n    }\n  }\n\n  // :: () → string\n  // Return a debugging string that describes this fragment.\n  toString() { return \"<\" + this.toStringInner() + \">\" }\n\n  toStringInner() { return this.content.join(\", \") }\n\n  // :: () → ?Object\n  // Create a JSON-serializeable representation of this fragment.\n  toJSON() {\n    return this.content.length ? this.content.map(n => n.toJSON()) : null\n  }\n\n  // :: (Schema, ?Object) → Fragment\n  // Deserialize a fragment from its JSON representation.\n  static fromJSON(schema, value) {\n    if (!value) return Fragment.empty\n    if (!Array.isArray(value)) throw new RangeError(\"Invalid input for Fragment.fromJSON\")\n    return new Fragment(value.map(schema.nodeFromJSON))\n  }\n\n  // :: ([Node]) → Fragment\n  // Build a fragment from an array of nodes. Ensures that adjacent\n  // text nodes with the same marks are joined together.\n  static fromArray(array) {\n    if (!array.length) return Fragment.empty\n    let joined, size = 0\n    for (let i = 0; i < array.length; i++) {\n      let node = array[i]\n      size += node.nodeSize\n      if (i && node.isText && array[i - 1].sameMarkup(node)) {\n        if (!joined) joined = array.slice(0, i)\n        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text)\n      } else if (joined) {\n        joined.push(node)\n      }\n    }\n    return new Fragment(joined || array, size)\n  }\n\n  // :: (?union<Fragment, Node, [Node]>) → Fragment\n  // Create a fragment from something that can be interpreted as a set\n  // of nodes. For `null`, it returns the empty fragment. For a\n  // fragment, the fragment itself. For a node or array of nodes, a\n  // fragment containing those nodes.\n  static from(nodes) {\n    if (!nodes) return Fragment.empty\n    if (nodes instanceof Fragment) return nodes\n    if (Array.isArray(nodes)) return this.fromArray(nodes)\n    if (nodes.attrs) return new Fragment([nodes], nodes.nodeSize)\n    throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" +\n                         (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"))\n  }\n}\n\nconst found = {index: 0, offset: 0}\nfunction retIndex(index, offset) {\n  found.index = index\n  found.offset = offset\n  return found\n}\n\n// :: Fragment\n// An empty fragment. Intended to be reused whenever a node doesn't\n// contain anything (rather than allocating a new empty fragment for\n// each leaf node).\nFragment.empty = new Fragment([], 0)\n","export function compareDeep(a, b) {\n  if (a === b) return true\n  if (!(a && typeof a == \"object\") ||\n      !(b && typeof b == \"object\")) return false\n  let array = Array.isArray(a)\n  if (Array.isArray(b) != array) return false\n  if (array) {\n    if (a.length != b.length) return false\n    for (let i = 0; i < a.length; i++) if (!compareDeep(a[i], b[i])) return false\n  } else {\n    for (let p in a) if (!(p in b) || !compareDeep(a[p], b[p])) return false\n    for (let p in b) if (!(p in a)) return false\n  }\n  return true\n}\n","import {compareDeep} from \"./comparedeep\"\n\n// ::- A mark is a piece of information that can be attached to a node,\n// such as it being emphasized, in code font, or a link. It has a type\n// and optionally a set of attributes that provide further information\n// (such as the target of the link). Marks are created through a\n// `Schema`, which controls which types exist and which\n// attributes they have.\nexport class Mark {\n  constructor(type, attrs) {\n    // :: MarkType\n    // The type of this mark.\n    this.type = type\n    // :: Object\n    // The attributes associated with this mark.\n    this.attrs = attrs\n  }\n\n  // :: ([Mark]) → [Mark]\n  // Given a set of marks, create a new set which contains this one as\n  // well, in the right position. If this mark is already in the set,\n  // the set itself is returned. If any marks that are set to be\n  // [exclusive](#model.MarkSpec.excludes) with this mark are present,\n  // those are replaced by this one.\n  addToSet(set) {\n    let copy, placed = false\n    for (let i = 0; i < set.length; i++) {\n      let other = set[i]\n      if (this.eq(other)) return set\n      if (this.type.excludes(other.type)) {\n        if (!copy) copy = set.slice(0, i)\n      } else if (other.type.excludes(this.type)) {\n        return set\n      } else {\n        if (!placed && other.type.rank > this.type.rank) {\n          if (!copy) copy = set.slice(0, i)\n          copy.push(this)\n          placed = true\n        }\n        if (copy) copy.push(other)\n      }\n    }\n    if (!copy) copy = set.slice()\n    if (!placed) copy.push(this)\n    return copy\n  }\n\n  // :: ([Mark]) → [Mark]\n  // Remove this mark from the given set, returning a new set. If this\n  // mark is not in the set, the set itself is returned.\n  removeFromSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (this.eq(set[i]))\n        return set.slice(0, i).concat(set.slice(i + 1))\n    return set\n  }\n\n  // :: ([Mark]) → bool\n  // Test whether this mark is in the given set of marks.\n  isInSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (this.eq(set[i])) return true\n    return false\n  }\n\n  // :: (Mark) → bool\n  // Test whether this mark has the same type and attributes as\n  // another mark.\n  eq(other) {\n    return this == other ||\n      (this.type == other.type && compareDeep(this.attrs, other.attrs))\n  }\n\n  // :: () → Object\n  // Convert this mark to a JSON-serializeable representation.\n  toJSON() {\n    let obj = {type: this.type.name}\n    for (let _ in this.attrs) {\n      obj.attrs = this.attrs\n      break\n    }\n    return obj\n  }\n\n  // :: (Schema, Object) → Mark\n  static fromJSON(schema, json) {\n    if (!json) throw new RangeError(\"Invalid input for Mark.fromJSON\")\n    let type = schema.marks[json.type]\n    if (!type) throw new RangeError(`There is no mark type ${json.type} in this schema`)\n    return type.create(json.attrs)\n  }\n\n  // :: ([Mark], [Mark]) → bool\n  // Test whether two sets of marks are identical.\n  static sameSet(a, b) {\n    if (a == b) return true\n    if (a.length != b.length) return false\n    for (let i = 0; i < a.length; i++)\n      if (!a[i].eq(b[i])) return false\n    return true\n  }\n\n  // :: (?union<Mark, [Mark]>) → [Mark]\n  // Create a properly sorted mark set from null, a single mark, or an\n  // unsorted array of marks.\n  static setFrom(marks) {\n    if (!marks || marks.length == 0) return Mark.none\n    if (marks instanceof Mark) return [marks]\n    let copy = marks.slice()\n    copy.sort((a, b) => a.type.rank - b.type.rank)\n    return copy\n  }\n}\n\n// :: [Mark] The empty set of marks.\nMark.none = []\n","import {Fragment} from \"./fragment\"\n\n// ReplaceError:: class extends Error\n// Error type raised by [`Node.replace`](#model.Node.replace) when\n// given an invalid replacement.\n\nexport function ReplaceError(message) {\n  let err = Error.call(this, message)\n  err.__proto__ = ReplaceError.prototype\n  return err\n}\n\nReplaceError.prototype = Object.create(Error.prototype)\nReplaceError.prototype.constructor = ReplaceError\nReplaceError.prototype.name = \"ReplaceError\"\n\n// ::- A slice represents a piece cut out of a larger document. It\n// stores not only a fragment, but also the depth up to which nodes on\n// both side are ‘open’ (cut through).\nexport class Slice {\n  // :: (Fragment, number, number)\n  // Create a slice. When specifying a non-zero open depth, you must\n  // make sure that there are nodes of at least that depth at the\n  // appropriate side of the fragment—i.e. if the fragment is an empty\n  // paragraph node, `openStart` and `openEnd` can't be greater than 1.\n  //\n  // It is not necessary for the content of open nodes to conform to\n  // the schema's content constraints, though it should be a valid\n  // start/end/middle for such a node, depending on which sides are\n  // open.\n  constructor(content, openStart, openEnd) {\n    // :: Fragment The slice's content.\n    this.content = content\n    // :: number The open depth at the start.\n    this.openStart = openStart\n    // :: number The open depth at the end.\n    this.openEnd = openEnd\n  }\n\n  // :: number\n  // The size this slice would add when inserted into a document.\n  get size() {\n    return this.content.size - this.openStart - this.openEnd\n  }\n\n  insertAt(pos, fragment) {\n    let content = insertInto(this.content, pos + this.openStart, fragment, null)\n    return content && new Slice(content, this.openStart, this.openEnd)\n  }\n\n  removeBetween(from, to) {\n    return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd)\n  }\n\n  // :: (Slice) → bool\n  // Tests whether this slice is equal to another slice.\n  eq(other) {\n    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd\n  }\n\n  toString() {\n    return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\"\n  }\n\n  // :: () → ?Object\n  // Convert a slice to a JSON-serializable representation.\n  toJSON() {\n    if (!this.content.size) return null\n    let json = {content: this.content.toJSON()}\n    if (this.openStart > 0) json.openStart = this.openStart\n    if (this.openEnd > 0) json.openEnd = this.openEnd\n    return json\n  }\n\n  // :: (Schema, ?Object) → Slice\n  // Deserialize a slice from its JSON representation.\n  static fromJSON(schema, json) {\n    if (!json) return Slice.empty\n    let openStart = json.openStart || 0, openEnd = json.openEnd || 0\n    if (typeof openStart != \"number\" || typeof openEnd != \"number\")\n      throw new RangeError(\"Invalid input for Slice.fromJSON\")\n    return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd)\n  }\n\n  // :: (Fragment, ?bool) → Slice\n  // Create a slice from a fragment by taking the maximum possible\n  // open value on both side of the fragment.\n  static maxOpen(fragment, openIsolating=true) {\n    let openStart = 0, openEnd = 0\n    for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) openStart++\n    for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild) openEnd++\n    return new Slice(fragment, openStart, openEnd)\n  }\n}\n\nfunction removeRange(content, from, to) {\n  let {index, offset} = content.findIndex(from), child = content.maybeChild(index)\n  let {index: indexTo, offset: offsetTo} = content.findIndex(to)\n  if (offset == from || child.isText) {\n    if (offsetTo != to && !content.child(indexTo).isText) throw new RangeError(\"Removing non-flat range\")\n    return content.cut(0, from).append(content.cut(to))\n  }\n  if (index != indexTo) throw new RangeError(\"Removing non-flat range\")\n  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)))\n}\n\nfunction insertInto(content, dist, insert, parent) {\n  let {index, offset} = content.findIndex(dist), child = content.maybeChild(index)\n  if (offset == dist || child.isText) {\n    if (parent && !parent.canReplace(index, index, insert)) return null\n    return content.cut(0, dist).append(insert).append(content.cut(dist))\n  }\n  let inner = insertInto(child.content, dist - offset - 1, insert)\n  return inner && content.replaceChild(index, child.copy(inner))\n}\n\n// :: Slice\n// The empty slice.\nSlice.empty = new Slice(Fragment.empty, 0, 0)\n\nexport function replace($from, $to, slice) {\n  if (slice.openStart > $from.depth)\n    throw new ReplaceError(\"Inserted content deeper than insertion position\")\n  if ($from.depth - slice.openStart != $to.depth - slice.openEnd)\n    throw new ReplaceError(\"Inconsistent open depths\")\n  return replaceOuter($from, $to, slice, 0)\n}\n\nfunction replaceOuter($from, $to, slice, depth) {\n  let index = $from.index(depth), node = $from.node(depth)\n  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n    let inner = replaceOuter($from, $to, slice, depth + 1)\n    return node.copy(node.content.replaceChild(index, inner))\n  } else if (!slice.content.size) {\n    return close(node, replaceTwoWay($from, $to, depth))\n  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) { // Simple, flat case\n    let parent = $from.parent, content = parent.content\n    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)))\n  } else {\n    let {start, end} = prepareSliceForReplace(slice, $from)\n    return close(node, replaceThreeWay($from, start, end, $to, depth))\n  }\n}\n\nfunction checkJoin(main, sub) {\n  if (!sub.type.compatibleContent(main.type))\n    throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name)\n}\n\nfunction joinable($before, $after, depth) {\n  let node = $before.node(depth)\n  checkJoin(node, $after.node(depth))\n  return node\n}\n\nfunction addNode(child, target) {\n  let last = target.length - 1\n  if (last >= 0 && child.isText && child.sameMarkup(target[last]))\n    target[last] = child.withText(target[last].text + child.text)\n  else\n    target.push(child)\n}\n\nfunction addRange($start, $end, depth, target) {\n  let node = ($end || $start).node(depth)\n  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount\n  if ($start) {\n    startIndex = $start.index(depth)\n    if ($start.depth > depth) {\n      startIndex++\n    } else if ($start.textOffset) {\n      addNode($start.nodeAfter, target)\n      startIndex++\n    }\n  }\n  for (let i = startIndex; i < endIndex; i++) addNode(node.child(i), target)\n  if ($end && $end.depth == depth && $end.textOffset)\n    addNode($end.nodeBefore, target)\n}\n\nfunction close(node, content) {\n  if (!node.type.validContent(content))\n    throw new ReplaceError(\"Invalid content for node \" + node.type.name)\n  return node.copy(content)\n}\n\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n  let openStart = $from.depth > depth && joinable($from, $start, depth + 1)\n  let openEnd = $to.depth > depth && joinable($end, $to, depth + 1)\n\n  let content = []\n  addRange(null, $from, depth, content)\n  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n    checkJoin(openStart, openEnd)\n    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content)\n  } else {\n    if (openStart)\n      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content)\n    addRange($start, $end, depth, content)\n    if (openEnd)\n      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content)\n  }\n  addRange($to, null, depth, content)\n  return new Fragment(content)\n}\n\nfunction replaceTwoWay($from, $to, depth) {\n  let content = []\n  addRange(null, $from, depth, content)\n  if ($from.depth > depth) {\n    let type = joinable($from, $to, depth + 1)\n    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content)\n  }\n  addRange($to, null, depth, content)\n  return new Fragment(content)\n}\n\nfunction prepareSliceForReplace(slice, $along) {\n  let extra = $along.depth - slice.openStart, parent = $along.node(extra)\n  let node = parent.copy(slice.content)\n  for (let i = extra - 1; i >= 0; i--)\n    node = $along.node(i).copy(Fragment.from(node))\n  return {start: node.resolveNoCache(slice.openStart + extra),\n          end: node.resolveNoCache(node.content.size - slice.openEnd - extra)}\n}\n","import {Mark} from \"./mark\"\n\n// ::- You can [_resolve_](#model.Node.resolve) a position to get more\n// information about it. Objects of this class represent such a\n// resolved position, providing various pieces of context information,\n// and some helper methods.\n//\n// Throughout this interface, methods that take an optional `depth`\n// parameter will interpret undefined as `this.depth` and negative\n// numbers as `this.depth + value`.\nexport class ResolvedPos {\n  constructor(pos, path, parentOffset) {\n    // :: number The position that was resolved.\n    this.pos = pos\n    this.path = path\n    // :: number\n    // The number of levels the parent node is from the root. If this\n    // position points directly into the root node, it is 0. If it\n    // points into a top-level paragraph, 1, and so on.\n    this.depth = path.length / 3 - 1\n    // :: number The offset this position has into its parent node.\n    this.parentOffset = parentOffset\n  }\n\n  resolveDepth(val) {\n    if (val == null) return this.depth\n    if (val < 0) return this.depth + val\n    return val\n  }\n\n  // :: Node\n  // The parent node that the position points into. Note that even if\n  // a position points into a text node, that node is not considered\n  // the parent—text nodes are ‘flat’ in this model, and have no content.\n  get parent() { return this.node(this.depth) }\n\n  // :: Node\n  // The root node in which the position was resolved.\n  get doc() { return this.node(0) }\n\n  // :: (?number) → Node\n  // The ancestor node at the given level. `p.node(p.depth)` is the\n  // same as `p.parent`.\n  node(depth) { return this.path[this.resolveDepth(depth) * 3] }\n\n  // :: (?number) → number\n  // The index into the ancestor at the given level. If this points at\n  // the 3rd node in the 2nd paragraph on the top level, for example,\n  // `p.index(0)` is 1 and `p.index(1)` is 2.\n  index(depth) { return this.path[this.resolveDepth(depth) * 3 + 1] }\n\n  // :: (?number) → number\n  // The index pointing after this position into the ancestor at the\n  // given level.\n  indexAfter(depth) {\n    depth = this.resolveDepth(depth)\n    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1)\n  }\n\n  // :: (?number) → number\n  // The (absolute) position at the start of the node at the given\n  // level.\n  start(depth) {\n    depth = this.resolveDepth(depth)\n    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n  }\n\n  // :: (?number) → number\n  // The (absolute) position at the end of the node at the given\n  // level.\n  end(depth) {\n    depth = this.resolveDepth(depth)\n    return this.start(depth) + this.node(depth).content.size\n  }\n\n  // :: (?number) → number\n  // The (absolute) position directly before the wrapping node at the\n  // given level, or, when `depth` is `this.depth + 1`, the original\n  // position.\n  before(depth) {\n    depth = this.resolveDepth(depth)\n    if (!depth) throw new RangeError(\"There is no position before the top-level node\")\n    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1]\n  }\n\n  // :: (?number) → number\n  // The (absolute) position directly after the wrapping node at the\n  // given level, or the original position when `depth` is `this.depth + 1`.\n  after(depth) {\n    depth = this.resolveDepth(depth)\n    if (!depth) throw new RangeError(\"There is no position after the top-level node\")\n    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize\n  }\n\n  // :: number\n  // When this position points into a text node, this returns the\n  // distance between the position and the start of the text node.\n  // Will be zero for positions that point between nodes.\n  get textOffset() { return this.pos - this.path[this.path.length - 1] }\n\n  // :: ?Node\n  // Get the node directly after the position, if any. If the position\n  // points into a text node, only the part of that node after the\n  // position is returned.\n  get nodeAfter() {\n    let parent = this.parent, index = this.index(this.depth)\n    if (index == parent.childCount) return null\n    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index)\n    return dOff ? parent.child(index).cut(dOff) : child\n  }\n\n  // :: ?Node\n  // Get the node directly before the position, if any. If the\n  // position points into a text node, only the part of that node\n  // before the position is returned.\n  get nodeBefore() {\n    let index = this.index(this.depth)\n    let dOff = this.pos - this.path[this.path.length - 1]\n    if (dOff) return this.parent.child(index).cut(0, dOff)\n    return index == 0 ? null : this.parent.child(index - 1)\n  }\n\n  // :: (number, ?number) → number\n  // Get the position at the given index in the parent node at the\n  // given depth (which defaults to `this.depth`).\n  posAtIndex(index, depth) {\n    depth = this.resolveDepth(depth)\n    let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n    for (let i = 0; i < index; i++) pos += node.child(i).nodeSize\n    return pos\n  }\n\n  // :: () → [Mark]\n  // Get the marks at this position, factoring in the surrounding\n  // marks' [`inclusive`](#model.MarkSpec.inclusive) property. If the\n  // position is at the start of a non-empty node, the marks of the\n  // node after it (if any) are returned.\n  marks() {\n    let parent = this.parent, index = this.index()\n\n    // In an empty parent, return the empty array\n    if (parent.content.size == 0) return Mark.none\n\n    // When inside a text node, just return the text node's marks\n    if (this.textOffset) return parent.child(index).marks\n\n    let main = parent.maybeChild(index - 1), other = parent.maybeChild(index)\n    // If the `after` flag is true of there is no node before, make\n    // the node after this position the main reference.\n    if (!main) { let tmp = main; main = other; other = tmp }\n\n    // Use all marks in the main node, except those that have\n    // `inclusive` set to false and are not present in the other node.\n    let marks = main.marks\n    for (var i = 0; i < marks.length; i++)\n      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))\n        marks = marks[i--].removeFromSet(marks)\n\n    return marks\n  }\n\n  // :: (ResolvedPos) → ?[Mark]\n  // Get the marks after the current position, if any, except those\n  // that are non-inclusive and not present at position `$end`. This\n  // is mostly useful for getting the set of marks to preserve after a\n  // deletion. Will return `null` if this position is at the end of\n  // its parent node or its parent node isn't a textblock (in which\n  // case no marks should be preserved).\n  marksAcross($end) {\n    let after = this.parent.maybeChild(this.index())\n    if (!after || !after.isInline) return null\n\n    let marks = after.marks, next = $end.parent.maybeChild($end.index())\n    for (var i = 0; i < marks.length; i++)\n      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))\n        marks = marks[i--].removeFromSet(marks)\n    return marks\n  }\n\n  // :: (number) → number\n  // The depth up to which this position and the given (non-resolved)\n  // position share the same parent nodes.\n  sharedDepth(pos) {\n    for (let depth = this.depth; depth > 0; depth--)\n      if (this.start(depth) <= pos && this.end(depth) >= pos) return depth\n    return 0\n  }\n\n  // :: (?ResolvedPos, ?(Node) → bool) → ?NodeRange\n  // Returns a range based on the place where this position and the\n  // given position diverge around block content. If both point into\n  // the same textblock, for example, a range around that textblock\n  // will be returned. If they point into different blocks, the range\n  // around those blocks in their shared ancestor is returned. You can\n  // pass in an optional predicate that will be called with a parent\n  // node to see if a range into that parent is acceptable.\n  blockRange(other = this, pred) {\n    if (other.pos < this.pos) return other.blockRange(this)\n    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)\n      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))\n        return new NodeRange(this, other, d)\n  }\n\n  // :: (ResolvedPos) → bool\n  // Query whether the given position shares the same parent node.\n  sameParent(other) {\n    return this.pos - this.parentOffset == other.pos - other.parentOffset\n  }\n\n  // :: (ResolvedPos) → ResolvedPos\n  // Return the greater of this and the given position.\n  max(other) {\n    return other.pos > this.pos ? other : this\n  }\n\n  // :: (ResolvedPos) → ResolvedPos\n  // Return the smaller of this and the given position.\n  min(other) {\n    return other.pos < this.pos ? other : this\n  }\n\n  toString() {\n    let str = \"\"\n    for (let i = 1; i <= this.depth; i++)\n      str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1)\n    return str + \":\" + this.parentOffset\n  }\n\n  static resolve(doc, pos) {\n    if (!(pos >= 0 && pos <= doc.content.size)) throw new RangeError(\"Position \" + pos + \" out of range\")\n    let path = []\n    let start = 0, parentOffset = pos\n    for (let node = doc;;) {\n      let {index, offset} = node.content.findIndex(parentOffset)\n      let rem = parentOffset - offset\n      path.push(node, index, start + offset)\n      if (!rem) break\n      node = node.child(index)\n      if (node.isText) break\n      parentOffset = rem - 1\n      start += offset + 1\n    }\n    return new ResolvedPos(pos, path, parentOffset)\n  }\n\n  static resolveCached(doc, pos) {\n    for (let i = 0; i < resolveCache.length; i++) {\n      let cached = resolveCache[i]\n      if (cached.pos == pos && cached.doc == doc) return cached\n    }\n    let result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos)\n    resolveCachePos = (resolveCachePos + 1) % resolveCacheSize\n    return result\n  }\n}\n\nlet resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12\n\n// ::- Represents a flat range of content, i.e. one that starts and\n// ends in the same node.\nexport class NodeRange {\n  // :: (ResolvedPos, ResolvedPos, number)\n  // Construct a node range. `$from` and `$to` should point into the\n  // same node until at least the given `depth`, since a node range\n  // denotes an adjacent set of nodes in a single parent node.\n  constructor($from, $to, depth) {\n    // :: ResolvedPos A resolved position along the start of the\n    // content. May have a `depth` greater than this object's `depth`\n    // property, since these are the positions that were used to\n    // compute the range, not re-resolved positions directly at its\n    // boundaries.\n    this.$from = $from\n    // :: ResolvedPos A position along the end of the content. See\n    // caveat for [`$from`](#model.NodeRange.$from).\n    this.$to = $to\n    // :: number The depth of the node that this range points into.\n    this.depth = depth\n  }\n\n  // :: number The position at the start of the range.\n  get start() { return this.$from.before(this.depth + 1) }\n  // :: number The position at the end of the range.\n  get end() { return this.$to.after(this.depth + 1) }\n\n  // :: Node The parent node that the range points into.\n  get parent() { return this.$from.node(this.depth) }\n  // :: number The start index of the range in the parent node.\n  get startIndex() { return this.$from.index(this.depth) }\n  // :: number The end index of the range in the parent node.\n  get endIndex() { return this.$to.indexAfter(this.depth) }\n}\n","import {Fragment} from \"./fragment\"\nimport {Mark} from \"./mark\"\nimport {Slice, replace} from \"./replace\"\nimport {ResolvedPos} from \"./resolvedpos\"\nimport {compareDeep} from \"./comparedeep\"\n\nconst emptyAttrs = Object.create(null)\n\n// ::- This class represents a node in the tree that makes up a\n// ProseMirror document. So a document is an instance of `Node`, with\n// children that are also instances of `Node`.\n//\n// Nodes are persistent data structures. Instead of changing them, you\n// create new ones with the content you want. Old ones keep pointing\n// at the old document shape. This is made cheaper by sharing\n// structure between the old and new data as much as possible, which a\n// tree shape like this (without back pointers) makes easy.\n//\n// **Do not** directly mutate the properties of a `Node` object. See\n// [the guide](/docs/guide/#doc) for more information.\nexport class Node {\n  constructor(type, attrs, content, marks) {\n    // :: NodeType\n    // The type of node that this is.\n    this.type = type\n\n    // :: Object\n    // An object mapping attribute names to values. The kind of\n    // attributes allowed and required are\n    // [determined](#model.NodeSpec.attrs) by the node type.\n    this.attrs = attrs\n\n    // :: Fragment\n    // A container holding the node's children.\n    this.content = content || Fragment.empty\n\n    // :: [Mark]\n    // The marks (things like whether it is emphasized or part of a\n    // link) applied to this node.\n    this.marks = marks || Mark.none\n  }\n\n  // text:: ?string\n  // For text nodes, this contains the node's text content.\n\n  // :: number\n  // The size of this node, as defined by the integer-based [indexing\n  // scheme](/docs/guide/#doc.indexing). For text nodes, this is the\n  // amount of characters. For other leaf nodes, it is one. For\n  // non-leaf nodes, it is the size of the content plus two (the start\n  // and end token).\n  get nodeSize() { return this.isLeaf ? 1 : 2 + this.content.size }\n\n  // :: number\n  // The number of children that the node has.\n  get childCount() { return this.content.childCount }\n\n  // :: (number) → Node\n  // Get the child node at the given index. Raises an error when the\n  // index is out of range.\n  child(index) { return this.content.child(index) }\n\n  // :: (number) → ?Node\n  // Get the child node at the given index, if it exists.\n  maybeChild(index) { return this.content.maybeChild(index) }\n\n  // :: ((node: Node, offset: number, index: number))\n  // Call `f` for every child node, passing the node, its offset\n  // into this parent node, and its index.\n  forEach(f) { this.content.forEach(f) }\n\n  // :: (number, number, (node: Node, pos: number, parent: Node, index: number) → ?bool, ?number)\n  // Invoke a callback for all descendant nodes recursively between\n  // the given two positions that are relative to start of this node's\n  // content. The callback is invoked with the node, its\n  // parent-relative position, its parent node, and its child index.\n  // When the callback returns false for a given node, that node's\n  // children will not be recursed over. The last parameter can be\n  // used to specify a starting position to count from.\n  nodesBetween(from, to, f, startPos = 0) {\n    this.content.nodesBetween(from, to, f, startPos, this)\n  }\n\n  // :: ((node: Node, pos: number, parent: Node) → ?bool)\n  // Call the given callback for every descendant node. Doesn't\n  // descend into a node when the callback returns `false`.\n  descendants(f) {\n    this.nodesBetween(0, this.content.size, f)\n  }\n\n  // :: string\n  // Concatenates all the text nodes found in this fragment and its\n  // children.\n  get textContent() { return this.textBetween(0, this.content.size, \"\") }\n\n  // :: (number, number, ?string, ?string) → string\n  // Get all text between positions `from` and `to`. When\n  // `blockSeparator` is given, it will be inserted whenever a new\n  // block node is started. When `leafText` is given, it'll be\n  // inserted for every non-text leaf node encountered.\n  textBetween(from, to, blockSeparator, leafText) {\n    return this.content.textBetween(from, to, blockSeparator, leafText)\n  }\n\n  // :: ?Node\n  // Returns this node's first child, or `null` if there are no\n  // children.\n  get firstChild() { return this.content.firstChild }\n\n  // :: ?Node\n  // Returns this node's last child, or `null` if there are no\n  // children.\n  get lastChild() { return this.content.lastChild }\n\n  // :: (Node) → bool\n  // Test whether two nodes represent the same piece of document.\n  eq(other) {\n    return this == other || (this.sameMarkup(other) && this.content.eq(other.content))\n  }\n\n  // :: (Node) → bool\n  // Compare the markup (type, attributes, and marks) of this node to\n  // those of another. Returns `true` if both have the same markup.\n  sameMarkup(other) {\n    return this.hasMarkup(other.type, other.attrs, other.marks)\n  }\n\n  // :: (NodeType, ?Object, ?[Mark]) → bool\n  // Check whether this node's markup correspond to the given type,\n  // attributes, and marks.\n  hasMarkup(type, attrs, marks) {\n    return this.type == type &&\n      compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&\n      Mark.sameSet(this.marks, marks || Mark.none)\n  }\n\n  // :: (?Fragment) → Node\n  // Create a new node with the same markup as this node, containing\n  // the given content (or empty, if no content is given).\n  copy(content = null) {\n    if (content == this.content) return this\n    return new this.constructor(this.type, this.attrs, content, this.marks)\n  }\n\n  // :: ([Mark]) → Node\n  // Create a copy of this node, with the given set of marks instead\n  // of the node's own marks.\n  mark(marks) {\n    return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks)\n  }\n\n  // :: (number, ?number) → Node\n  // Create a copy of this node with only the content between the\n  // given positions. If `to` is not given, it defaults to the end of\n  // the node.\n  cut(from, to) {\n    if (from == 0 && to == this.content.size) return this\n    return this.copy(this.content.cut(from, to))\n  }\n\n  // :: (number, ?number) → Slice\n  // Cut out the part of the document between the given positions, and\n  // return it as a `Slice` object.\n  slice(from, to = this.content.size, includeParents = false) {\n    if (from == to) return Slice.empty\n\n    let $from = this.resolve(from), $to = this.resolve(to)\n    let depth = includeParents ? 0 : $from.sharedDepth(to)\n    let start = $from.start(depth), node = $from.node(depth)\n    let content = node.content.cut($from.pos - start, $to.pos - start)\n    return new Slice(content, $from.depth - depth, $to.depth - depth)\n  }\n\n  // :: (number, number, Slice) → Node\n  // Replace the part of the document between the given positions with\n  // the given slice. The slice must 'fit', meaning its open sides\n  // must be able to connect to the surrounding content, and its\n  // content nodes must be valid children for the node they are placed\n  // into. If any of this is violated, an error of type\n  // [`ReplaceError`](#model.ReplaceError) is thrown.\n  replace(from, to, slice) {\n    return replace(this.resolve(from), this.resolve(to), slice)\n  }\n\n  // :: (number) → ?Node\n  // Find the node directly after the given position.\n  nodeAt(pos) {\n    for (let node = this;;) {\n      let {index, offset} = node.content.findIndex(pos)\n      node = node.maybeChild(index)\n      if (!node) return null\n      if (offset == pos || node.isText) return node\n      pos -= offset + 1\n    }\n  }\n\n  // :: (number) → {node: ?Node, index: number, offset: number}\n  // Find the (direct) child node after the given offset, if any,\n  // and return it along with its index and offset relative to this\n  // node.\n  childAfter(pos) {\n    let {index, offset} = this.content.findIndex(pos)\n    return {node: this.content.maybeChild(index), index, offset}\n  }\n\n  // :: (number) → {node: ?Node, index: number, offset: number}\n  // Find the (direct) child node before the given offset, if any,\n  // and return it along with its index and offset relative to this\n  // node.\n  childBefore(pos) {\n    if (pos == 0) return {node: null, index: 0, offset: 0}\n    let {index, offset} = this.content.findIndex(pos)\n    if (offset < pos) return {node: this.content.child(index), index, offset}\n    let node = this.content.child(index - 1)\n    return {node, index: index - 1, offset: offset - node.nodeSize}\n  }\n\n  // :: (number) → ResolvedPos\n  // Resolve the given position in the document, returning an\n  // [object](#model.ResolvedPos) with information about its context.\n  resolve(pos) { return ResolvedPos.resolveCached(this, pos) }\n\n  resolveNoCache(pos) { return ResolvedPos.resolve(this, pos) }\n\n  // :: (number, number, union<Mark, MarkType>) → bool\n  // Test whether a given mark or mark type occurs in this document\n  // between the two given positions.\n  rangeHasMark(from, to, type) {\n    let found = false\n    if (to > from) this.nodesBetween(from, to, node => {\n      if (type.isInSet(node.marks)) found = true\n      return !found\n    })\n    return found\n  }\n\n  // :: bool\n  // True when this is a block (non-inline node)\n  get isBlock() { return this.type.isBlock }\n\n  // :: bool\n  // True when this is a textblock node, a block node with inline\n  // content.\n  get isTextblock() { return this.type.isTextblock }\n\n  // :: bool\n  // True when this node allows inline content.\n  get inlineContent() { return this.type.inlineContent }\n\n  // :: bool\n  // True when this is an inline node (a text node or a node that can\n  // appear among text).\n  get isInline() { return this.type.isInline }\n\n  // :: bool\n  // True when this is a text node.\n  get isText() { return this.type.isText }\n\n  // :: bool\n  // True when this is a leaf node.\n  get isLeaf() { return this.type.isLeaf }\n\n  // :: bool\n  // True when this is an atom, i.e. when it does not have directly\n  // editable content. This is usually the same as `isLeaf`, but can\n  // be configured with the [`atom` property](#model.NodeSpec.atom) on\n  // a node's spec (typically used when the node is displayed as an\n  // uneditable [node view](#view.NodeView)).\n  get isAtom() { return this.type.isAtom }\n\n  // :: () → string\n  // Return a string representation of this node for debugging\n  // purposes.\n  toString() {\n    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this)\n    let name = this.type.name\n    if (this.content.size)\n      name += \"(\" + this.content.toStringInner() + \")\"\n    return wrapMarks(this.marks, name)\n  }\n\n  // :: (number) → ContentMatch\n  // Get the content match in this node at the given index.\n  contentMatchAt(index) {\n    let match = this.type.contentMatch.matchFragment(this.content, 0, index)\n    if (!match) throw new Error(\"Called contentMatchAt on a node with invalid content\")\n    return match\n  }\n\n  // :: (number, number, ?Fragment, ?number, ?number) → bool\n  // Test whether replacing the range between `from` and `to` (by\n  // child index) with the given replacement fragment (which defaults\n  // to the empty fragment) would leave the node's content valid. You\n  // can optionally pass `start` and `end` indices into the\n  // replacement fragment.\n  canReplace(from, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {\n    let one = this.contentMatchAt(from).matchFragment(replacement, start, end)\n    let two = one && one.matchFragment(this.content, to)\n    if (!two || !two.validEnd) return false\n    for (let i = start; i < end; i++) if (!this.type.allowsMarks(replacement.child(i).marks)) return false\n    return true\n  }\n\n  // :: (number, number, NodeType, ?[Mark]) → bool\n  // Test whether replacing the range `from` to `to` (by index) with a\n  // node of the given type would leave the node's content valid.\n  canReplaceWith(from, to, type, marks) {\n    if (marks && !this.type.allowsMarks(marks)) return false\n    let start = this.contentMatchAt(from).matchType(type)\n    let end = start && start.matchFragment(this.content, to)\n    return end ? end.validEnd : false\n  }\n\n  // :: (Node) → bool\n  // Test whether the given node's content could be appended to this\n  // node. If that node is empty, this will only return true if there\n  // is at least one node type that can appear in both nodes (to avoid\n  // merging completely incompatible nodes).\n  canAppend(other) {\n    if (other.content.size) return this.canReplace(this.childCount, this.childCount, other.content)\n    else return this.type.compatibleContent(other.type)\n  }\n\n  // :: ()\n  // Check whether this node and its descendants conform to the\n  // schema, and raise error when they do not.\n  check() {\n    if (!this.type.validContent(this.content))\n      throw new RangeError(`Invalid content for node ${this.type.name}: ${this.content.toString().slice(0, 50)}`)\n    this.content.forEach(node => node.check())\n  }\n\n  // :: () → Object\n  // Return a JSON-serializeable representation of this node.\n  toJSON() {\n    let obj = {type: this.type.name}\n    for (let _ in this.attrs) {\n      obj.attrs = this.attrs\n      break\n    }\n    if (this.content.size)\n      obj.content = this.content.toJSON()\n    if (this.marks.length)\n      obj.marks = this.marks.map(n => n.toJSON())\n    return obj\n  }\n\n  // :: (Schema, Object) → Node\n  // Deserialize a node from its JSON representation.\n  static fromJSON(schema, json) {\n    if (!json) throw new RangeError(\"Invalid input for Node.fromJSON\")\n    let marks = null\n    if (json.marks) {\n      if (!Array.isArray(json.marks)) throw new RangeError(\"Invalid mark data for Node.fromJSON\")\n      marks = json.marks.map(schema.markFromJSON)\n    }\n    if (json.type == \"text\") {\n      if (typeof json.text != \"string\") throw new RangeError(\"Invalid text node in JSON\")\n      return schema.text(json.text, marks)\n    }\n    let content = Fragment.fromJSON(schema, json.content)\n    return schema.nodeType(json.type).create(json.attrs, content, marks)\n  }\n}\n\nexport class TextNode extends Node {\n  constructor(type, attrs, content, marks) {\n    super(type, attrs, null, marks)\n\n    if (!content) throw new RangeError(\"Empty text nodes are not allowed\")\n\n    this.text = content\n  }\n\n  toString() {\n    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this)\n    return wrapMarks(this.marks, JSON.stringify(this.text))\n  }\n\n  get textContent() { return this.text }\n\n  textBetween(from, to) { return this.text.slice(from, to) }\n\n  get nodeSize() { return this.text.length }\n\n  mark(marks) {\n    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks)\n  }\n\n  withText(text) {\n    if (text == this.text) return this\n    return new TextNode(this.type, this.attrs, text, this.marks)\n  }\n\n  cut(from = 0, to = this.text.length) {\n    if (from == 0 && to == this.text.length) return this\n    return this.withText(this.text.slice(from, to))\n  }\n\n  eq(other) {\n    return this.sameMarkup(other) && this.text == other.text\n  }\n\n  toJSON() {\n    let base = super.toJSON()\n    base.text = this.text\n    return base\n  }\n}\n\nfunction wrapMarks(marks, str) {\n  for (let i = marks.length - 1; i >= 0; i--)\n    str = marks[i].type.name + \"(\" + str + \")\"\n  return str\n}\n","import {Fragment} from \"./fragment\"\n\n// ::- Instances of this class represent a match state of a node\n// type's [content expression](#model.NodeSpec.content), and can be\n// used to find out whether further content matches here, and whether\n// a given position is a valid end of the node.\nexport class ContentMatch {\n  constructor(validEnd) {\n    // :: bool\n    // True when this match state represents a valid end of the node.\n    this.validEnd = validEnd\n    this.next = []\n    this.wrapCache = []\n  }\n\n  static parse(string, nodeTypes) {\n    let stream = new TokenStream(string, nodeTypes)\n    if (stream.next == null) return ContentMatch.empty\n    let expr = parseExpr(stream)\n    if (stream.next) stream.err(\"Unexpected trailing text\")\n    let match = dfa(nfa(expr))\n    checkForDeadEnds(match, stream)\n    return match\n  }\n\n  // :: (NodeType) → ?ContentMatch\n  // Match a node type, returning a match after that node if\n  // successful.\n  matchType(type) {\n    for (let i = 0; i < this.next.length; i += 2)\n      if (this.next[i] == type) return this.next[i + 1]\n    return null\n  }\n\n  // :: (Fragment, ?number, ?number) → ?ContentMatch\n  // Try to match a fragment. Returns the resulting match when\n  // successful.\n  matchFragment(frag, start = 0, end = frag.childCount) {\n    let cur = this\n    for (let i = start; cur && i < end; i++)\n      cur = cur.matchType(frag.child(i).type)\n    return cur\n  }\n\n  get inlineContent() {\n    let first = this.next[0]\n    return first ? first.isInline : false\n  }\n\n  // :: ?NodeType\n  // Get the first matching node type at this match position that can\n  // be generated.\n  get defaultType() {\n    for (let i = 0; i < this.next.length; i += 2) {\n      let type = this.next[i]\n      if (!(type.isText || type.hasRequiredAttrs())) return type\n    }\n  }\n\n  compatible(other) {\n    for (let i = 0; i < this.next.length; i += 2)\n      for (let j = 0; j < other.next.length; j += 2)\n        if (this.next[i] == other.next[j]) return true\n    return false\n  }\n\n  // :: (Fragment, bool, ?number) → ?Fragment\n  // Try to match the given fragment, and if that fails, see if it can\n  // be made to match by inserting nodes in front of it. When\n  // successful, return a fragment of inserted nodes (which may be\n  // empty if nothing had to be inserted). When `toEnd` is true, only\n  // return a fragment if the resulting match goes to the end of the\n  // content expression.\n  fillBefore(after, toEnd = false, startIndex = 0) {\n    let seen = [this]\n    function search(match, types) {\n      let finished = match.matchFragment(after, startIndex)\n      if (finished && (!toEnd || finished.validEnd))\n        return Fragment.from(types.map(tp => tp.createAndFill()))\n\n      for (let i = 0; i < match.next.length; i += 2) {\n        let type = match.next[i], next = match.next[i + 1]\n        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n          seen.push(next)\n          let found = search(next, types.concat(type))\n          if (found) return found\n        }\n      }\n    }\n\n    return search(this, [])\n  }\n\n  // :: (NodeType) → ?[NodeType]\n  // Find a set of wrapping node types that would allow a node of the\n  // given type to appear at this position. The result may be empty\n  // (when it fits directly) and will be null when no such wrapping\n  // exists.\n  findWrapping(target) {\n    for (let i = 0; i < this.wrapCache.length; i += 2)\n      if (this.wrapCache[i] == target) return this.wrapCache[i + 1]\n    let computed = this.computeWrapping(target)\n    this.wrapCache.push(target, computed)\n    return computed\n  }\n\n  computeWrapping(target) {\n    let seen = Object.create(null), active = [{match: this, type: null, via: null}]\n    while (active.length) {\n      let current = active.shift(), match = current.match\n      if (match.matchType(target)) {\n        let result = []\n        for (let obj = current; obj.type; obj = obj.via)\n          result.push(obj.type)\n        return result.reverse()\n      }\n      for (let i = 0; i < match.next.length; i += 2) {\n        let type = match.next[i]\n        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {\n          active.push({match: type.contentMatch, type, via: current})\n          seen[type.name] = true\n        }\n      }\n    }\n  }\n\n  // :: number\n  // The number of outgoing edges this node has in the finite\n  // automaton that describes the content expression.\n  get edgeCount() {\n    return this.next.length >> 1\n  }\n\n  // :: (number) → {type: NodeType, next: ContentMatch}\n  // Get the _n_​th outgoing edge from this node in the finite\n  // automaton that describes the content expression.\n  edge(n) {\n    let i = n << 1\n    if (i >= this.next.length) throw new RangeError(`There's no ${n}th edge in this content match`)\n    return {type: this.next[i], next: this.next[i + 1]}\n  }\n\n  toString() {\n    let seen = []\n    function scan(m) {\n      seen.push(m)\n      for (let i = 1; i < m.next.length; i += 2)\n        if (seen.indexOf(m.next[i]) == -1) scan(m.next[i])\n    }\n    scan(this)\n    return seen.map((m, i) => {\n      let out = i + (m.validEnd ? \"*\" : \" \") + \" \"\n      for (let i = 0; i < m.next.length; i += 2)\n        out += (i ? \", \" : \"\") + m.next[i].name + \"->\" + seen.indexOf(m.next[i + 1])\n      return out\n    }).join(\"\\n\")\n  }\n}\n\nContentMatch.empty = new ContentMatch(true)\n\nclass TokenStream {\n  constructor(string, nodeTypes) {\n    this.string = string\n    this.nodeTypes = nodeTypes\n    this.inline = null\n    this.pos = 0\n    this.tokens = string.split(/\\s*(?=\\b|\\W|$)/)\n    if (this.tokens[this.tokens.length - 1] == \"\") this.tokens.pop()\n    if (this.tokens[0] == \"\") this.tokens.unshift()\n  }\n\n  get next() { return this.tokens[this.pos] }\n\n  eat(tok) { return this.next == tok && (this.pos++ || true) }\n\n  err(str) { throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\") }\n}\n\nfunction parseExpr(stream) {\n  let exprs = []\n  do { exprs.push(parseExprSeq(stream)) }\n  while (stream.eat(\"|\"))\n  return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs}\n}\n\nfunction parseExprSeq(stream) {\n  let exprs = []\n  do { exprs.push(parseExprSubscript(stream)) }\n  while (stream.next && stream.next != \")\" && stream.next != \"|\")\n  return exprs.length == 1 ? exprs[0] : {type: \"seq\", exprs}\n}\n\nfunction parseExprSubscript(stream) {\n  let expr = parseExprAtom(stream)\n  for (;;) {\n    if (stream.eat(\"+\"))\n      expr = {type: \"plus\", expr}\n    else if (stream.eat(\"*\"))\n      expr = {type: \"star\", expr}\n    else if (stream.eat(\"?\"))\n      expr = {type: \"opt\", expr}\n    else if (stream.eat(\"{\"))\n      expr = parseExprRange(stream, expr)\n    else break\n  }\n  return expr\n}\n\nfunction parseNum(stream) {\n  if (/\\D/.test(stream.next)) stream.err(\"Expected number, got '\" + stream.next + \"'\")\n  let result = Number(stream.next)\n  stream.pos++\n  return result\n}\n\nfunction parseExprRange(stream, expr) {\n  let min = parseNum(stream), max = min\n  if (stream.eat(\",\")) {\n    if (stream.next != \"}\") max = parseNum(stream)\n    else max = -1\n  }\n  if (!stream.eat(\"}\")) stream.err(\"Unclosed braced range\")\n  return {type: \"range\", min, max, expr}\n}\n\nfunction resolveName(stream, name) {\n  let types = stream.nodeTypes, type = types[name]\n  if (type) return [type]\n  let result = []\n  for (let typeName in types) {\n    let type = types[typeName]\n    if (type.groups.indexOf(name) > -1) result.push(type)\n  }\n  if (result.length == 0) stream.err(\"No node type or group '\" + name + \"' found\")\n  return result\n}\n\nfunction parseExprAtom(stream) {\n  if (stream.eat(\"(\")) {\n    let expr = parseExpr(stream)\n    if (!stream.eat(\")\")) stream.err(\"Missing closing paren\")\n    return expr\n  } else if (!/\\W/.test(stream.next)) {\n    let exprs = resolveName(stream, stream.next).map(type => {\n      if (stream.inline == null) stream.inline = type.isInline\n      else if (stream.inline != type.isInline) stream.err(\"Mixing inline and block content\")\n      return {type: \"name\", value: type}\n    })\n    stream.pos++\n    return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs}\n  } else {\n    stream.err(\"Unexpected token '\" + stream.next + \"'\")\n  }\n}\n\n// The code below helps compile a regular-expression-like language\n// into a deterministic finite automaton. For a good introduction to\n// these concepts, see https://swtch.com/~rsc/regexp/regexp1.html\n\n// : (Object) → [[{term: ?any, to: number}]]\n// Construct an NFA from an expression as returned by the parser. The\n// NFA is represented as an array of states, which are themselves\n// arrays of edges, which are `{term, to}` objects. The first state is\n// the entry state and the last node is the success state.\n//\n// Note that unlike typical NFAs, the edge ordering in this one is\n// significant, in that it is used to contruct filler content when\n// necessary.\nfunction nfa(expr) {\n  let nfa = [[]]\n  connect(compile(expr, 0), node())\n  return nfa\n\n  function node() { return nfa.push([]) - 1 }\n  function edge(from, to, term) {\n    let edge = {term, to}\n    nfa[from].push(edge)\n    return edge\n  }\n  function connect(edges, to) { edges.forEach(edge => edge.to = to) }\n\n  function compile(expr, from) {\n    if (expr.type == \"choice\") {\n      return expr.exprs.reduce((out, expr) => out.concat(compile(expr, from)), [])\n    } else if (expr.type == \"seq\") {\n      for (let i = 0;; i++) {\n        let next = compile(expr.exprs[i], from)\n        if (i == expr.exprs.length - 1) return next\n        connect(next, from = node())\n      }\n    } else if (expr.type == \"star\") {\n      let loop = node()\n      edge(from, loop)\n      connect(compile(expr.expr, loop), loop)\n      return [edge(loop)]\n    } else if (expr.type == \"plus\") {\n      let loop = node()\n      connect(compile(expr.expr, from), loop)\n      connect(compile(expr.expr, loop), loop)\n      return [edge(loop)]\n    } else if (expr.type == \"opt\") {\n      return [edge(from)].concat(compile(expr.expr, from))\n    } else if (expr.type == \"range\") {\n      let cur = from\n      for (let i = 0; i < expr.min; i++) {\n        let next = node()\n        connect(compile(expr.expr, cur), next)\n        cur = next\n      }\n      if (expr.max == -1) {\n        connect(compile(expr.expr, cur), cur)\n      } else {\n        for (let i = expr.min; i < expr.max; i++) {\n          let next = node()\n          edge(cur, next)\n          connect(compile(expr.expr, cur), next)\n          cur = next\n        }\n      }\n      return [edge(cur)]\n    } else if (expr.type == \"name\") {\n      return [edge(from, null, expr.value)]\n    }\n  }\n}\n\nfunction cmp(a, b) { return b - a }\n\n// Get the set of nodes reachable by null edges from `node`. Omit\n// nodes with only a single null-out-edge, since they may lead to\n// needless duplicated nodes.\nfunction nullFrom(nfa, node) {\n  let result = []\n  scan(node)\n  return result.sort(cmp)\n\n  function scan(node) {\n    let edges = nfa[node]\n    if (edges.length == 1 && !edges[0].term) return scan(edges[0].to)\n    result.push(node)\n    for (let i = 0; i < edges.length; i++) {\n      let {term, to} = edges[i]\n      if (!term && result.indexOf(to) == -1) scan(to)\n    }\n  }\n}\n\n// : ([[{term: ?any, to: number}]]) → ContentMatch\n// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set\n// of state objects (`ContentMatch` instances) with transitions\n// between them.\nfunction dfa(nfa) {\n  let labeled = Object.create(null)\n  return explore(nullFrom(nfa, 0))\n\n  function explore(states) {\n    let out = []\n    states.forEach(node => {\n      nfa[node].forEach(({term, to}) => {\n        if (!term) return\n        let known = out.indexOf(term), set = known > -1 && out[known + 1]\n        nullFrom(nfa, to).forEach(node => {\n          if (!set) out.push(term, set = [])\n          if (set.indexOf(node) == -1) set.push(node)\n        })\n      })\n    })\n    let state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1)\n    for (let i = 0; i < out.length; i += 2) {\n      let states = out[i + 1].sort(cmp)\n      state.next.push(out[i], labeled[states.join(\",\")] || explore(states))\n    }\n    return state\n  }\n}\n\nfunction checkForDeadEnds(match, stream) {\n  for (let i = 0, work = [match]; i < work.length; i++) {\n    let state = work[i], dead = !state.validEnd, nodes = []\n    for (let j = 0; j < state.next.length; j += 2) {\n      let node = state.next[j], next = state.next[j + 1]\n      nodes.push(node.name)\n      if (dead && !(node.isText || node.hasRequiredAttrs())) dead = false\n      if (work.indexOf(next) == -1) work.push(next)\n    }\n    if (dead) stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\")\n  }\n}\n","import OrderedMap from \"orderedmap\"\n\nimport {Node, TextNode} from \"./node\"\nimport {Fragment} from \"./fragment\"\nimport {Mark} from \"./mark\"\nimport {ContentMatch} from \"./content\"\n\n// For node types where all attrs have a default value (or which don't\n// have any attributes), build up a single reusable default attribute\n// object, and use it for all nodes that don't specify specific\n// attributes.\nfunction defaultAttrs(attrs) {\n  let defaults = Object.create(null)\n  for (let attrName in attrs) {\n    let attr = attrs[attrName]\n    if (!attr.hasDefault) return null\n    defaults[attrName] = attr.default\n  }\n  return defaults\n}\n\nfunction computeAttrs(attrs, value) {\n  let built = Object.create(null)\n  for (let name in attrs) {\n    let given = value && value[name]\n    if (given === undefined) {\n      let attr = attrs[name]\n      if (attr.hasDefault) given = attr.default\n      else throw new RangeError(\"No value supplied for attribute \" + name)\n    }\n    built[name] = given\n  }\n  return built\n}\n\nfunction initAttrs(attrs) {\n  let result = Object.create(null)\n  if (attrs) for (let name in attrs) result[name] = new Attribute(attrs[name])\n  return result\n}\n\n// ::- Node types are objects allocated once per `Schema` and used to\n// [tag](#model.Node.type) `Node` instances. They contain information\n// about the node type, such as its name and what kind of node it\n// represents.\nexport class NodeType {\n  constructor(name, schema, spec) {\n    // :: string\n    // The name the node type has in this schema.\n    this.name = name\n\n    // :: Schema\n    // A link back to the `Schema` the node type belongs to.\n    this.schema = schema\n\n    // :: NodeSpec\n    // The spec that this type is based on\n    this.spec = spec\n\n    this.groups = spec.group ? spec.group.split(\" \") : []\n    this.attrs = initAttrs(spec.attrs)\n\n    this.defaultAttrs = defaultAttrs(this.attrs)\n\n    // :: ContentMatch\n    // The starting match of the node type's content expression.\n    this.contentMatch = null\n\n    // : ?[MarkType]\n    // The set of marks allowed in this node. `null` means all marks\n    // are allowed.\n    this.markSet = null\n\n    // :: bool\n    // True if this node type has inline content.\n    this.inlineContent = null\n\n    // :: bool\n    // True if this is a block type\n    this.isBlock = !(spec.inline || name == \"text\")\n\n    // :: bool\n    // True if this is the text node type.\n    this.isText = name == \"text\"\n  }\n\n  // :: bool\n  // True if this is an inline type.\n  get isInline() { return !this.isBlock }\n\n  // :: bool\n  // True if this is a textblock type, a block that contains inline\n  // content.\n  get isTextblock() { return this.isBlock && this.inlineContent }\n\n  // :: bool\n  // True for node types that allow no content.\n  get isLeaf() { return this.contentMatch == ContentMatch.empty }\n\n  // :: bool\n  // True when this node is an atom, i.e. when it does not have\n  // directly editable content.\n  get isAtom() { return this.isLeaf || this.spec.atom }\n\n  // :: () → bool\n  // Tells you whether this node type has any required attributes.\n  hasRequiredAttrs() {\n    for (let n in this.attrs) if (this.attrs[n].isRequired) return true\n    return false\n  }\n\n  compatibleContent(other) {\n    return this == other || this.contentMatch.compatible(other.contentMatch)\n  }\n\n  computeAttrs(attrs) {\n    if (!attrs && this.defaultAttrs) return this.defaultAttrs\n    else return computeAttrs(this.attrs, attrs)\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Create a `Node` of this type. The given attributes are\n  // checked and defaulted (you can pass `null` to use the type's\n  // defaults entirely, if no required attributes exist). `content`\n  // may be a `Fragment`, a node, an array of nodes, or\n  // `null`. Similarly `marks` may be `null` to default to the empty\n  // set of marks.\n  create(attrs, content, marks) {\n    if (this.isText) throw new Error(\"NodeType.create can't construct text nodes\")\n    return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks))\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Like [`create`](#model.NodeType.create), but check the given content\n  // against the node type's content restrictions, and throw an error\n  // if it doesn't match.\n  createChecked(attrs, content, marks) {\n    content = Fragment.from(content)\n    if (!this.validContent(content))\n      throw new RangeError(\"Invalid content for node \" + this.name)\n    return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks))\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → ?Node\n  // Like [`create`](#model.NodeType.create), but see if it is necessary to\n  // add nodes to the start or end of the given fragment to make it\n  // fit the node. If no fitting wrapping can be found, return null.\n  // Note that, due to the fact that required nodes can always be\n  // created, this will always succeed if you pass null or\n  // `Fragment.empty` as content.\n  createAndFill(attrs, content, marks) {\n    attrs = this.computeAttrs(attrs)\n    content = Fragment.from(content)\n    if (content.size) {\n      let before = this.contentMatch.fillBefore(content)\n      if (!before) return null\n      content = before.append(content)\n    }\n    let after = this.contentMatch.matchFragment(content).fillBefore(Fragment.empty, true)\n    if (!after) return null\n    return new Node(this, attrs, content.append(after), Mark.setFrom(marks))\n  }\n\n  // :: (Fragment) → bool\n  // Returns true if the given fragment is valid content for this node\n  // type with the given attributes.\n  validContent(content) {\n    let result = this.contentMatch.matchFragment(content)\n    if (!result || !result.validEnd) return false\n    for (let i = 0; i < content.childCount; i++)\n      if (!this.allowsMarks(content.child(i).marks)) return false\n    return true\n  }\n\n  // :: (MarkType) → bool\n  // Check whether the given mark type is allowed in this node.\n  allowsMarkType(markType) {\n    return this.markSet == null || this.markSet.indexOf(markType) > -1\n  }\n\n  // :: ([Mark]) → bool\n  // Test whether the given set of marks are allowed in this node.\n  allowsMarks(marks) {\n    if (this.markSet == null) return true\n    for (let i = 0; i < marks.length; i++) if (!this.allowsMarkType(marks[i].type)) return false\n    return true\n  }\n\n  // :: ([Mark]) → [Mark]\n  // Removes the marks that are not allowed in this node from the given set.\n  allowedMarks(marks) {\n    if (this.markSet == null) return marks\n    let copy\n    for (let i = 0; i < marks.length; i++) {\n      if (!this.allowsMarkType(marks[i].type)) {\n        if (!copy) copy = marks.slice(0, i)\n      } else if (copy) {\n        copy.push(marks[i])\n      }\n    }\n    return !copy ? marks : copy.length ? copy : Mark.empty\n  }\n\n  static compile(nodes, schema) {\n    let result = Object.create(null)\n    nodes.forEach((name, spec) => result[name] = new NodeType(name, schema, spec))\n\n    let topType = schema.spec.topNode || \"doc\"\n    if (!result[topType]) throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\")\n    if (!result.text) throw new RangeError(\"Every schema needs a 'text' type\")\n    for (let _ in result.text.attrs) throw new RangeError(\"The text node type should not have attributes\")\n\n    return result\n  }\n}\n\n// Attribute descriptors\n\nclass Attribute {\n  constructor(options) {\n    this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\")\n    this.default = options.default\n  }\n\n  get isRequired() {\n    return !this.hasDefault\n  }\n}\n\n// Marks\n\n// ::- Like nodes, marks (which are associated with nodes to signify\n// things like emphasis or being part of a link) are\n// [tagged](#model.Mark.type) with type objects, which are\n// instantiated once per `Schema`.\nexport class MarkType {\n  constructor(name, rank, schema, spec) {\n    // :: string\n    // The name of the mark type.\n    this.name = name\n\n    // :: Schema\n    // The schema that this mark type instance is part of.\n    this.schema = schema\n\n    // :: MarkSpec\n    // The spec on which the type is based.\n    this.spec = spec\n\n    this.attrs = initAttrs(spec.attrs)\n\n    this.rank = rank\n    this.excluded = null\n    let defaults = defaultAttrs(this.attrs)\n    this.instance = defaults && new Mark(this, defaults)\n  }\n\n  // :: (?Object) → Mark\n  // Create a mark of this type. `attrs` may be `null` or an object\n  // containing only some of the mark's attributes. The others, if\n  // they have defaults, will be added.\n  create(attrs) {\n    if (!attrs && this.instance) return this.instance\n    return new Mark(this, computeAttrs(this.attrs, attrs))\n  }\n\n  static compile(marks, schema) {\n    let result = Object.create(null), rank = 0\n    marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema, spec))\n    return result\n  }\n\n  // :: ([Mark]) → [Mark]\n  // When there is a mark of this type in the given set, a new set\n  // without it is returned. Otherwise, the input set is returned.\n  removeFromSet(set) {\n    for (var i = 0; i < set.length; i++)\n      if (set[i].type == this)\n        return set.slice(0, i).concat(set.slice(i + 1))\n    return set\n  }\n\n  // :: ([Mark]) → ?Mark\n  // Tests whether there is a mark of this type in the given set.\n  isInSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (set[i].type == this) return set[i]\n  }\n\n  // :: (MarkType) → bool\n  // Queries whether a given mark type is\n  // [excluded](#model.MarkSpec.excludes) by this one.\n  excludes(other) {\n    return this.excluded.indexOf(other) > -1\n  }\n}\n\n// SchemaSpec:: interface\n// An object describing a schema, as passed to the [`Schema`](#model.Schema)\n// constructor.\n//\n//   nodes:: union<Object<NodeSpec>, OrderedMap<NodeSpec>>\n//   The node types in this schema. Maps names to\n//   [`NodeSpec`](#model.NodeSpec) objects that describe the node type\n//   associated with that name. Their order is significant—it\n//   determines which [parse rules](#model.NodeSpec.parseDOM) take\n//   precedence by default, and which nodes come first in a given\n//   [group](#model.NodeSpec.group).\n//\n//   marks:: ?union<Object<MarkSpec>, OrderedMap<MarkSpec>>\n//   The mark types that exist in this schema. The order in which they\n//   are provided determines the order in which [mark\n//   sets](#model.Mark.addToSet) are sorted and in which [parse\n//   rules](#model.MarkSpec.parseDOM) are tried.\n//\n//   topNode:: ?string\n//   The name of the default top-level node for the schema. Defaults\n//   to `\"doc\"`.\n\n// NodeSpec:: interface\n//\n//   content:: ?string\n//   The content expression for this node, as described in the [schema\n//   guide](/docs/guide/#schema.content_expressions). When not given,\n//   the node does not allow any content.\n//\n//   marks:: ?string\n//   The marks that are allowed inside of this node. May be a\n//   space-separated string referring to mark names or groups, `\"_\"`\n//   to explicitly allow all marks, or `\"\"` to disallow marks. When\n//   not given, nodes with inline content default to allowing all\n//   marks, other nodes default to not allowing marks.\n//\n//   group:: ?string\n//   The group or space-separated groups to which this node belongs,\n//   which can be referred to in the content expressions for the\n//   schema.\n//\n//   inline:: ?bool\n//   Should be set to true for inline nodes. (Implied for text nodes.)\n//\n//   atom:: ?bool\n//   Can be set to true to indicate that, though this isn't a [leaf\n//   node](#model.NodeType.isLeaf), it doesn't have directly editable\n//   content and should be treated as a single unit in the view.\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that nodes of this type get.\n//\n//   selectable:: ?bool\n//   Controls whether nodes of this type can be selected as a [node\n//   selection](#state.NodeSelection). Defaults to true for non-text\n//   nodes.\n//\n//   draggable:: ?bool\n//   Determines whether nodes of this type can be dragged without\n//   being selected. Defaults to false.\n//\n//   code:: ?bool\n//   Can be used to indicate that this node contains code, which\n//   causes some commands to behave differently.\n//\n//   defining:: ?bool\n//   Determines whether this node is considered an important parent\n//   node during replace operations (such as paste). Non-defining (the\n//   default) nodes get dropped when their entire content is replaced,\n//   whereas defining nodes persist and wrap the inserted content.\n//   Likewise, in _inserted_ content the defining parents of the\n//   content are preserved when possible. Typically,\n//   non-default-paragraph textblock types, and possibly list items,\n//   are marked as defining.\n//\n//   isolating:: ?bool\n//   When enabled (default is false), the sides of nodes of this type\n//   count as boundaries that regular editing operations, like\n//   backspacing or lifting, won't cross. An example of a node that\n//   should probably have this enabled is a table cell.\n//\n//   toDOM:: ?(node: Node) → DOMOutputSpec\n//   Defines the default way a node of this type should be serialized\n//   to DOM/HTML (as used by\n//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)).\n//   Should return a DOM node or an [array\n//   structure](#model.DOMOutputSpec) that describes one, with an\n//   optional number zero (“hole”) in it to indicate where the node's\n//   content should be inserted.\n//\n//   For text nodes, the default is to create a text DOM node. Though\n//   it is possible to create a serializer where text is rendered\n//   differently, this is not supported inside the editor, so you\n//   shouldn't override that in your text node spec.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this node, which can be\n//   used by [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) to\n//   automatically derive a parser. The `node` field in the rules is\n//   implied (the name of this node will be filled in automatically).\n//   If you supply your own parser, you do not need to also specify\n//   parsing rules in your schema.\n//\n//   toDebugString:: ?(node: Node) -> string\n//   Defines the default way a node of this type should be serialized\n//   to a string representation for debugging (e.g. in error messages).\n\n// MarkSpec:: interface\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that marks of this type get.\n//\n//   inclusive:: ?bool\n//   Whether this mark should be active when the cursor is positioned\n//   at its end (or at its start when that is also the start of the\n//   parent node). Defaults to true.\n//\n//   excludes:: ?string\n//   Determines which other marks this mark can coexist with. Should\n//   be a space-separated strings naming other marks or groups of marks.\n//   When a mark is [added](#model.Mark.addToSet) to a set, all marks\n//   that it excludes are removed in the process. If the set contains\n//   any mark that excludes the new mark but is not, itself, excluded\n//   by the new mark, the mark can not be added an the set. You can\n//   use the value `\"_\"` to indicate that the mark excludes all\n//   marks in the schema.\n//\n//   Defaults to only being exclusive with marks of the same type. You\n//   can set it to an empty string (or any string not containing the\n//   mark's own name) to allow multiple marks of a given type to\n//   coexist (as long as they have different attributes).\n//\n//   group:: ?string\n//   The group or space-separated groups to which this mark belongs.\n//\n//   spanning:: ?bool\n//   Determines whether marks of this type can span multiple adjacent\n//   nodes when serialized to DOM/HTML. Defaults to true.\n//\n//   toDOM:: ?(mark: Mark, inline: bool) → DOMOutputSpec\n//   Defines the default way marks of this type should be serialized\n//   to DOM/HTML. When the resulting spec contains a hole, that is\n//   where the marked content is placed. Otherwise, it is appended to\n//   the top node.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this mark (see the\n//   corresponding [node spec field](#model.NodeSpec.parseDOM)). The\n//   `mark` field in the rules is implied.\n\n// AttributeSpec:: interface\n//\n// Used to [define](#model.NodeSpec.attrs) attributes on nodes or\n// marks.\n//\n//   default:: ?any\n//   The default value for this attribute, to use when no explicit\n//   value is provided. Attributes that have no default must be\n//   provided whenever a node or mark of a type that has them is\n//   created.\n\n// ::- A document schema. Holds [node](#model.NodeType) and [mark\n// type](#model.MarkType) objects for the nodes and marks that may\n// occur in conforming documents, and provides functionality for\n// creating and deserializing such documents.\nexport class Schema {\n  // :: (SchemaSpec)\n  // Construct a schema from a schema [specification](#model.SchemaSpec).\n  constructor(spec) {\n    // :: SchemaSpec\n    // The [spec](#model.SchemaSpec) on which the schema is based,\n    // with the added guarantee that its `nodes` and `marks`\n    // properties are\n    // [`OrderedMap`](https://github.com/marijnh/orderedmap) instances\n    // (not raw objects).\n    this.spec = {}\n    for (let prop in spec) this.spec[prop] = spec[prop]\n    this.spec.nodes = OrderedMap.from(spec.nodes)\n    this.spec.marks = OrderedMap.from(spec.marks)\n\n    // :: Object<NodeType>\n    // An object mapping the schema's node names to node type objects.\n    this.nodes = NodeType.compile(this.spec.nodes, this)\n\n    // :: Object<MarkType>\n    // A map from mark names to mark type objects.\n    this.marks = MarkType.compile(this.spec.marks, this)\n\n    let contentExprCache = Object.create(null)\n    for (let prop in this.nodes) {\n      if (prop in this.marks)\n        throw new RangeError(prop + \" can not be both a node and a mark\")\n      let type = this.nodes[prop], contentExpr = type.spec.content || \"\", markExpr = type.spec.marks\n      type.contentMatch = contentExprCache[contentExpr] ||\n        (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes))\n      type.inlineContent = type.contentMatch.inlineContent\n      type.markSet = markExpr == \"_\" ? null :\n        markExpr ? gatherMarks(this, markExpr.split(\" \")) :\n        markExpr == \"\" || !type.inlineContent ? [] : null\n    }\n    for (let prop in this.marks) {\n      let type = this.marks[prop], excl = type.spec.excludes\n      type.excluded = excl == null ? [type] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"))\n    }\n\n    this.nodeFromJSON = this.nodeFromJSON.bind(this)\n    this.markFromJSON = this.markFromJSON.bind(this)\n\n    // :: NodeType\n    // The type of the [default top node](#model.SchemaSpec.topNode)\n    // for this schema.\n    this.topNodeType = this.nodes[this.spec.topNode || \"doc\"]\n\n    // :: Object\n    // An object for storing whatever values modules may want to\n    // compute and cache per schema. (If you want to store something\n    // in it, try to use property names unlikely to clash.)\n    this.cached = Object.create(null)\n    this.cached.wrappings = Object.create(null)\n  }\n\n  // :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Create a node in this schema. The `type` may be a string or a\n  // `NodeType` instance. Attributes will be extended\n  // with defaults, `content` may be a `Fragment`,\n  // `null`, a `Node`, or an array of nodes.\n  node(type, attrs, content, marks) {\n    if (typeof type == \"string\")\n      type = this.nodeType(type)\n    else if (!(type instanceof NodeType))\n      throw new RangeError(\"Invalid node type: \" + type)\n    else if (type.schema != this)\n      throw new RangeError(\"Node type from different schema used (\" + type.name + \")\")\n\n    return type.createChecked(attrs, content, marks)\n  }\n\n  // :: (string, ?[Mark]) → Node\n  // Create a text node in the schema. Empty text nodes are not\n  // allowed.\n  text(text, marks) {\n    let type = this.nodes.text\n    return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks))\n  }\n\n  // :: (union<string, MarkType>, ?Object) → Mark\n  // Create a mark with the given type and attributes.\n  mark(type, attrs) {\n    if (typeof type == \"string\") type = this.marks[type]\n    return type.create(attrs)\n  }\n\n  // :: (Object) → Node\n  // Deserialize a node from its JSON representation. This method is\n  // bound.\n  nodeFromJSON(json) {\n    return Node.fromJSON(this, json)\n  }\n\n  // :: (Object) → Mark\n  // Deserialize a mark from its JSON representation. This method is\n  // bound.\n  markFromJSON(json) {\n    return Mark.fromJSON(this, json)\n  }\n\n  nodeType(name) {\n    let found = this.nodes[name]\n    if (!found) throw new RangeError(\"Unknown node type: \" + name)\n    return found\n  }\n}\n\nfunction gatherMarks(schema, marks) {\n  let found = []\n  for (let i = 0; i < marks.length; i++) {\n    let name = marks[i], mark = schema.marks[name], ok = mark\n    if (mark) {\n      found.push(mark)\n    } else {\n      for (let prop in schema.marks) {\n        let mark = schema.marks[prop]\n        if (name == \"_\" || (mark.spec.group && mark.spec.group.split(\" \").indexOf(name) > -1))\n          found.push(ok = mark)\n      }\n    }\n    if (!ok) throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\")\n  }\n  return found\n}\n","import {Fragment} from \"./fragment\"\nimport {Slice} from \"./replace\"\nimport {Mark} from \"./mark\"\n\n// ParseOptions:: interface\n// These are the options recognized by the\n// [`parse`](#model.DOMParser.parse) and\n// [`parseSlice`](#model.DOMParser.parseSlice) methods.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   By default, whitespace is collapsed as per HTML's rules. Pass\n//   `true` to preserve whitespace, but normalize newlines to\n//   spaces, and `\"full\"` to preserve whitespace entirely.\n//\n//   findPositions:: ?[{node: dom.Node, offset: number}]\n//   When given, the parser will, beside parsing the content,\n//   record the document positions of the given DOM positions. It\n//   will do so by writing to the objects, adding a `pos` property\n//   that holds the document position. DOM positions that are not\n//   in the parsed content will not be written to.\n//\n//   from:: ?number\n//   The child node index to start parsing from.\n//\n//   to:: ?number\n//   The child node index to stop parsing at.\n//\n//   topNode:: ?Node\n//   By default, the content is parsed into the schema's default\n//   [top node type](#model.Schema.topNodeType). You can pass this\n//   option to use the type and attributes from a different node\n//   as the top container.\n//\n//   topMatch:: ?ContentMatch\n//   Provide the starting content match that content parsed into the\n//   top node is matched against.\n//\n//   context:: ?ResolvedPos\n//   A set of additional nodes to count as\n//   [context](#model.ParseRule.context) when parsing, above the\n//   given [top node](#model.ParseOptions.topNode).\n\n// ParseRule:: interface\n// A value that describes how to parse a given DOM node or inline\n// style as a ProseMirror node or mark.\n//\n//   tag:: ?string\n//   A CSS selector describing the kind of DOM elements to match. A\n//   single rule should have _either_ a `tag` or a `style` property.\n//\n//   namespace:: ?string\n//   The namespace to match. This should be used with `tag`.\n//   Nodes are only matched when the namespace matches or this property\n//   is null.\n//\n//   style:: ?string\n//   A CSS property name to match. When given, this rule matches\n//   inline styles that list that property. May also have the form\n//   `\"property=value\"`, in which case the rule only matches if the\n//   propery's value exactly matches the given value. (For more\n//   complicated filters, use [`getAttrs`](#model.ParseRule.getAttrs)\n//   and return false to indicate that the match failed.)\n//\n//   priority:: ?number\n//   Can be used to change the order in which the parse rules in a\n//   schema are tried. Those with higher priority come first. Rules\n//   without a priority are counted as having priority 50. This\n//   property is only meaningful in a schema—when directly\n//   constructing a parser, the order of the rule array is used.\n//\n//   context:: ?string\n//   When given, restricts this rule to only match when the current\n//   context—the parent nodes into which the content is being\n//   parsed—matches this expression. Should contain one or more node\n//   names or node group names followed by single or double slashes.\n//   For example `\"paragraph/\"` means the rule only matches when the\n//   parent node is a paragraph, `\"blockquote/paragraph/\"` restricts\n//   it to be in a paragraph that is inside a blockquote, and\n//   `\"section//\"` matches any position inside a section—a double\n//   slash matches any sequence of ancestor nodes. To allow multiple\n//   different contexts, they can be separated by a pipe (`|`)\n//   character, as in `\"blockquote/|list_item/\"`.\n//\n//   node:: ?string\n//   The name of the node type to create when this rule matches. Only\n//   valid for rules with a `tag` property, not for style rules. Each\n//   rule should have one of a `node`, `mark`, or `ignore` property\n//   (except when it appears in a [node](#model.NodeSpec.parseDOM) or\n//   [mark spec](#model.MarkSpec.parseDOM), in which case the `node`\n//   or `mark` property will be derived from its position).\n//\n//   mark:: ?string\n//   The name of the mark type to wrap the matched content in.\n//\n//   ignore:: ?bool\n//   When true, ignore content that matches this rule.\n//\n//   closeParent:: ?bool\n//   When true, finding an element that matches this rule will close\n//   the current node.\n//\n//   skip:: ?bool\n//   When true, ignore the node that matches this rule, but do parse\n//   its content.\n//\n//   attrs:: ?Object\n//   Attributes for the node or mark created by this rule. When\n//   `getAttrs` is provided, it takes precedence.\n//\n//   getAttrs:: ?(union<dom.Node, string>) → ?union<Object, false>\n//   A function used to compute the attributes for the node or mark\n//   created by this rule. Can also be used to describe further\n//   conditions the DOM element or style must match. When it returns\n//   `false`, the rule won't match. When it returns null or undefined,\n//   that is interpreted as an empty/default set of attributes.\n//\n//   Called with a DOM Element for `tag` rules, and with a string (the\n//   style's value) for `style` rules.\n//\n//   contentElement:: ?union<string, (dom.Node) → dom.Node>\n//   For `tag` rules that produce non-leaf nodes or marks, by default\n//   the content of the DOM element is parsed as content of the mark\n//   or node. If the child nodes are in a descendent node, this may be\n//   a CSS selector string that the parser must use to find the actual\n//   content element, or a function that returns the actual content\n//   element to the parser.\n//\n//   getContent:: ?(dom.Node, schema: Schema) → Fragment\n//   Can be used to override the content of a matched node. When\n//   present, instead of parsing the node's child nodes, the result of\n//   this function is used.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   Controls whether whitespace should be preserved when parsing the\n//   content inside the matched element. `false` means whitespace may\n//   be collapsed, `true` means that whitespace should be preserved\n//   but newlines normalized to spaces, and `\"full\"` means that\n//   newlines should also be preserved.\n\n// ::- A DOM parser represents a strategy for parsing DOM content into\n// a ProseMirror document conforming to a given schema. Its behavior\n// is defined by an array of [rules](#model.ParseRule).\nexport class DOMParser {\n  // :: (Schema, [ParseRule])\n  // Create a parser that targets the given schema, using the given\n  // parsing rules.\n  constructor(schema, rules) {\n    // :: Schema\n    // The schema into which the parser parses.\n    this.schema = schema\n    // :: [ParseRule]\n    // The set of [parse rules](#model.ParseRule) that the parser\n    // uses, in order of precedence.\n    this.rules = rules\n    this.tags = []\n    this.styles = []\n\n    rules.forEach(rule => {\n      if (rule.tag) this.tags.push(rule)\n      else if (rule.style) this.styles.push(rule)\n    })\n\n    // Only normalize list elements when lists in the schema can't directly contain themselves\n    this.normalizeLists = !this.tags.some(r => {\n      if (!/^(ul|ol)\\b/.test(r.tag) || !r.node) return false\n      let node = schema.nodes[r.node]\n      return node.contentMatch.matchType(node)\n    })\n  }\n\n  // :: (dom.Node, ?ParseOptions) → Node\n  // Parse a document from the content of a DOM node.\n  parse(dom, options = {}) {\n    let context = new ParseContext(this, options, false)\n    context.addAll(dom, null, options.from, options.to)\n    return context.finish()\n  }\n\n  // :: (dom.Node, ?ParseOptions) → Slice\n  // Parses the content of the given DOM node, like\n  // [`parse`](#model.DOMParser.parse), and takes the same set of\n  // options. But unlike that method, which produces a whole node,\n  // this one returns a slice that is open at the sides, meaning that\n  // the schema constraints aren't applied to the start of nodes to\n  // the left of the input and the end of nodes at the end.\n  parseSlice(dom, options = {}) {\n    let context = new ParseContext(this, options, true)\n    context.addAll(dom, null, options.from, options.to)\n    return Slice.maxOpen(context.finish())\n  }\n\n  matchTag(dom, context) {\n    for (let i = 0; i < this.tags.length; i++) {\n      let rule = this.tags[i]\n      if (matches(dom, rule.tag) &&\n          (rule.namespace === undefined || dom.namespaceURI == rule.namespace) &&\n          (!rule.context || context.matchesContext(rule.context))) {\n        if (rule.getAttrs) {\n          let result = rule.getAttrs(dom)\n          if (result === false) continue\n          rule.attrs = result\n        }\n        return rule\n      }\n    }\n  }\n\n  matchStyle(prop, value, context) {\n    for (let i = 0; i < this.styles.length; i++) {\n      let rule = this.styles[i]\n      if (rule.style.indexOf(prop) != 0 ||\n          rule.context && !context.matchesContext(rule.context) ||\n          // Test that the style string either precisely matches the prop,\n          // or has an '=' sign after the prop, followed by the given\n          // value.\n          rule.style.length > prop.length &&\n          (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value))\n        continue\n      if (rule.getAttrs) {\n        let result = rule.getAttrs(value)\n        if (result === false) continue\n        rule.attrs = result\n      }\n      return rule\n    }\n  }\n\n  // : (Schema) → [ParseRule]\n  static schemaRules(schema) {\n    let result = []\n    function insert(rule) {\n      let priority = rule.priority == null ? 50 : rule.priority, i = 0\n      for (; i < result.length; i++) {\n        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority\n        if (nextPriority < priority) break\n      }\n      result.splice(i, 0, rule)\n    }\n\n    for (let name in schema.marks) {\n      let rules = schema.marks[name].spec.parseDOM\n      if (rules) rules.forEach(rule => {\n        insert(rule = copy(rule))\n        rule.mark = name\n      })\n    }\n    for (let name in schema.nodes) {\n      let rules = schema.nodes[name].spec.parseDOM\n      if (rules) rules.forEach(rule => {\n        insert(rule = copy(rule))\n        rule.node = name\n      })\n    }\n    return result\n  }\n\n  // :: (Schema) → DOMParser\n  // Construct a DOM parser using the parsing rules listed in a\n  // schema's [node specs](#model.NodeSpec.parseDOM), reordered by\n  // [priority](#model.ParseRule.priority).\n  static fromSchema(schema) {\n    return schema.cached.domParser ||\n      (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)))\n  }\n}\n\n// : Object<bool> The block-level tags in HTML5\nconst blockTags = {\n  address: true, article: true, aside: true, blockquote: true, canvas: true,\n  dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,\n  footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,\n  h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,\n  output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true\n}\n\n// : Object<bool> The tags that we normally ignore.\nconst ignoreTags = {\n  head: true, noscript: true, object: true, script: true, style: true, title: true\n}\n\n// : Object<bool> List tags.\nconst listTags = {ol: true, ul: true}\n\n// Using a bitfield for node context options\nconst OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4\n\nfunction wsOptionsFor(preserveWhitespace) {\n  return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0)\n}\n\nclass NodeContext {\n  constructor(type, attrs, marks, pendingMarks, solid, match, options) {\n    this.type = type\n    this.attrs = attrs\n    this.solid = solid\n    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch)\n    this.options = options\n    this.content = []\n    // Marks applied to this node itself\n    this.marks = marks\n    // Marks applied to its children\n    this.activeMarks = Mark.none\n    // Marks that can't apply here, but will be used in children if possible\n    this.pendingMarks = pendingMarks\n  }\n\n  findWrapping(node) {\n    if (!this.match) {\n      if (!this.type) return []\n      let fill = this.type.contentMatch.fillBefore(Fragment.from(node))\n      if (fill) {\n        this.match = this.type.contentMatch.matchFragment(fill)\n      } else {\n        let start = this.type.contentMatch, wrap\n        if (wrap = start.findWrapping(node.type)) {\n          this.match = start\n          return wrap\n        } else {\n          return null\n        }\n      }\n    }\n    return this.match.findWrapping(node.type)\n  }\n\n  finish(openEnd) {\n    if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace\n      let last = this.content[this.content.length - 1], m\n      if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n        if (last.text.length == m[0].length) this.content.pop()\n        else this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length))\n      }\n    }\n    let content = Fragment.from(this.content)\n    if (!openEnd && this.match)\n      content = content.append(this.match.fillBefore(Fragment.empty, true))\n    return this.type ? this.type.create(this.attrs, content, this.marks) : content\n  }\n\n  applyPending(nextType) {\n    for (let i = 0, pending = this.pendingMarks; i < pending.length; i++) {\n      let mark = pending[i]\n      if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) &&\n          !mark.isInSet(this.activeMarks)) {\n        this.activeMarks = mark.addToSet(this.activeMarks)\n        this.pendingMarks = mark.removeFromSet(this.pendingMarks)\n      }\n    }\n  }\n}\n\nclass ParseContext {\n  // : (DOMParser, Object)\n  constructor(parser, options, open) {\n    // : DOMParser The parser we are using.\n    this.parser = parser\n    // : Object The options passed to this parse.\n    this.options = options\n    this.isOpen = open\n    let topNode = options.topNode, topContext\n    let topOptions = wsOptionsFor(options.preserveWhitespace) | (open ? OPT_OPEN_LEFT : 0)\n    if (topNode)\n      topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true,\n                                   options.topMatch || topNode.type.contentMatch, topOptions)\n    else if (open)\n      topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions)\n    else\n      topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions)\n    this.nodes = [topContext]\n    // : [Mark] The current set of marks\n    this.open = 0\n    this.find = options.findPositions\n    this.needsBlock = false\n  }\n\n  get top() {\n    return this.nodes[this.open]\n  }\n\n  // : (dom.Node)\n  // Add a DOM node to the content. Text is inserted as text node,\n  // otherwise, the node is passed to `addElement` or, if it has a\n  // `style` attribute, `addElementWithStyles`.\n  addDOM(dom) {\n    if (dom.nodeType == 3) {\n      this.addTextNode(dom)\n    } else if (dom.nodeType == 1) {\n      let style = dom.getAttribute(\"style\")\n      let marks = style ? this.readStyles(parseStyles(style)) : null, top = this.top\n      if (marks != null) for (let i = 0; i < marks.length; i++) this.addPendingMark(marks[i])\n      this.addElement(dom)\n      if (marks != null) for (let i = 0; i < marks.length; i++) this.removePendingMark(marks[i], top)\n    }\n  }\n\n  addTextNode(dom) {\n    let value = dom.nodeValue\n    let top = this.top\n    if ((top.type ? top.type.inlineContent : top.content.length && top.content[0].isInline) || /[^ \\t\\r\\n\\u000c]/.test(value)) {\n      if (!(top.options & OPT_PRESERVE_WS)) {\n        value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \")\n        // If this starts with whitespace, and there is no node before it, or\n        // a hard break, or a text node that ends with whitespace, strip the\n        // leading space.\n        if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n          let nodeBefore = top.content[top.content.length - 1]\n          let domNodeBefore = dom.previousSibling\n          if (!nodeBefore ||\n              (domNodeBefore && domNodeBefore.nodeName == 'BR') ||\n              (nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text)))\n            value = value.slice(1)\n        }\n      } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {\n        value = value.replace(/\\r?\\n|\\r/g, \" \")\n      }\n      if (value) this.insertNode(this.parser.schema.text(value))\n      this.findInText(dom)\n    } else {\n      this.findInside(dom)\n    }\n  }\n\n  // : (dom.Element)\n  // Try to find a handler for the given tag and use that to parse. If\n  // none is found, the element's content nodes are added directly.\n  addElement(dom) {\n    let name = dom.nodeName.toLowerCase()\n    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) normalizeList(dom)\n    let rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) || this.parser.matchTag(dom, this)\n    if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n      this.findInside(dom)\n    } else if (!rule || rule.skip || rule.closeParent) {\n      if (rule && rule.closeParent) this.open = Math.max(0, this.open - 1)\n      else if (rule && rule.skip.nodeType) dom = rule.skip\n      let sync, top = this.top, oldNeedsBlock = this.needsBlock\n      if (blockTags.hasOwnProperty(name)) {\n        sync = true\n        if (!top.type) this.needsBlock = true\n      } else if (!dom.firstChild) {\n        this.leafFallback(dom)\n        return\n      }\n      this.addAll(dom)\n      if (sync) this.sync(top)\n      this.needsBlock = oldNeedsBlock\n    } else {\n      this.addElementByRule(dom, rule)\n    }\n  }\n\n  // Called for leaf DOM nodes that would otherwise be ignored\n  leafFallback(dom) {\n    if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent)\n      this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\"))\n  }\n\n  // Run any style parser associated with the node's styles. Either\n  // return an array of marks, or null to indicate some of the styles\n  // had a rule with `ignore` set.\n  readStyles(styles) {\n    let marks = Mark.none\n    for (let i = 0; i < styles.length; i += 2) {\n      let rule = this.parser.matchStyle(styles[i], styles[i + 1], this)\n      if (!rule) continue\n      if (rule.ignore) return null\n      marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks)\n    }\n    return marks\n  }\n\n  // : (dom.Element, ParseRule) → bool\n  // Look up a handler for the given node. If none are found, return\n  // false. Otherwise, apply it, use its return value to drive the way\n  // the node's content is wrapped, and return true.\n  addElementByRule(dom, rule) {\n    let sync, nodeType, markType, mark\n    if (rule.node) {\n      nodeType = this.parser.schema.nodes[rule.node]\n      if (!nodeType.isLeaf) {\n        sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace)\n      } else if (!this.insertNode(nodeType.create(rule.attrs))) {\n        this.leafFallback(dom)\n      }\n    } else {\n      markType = this.parser.schema.marks[rule.mark]\n      mark = markType.create(rule.attrs)\n      this.addPendingMark(mark)\n    }\n    let startIn = this.top\n\n    if (nodeType && nodeType.isLeaf) {\n      this.findInside(dom)\n    } else if (rule.getContent) {\n      this.findInside(dom)\n      rule.getContent(dom, this.parser.schema).forEach(node => this.insertNode(node))\n    } else {\n      let contentDOM = rule.contentElement\n      if (typeof contentDOM == \"string\") contentDOM = dom.querySelector(contentDOM)\n      else if (typeof contentDOM == \"function\") contentDOM = contentDOM(dom)\n      if (!contentDOM) contentDOM = dom\n      this.findAround(dom, contentDOM, true)\n      this.addAll(contentDOM, sync)\n    }\n    if (sync) { this.sync(startIn); this.open-- }\n    if (mark) this.removePendingMark(mark, startIn)\n  }\n\n  // : (dom.Node, ?NodeBuilder, ?number, ?number)\n  // Add all child nodes between `startIndex` and `endIndex` (or the\n  // whole node, if not given). If `sync` is passed, use it to\n  // synchronize after every block element.\n  addAll(parent, sync, startIndex, endIndex) {\n    let index = startIndex || 0\n    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild,\n             end = endIndex == null ? null : parent.childNodes[endIndex];\n         dom != end; dom = dom.nextSibling, ++index) {\n      this.findAtPoint(parent, index)\n      this.addDOM(dom)\n      if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase()))\n        this.sync(sync)\n    }\n    this.findAtPoint(parent, index)\n  }\n\n  // Try to find a way to fit the given node type into the current\n  // context. May add intermediate wrappers and/or leave non-solid\n  // nodes that we're in.\n  findPlace(node) {\n    let route, sync\n    for (let depth = this.open; depth >= 0; depth--) {\n      let cx = this.nodes[depth]\n      let found = cx.findWrapping(node)\n      if (found && (!route || route.length > found.length)) {\n        route = found\n        sync = cx\n        if (!found.length) break\n      }\n      if (cx.solid) break\n    }\n    if (!route) return false\n    this.sync(sync)\n    for (let i = 0; i < route.length; i++)\n      this.enterInner(route[i], null, false)\n    return true\n  }\n\n  // : (Node) → ?Node\n  // Try to insert the given node, adjusting the context when needed.\n  insertNode(node) {\n    if (node.isInline && this.needsBlock && !this.top.type) {\n      let block = this.textblockFromContext()\n      if (block) this.enterInner(block)\n    }\n    if (this.findPlace(node)) {\n      this.closeExtra()\n      let top = this.top\n      top.applyPending(node.type)\n      if (top.match) top.match = top.match.matchType(node.type)\n      let marks = top.activeMarks\n      for (let i = 0; i < node.marks.length; i++)\n        if (!top.type || top.type.allowsMarkType(node.marks[i].type))\n          marks = node.marks[i].addToSet(marks)\n      top.content.push(node.mark(marks))\n      return true\n    }\n    return false\n  }\n\n  // : (NodeType, ?Object) → bool\n  // Try to start a node of the given type, adjusting the context when\n  // necessary.\n  enter(type, attrs, preserveWS) {\n    let ok = this.findPlace(type.create(attrs))\n    if (ok) this.enterInner(type, attrs, true, preserveWS)\n    return ok\n  }\n\n  // Open a node of the given type\n  enterInner(type, attrs, solid, preserveWS) {\n    this.closeExtra()\n    let top = this.top\n    top.applyPending(type)\n    top.match = top.match && top.match.matchType(type, attrs)\n    let options = preserveWS == null ? top.options & ~OPT_OPEN_LEFT : wsOptionsFor(preserveWS)\n    if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0) options |= OPT_OPEN_LEFT\n    this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options))\n    this.open++\n  }\n\n  // Make sure all nodes above this.open are finished and added to\n  // their parents\n  closeExtra(openEnd) {\n    let i = this.nodes.length - 1\n    if (i > this.open) {\n      for (; i > this.open; i--) this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd))\n      this.nodes.length = this.open + 1\n    }\n  }\n\n  finish() {\n    this.open = 0\n    this.closeExtra(this.isOpen)\n    return this.nodes[0].finish(this.isOpen || this.options.topOpen)\n  }\n\n  sync(to) {\n    for (let i = this.open; i >= 0; i--) if (this.nodes[i] == to) {\n      this.open = i\n      return\n    }\n  }\n\n  get currentPos() {\n    this.closeExtra()\n    let pos = 0\n    for (let i = this.open; i >= 0; i--) {\n      let content = this.nodes[i].content\n      for (let j = content.length - 1; j >= 0; j--)\n        pos += content[j].nodeSize\n      if (i) pos++\n    }\n    return pos\n  }\n\n  findAtPoint(parent, offset) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].node == parent && this.find[i].offset == offset)\n        this.find[i].pos = this.currentPos\n    }\n  }\n\n  findInside(parent) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))\n        this.find[i].pos = this.currentPos\n    }\n  }\n\n  findAround(parent, content, before) {\n    if (parent != content && this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n        let pos = content.compareDocumentPosition(this.find[i].node)\n        if (pos & (before ? 2 : 4))\n          this.find[i].pos = this.currentPos\n      }\n    }\n  }\n\n  findInText(textNode) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].node == textNode)\n        this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset)\n    }\n  }\n\n  // : (string) → bool\n  // Determines whether the given [context\n  // string](#ParseRule.context) matches this context.\n  matchesContext(context) {\n    if (context.indexOf(\"|\") > -1)\n      return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this)\n\n    let parts = context.split(\"/\")\n    let option = this.options.context\n    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type)\n    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1)\n    let match = (i, depth) => {\n      for (; i >= 0; i--) {\n        let part = parts[i]\n        if (part == \"\") {\n          if (i == parts.length - 1 || i == 0) continue\n          for (; depth >= minDepth; depth--)\n            if (match(i - 1, depth)) return true\n          return false\n        } else {\n          let next = depth > 0 || (depth == 0 && useRoot) ? this.nodes[depth].type\n              : option && depth >= minDepth ? option.node(depth - minDepth).type\n              : null\n          if (!next || (next.name != part && next.groups.indexOf(part) == -1))\n            return false\n          depth--\n        }\n      }\n      return true\n    }\n    return match(parts.length - 1, this.open)\n  }\n\n  textblockFromContext() {\n    let $context = this.options.context\n    if ($context) for (let d = $context.depth; d >= 0; d--) {\n      let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType\n      if (deflt && deflt.isTextblock && deflt.defaultAttrs) return deflt\n    }\n    for (let name in this.parser.schema.nodes) {\n      let type = this.parser.schema.nodes[name]\n      if (type.isTextblock && type.defaultAttrs) return type\n    }\n  }\n\n  addPendingMark(mark) {\n    this.top.pendingMarks = mark.addToSet(this.top.pendingMarks)\n  }\n\n  removePendingMark(mark, upto) {\n    for (let depth = this.open; depth >= 0; depth--) {\n      let level = this.nodes[depth]\n      let found = level.pendingMarks.lastIndexOf(mark)\n      if (found > -1) level.pendingMarks = mark.removeFromSet(level.pendingMarks)\n      else level.activeMarks = mark.removeFromSet(level.activeMarks)\n      if (level == upto) break\n    }\n  }\n}\n\n// Kludge to work around directly nested list nodes produced by some\n// tools and allowed by browsers to mean that the nested list is\n// actually part of the list item above it.\nfunction normalizeList(dom) {\n  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null\n    if (name && listTags.hasOwnProperty(name) && prevItem) {\n      prevItem.appendChild(child)\n      child = prevItem\n    } else if (name == \"li\") {\n      prevItem = child\n    } else if (name) {\n      prevItem = null\n    }\n  }\n}\n\n// Apply a CSS selector.\nfunction matches(dom, selector) {\n  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector)\n}\n\n// : (string) → [string]\n// Tokenize a style attribute into property/value pairs.\nfunction parseStyles(style) {\n  let re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g, m, result = []\n  while (m = re.exec(style)) result.push(m[1], m[2].trim())\n  return result\n}\n\nfunction copy(obj) {\n  let copy = {}\n  for (let prop in obj) copy[prop] = obj[prop]\n  return copy\n}\n\n// Used when finding a mark at the top level of a fragment parse.\n// Checks whether it would be reasonable to apply a given mark type to\n// a given node, by looking at the way the mark occurs in the schema.\nfunction markMayApply(markType, nodeType) {\n  let nodes = nodeType.schema.nodes\n  for (let name in nodes) {\n    let parent = nodes[name]\n    if (!parent.allowsMarkType(markType)) continue\n    let seen = [], scan = match => {\n      seen.push(match)\n      for (let i = 0; i < match.edgeCount; i++) {\n        let {type, next} = match.edge(i)\n        if (type == nodeType) return true\n        if (seen.indexOf(next) < 0 && scan(next)) return true\n      }\n    }\n    if (scan(parent.contentMatch)) return true\n  }\n}\n","// DOMOutputSpec:: interface\n// A description of a DOM structure. Can be either a string, which is\n// interpreted as a text node, a DOM node, which is interpreted as\n// itself, or an array.\n//\n// An array describes a DOM element. The first value in the array\n// should be a string—the name of the DOM element, optionally prefixed\n// by a namespace URL and a space. If the second element is plain\n// object, it is interpreted as a set of attributes for the element.\n// Any elements after that (including the 2nd if it's not an attribute\n// object) are interpreted as children of the DOM elements, and must\n// either be valid `DOMOutputSpec` values, or the number zero.\n//\n// The number zero (pronounced “hole”) is used to indicate the place\n// where a node's child nodes should be inserted. If it occurs in an\n// output spec, it should be the only child element in its parent\n// node.\n\n// ::- A DOM serializer knows how to convert ProseMirror nodes and\n// marks of various types to DOM nodes.\nexport class DOMSerializer {\n  // :: (Object<(node: Node) → DOMOutputSpec>, Object<?(mark: Mark, inline: bool) → DOMOutputSpec>)\n  // Create a serializer. `nodes` should map node names to functions\n  // that take a node and return a description of the corresponding\n  // DOM. `marks` does the same for mark names, but also gets an\n  // argument that tells it whether the mark's content is block or\n  // inline content (for typical use, it'll always be inline). A mark\n  // serializer may be `null` to indicate that marks of that type\n  // should not be serialized.\n  constructor(nodes, marks) {\n    // :: Object<(node: Node) → DOMOutputSpec>\n    // The node serialization functions.\n    this.nodes = nodes || {}\n    // :: Object<?(mark: Mark, inline: bool) → DOMOutputSpec>\n    // The mark serialization functions.\n    this.marks = marks || {}\n  }\n\n  // :: (Fragment, ?Object) → dom.DocumentFragment\n  // Serialize the content of this fragment to a DOM fragment. When\n  // not in the browser, the `document` option, containing a DOM\n  // document, should be passed so that the serializer can create\n  // nodes.\n  serializeFragment(fragment, options = {}, target) {\n    if (!target) target = doc(options).createDocumentFragment()\n\n    let top = target, active = null\n    fragment.forEach(node => {\n      if (active || node.marks.length) {\n        if (!active) active = []\n        let keep = 0, rendered = 0\n        while (keep < active.length && rendered < node.marks.length) {\n          let next = node.marks[rendered]\n          if (!this.marks[next.type.name]) { rendered++; continue }\n          if (!next.eq(active[keep]) || next.type.spec.spanning === false) break\n          keep += 2; rendered++\n        }\n        while (keep < active.length) {\n          top = active.pop()\n          active.pop()\n        }\n        while (rendered < node.marks.length) {\n          let add = node.marks[rendered++]\n          let markDOM = this.serializeMark(add, node.isInline, options)\n          if (markDOM) {\n            active.push(add, top)\n            top.appendChild(markDOM.dom)\n            top = markDOM.contentDOM || markDOM.dom\n          }\n        }\n      }\n      top.appendChild(this.serializeNode(node, options))\n    })\n\n    return target\n  }\n\n  // :: (Node, ?Object) → dom.Node\n  // Serialize this node to a DOM node. This can be useful when you\n  // need to serialize a part of a document, as opposed to the whole\n  // document. To serialize a whole document, use\n  // [`serializeFragment`](#model.DOMSerializer.serializeFragment) on\n  // its [content](#model.Node.content).\n  serializeNode(node, options = {}) {\n    let {dom, contentDOM} =\n        DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node))\n    if (contentDOM) {\n      if (node.isLeaf)\n        throw new RangeError(\"Content hole not allowed in a leaf node spec\")\n      if (options.onContent)\n        options.onContent(node, contentDOM, options)\n      else\n        this.serializeFragment(node.content, options, contentDOM)\n    }\n    return dom\n  }\n\n  serializeNodeAndMarks(node, options = {}) {\n    let dom = this.serializeNode(node, options)\n    for (let i = node.marks.length - 1; i >= 0; i--) {\n      let wrap = this.serializeMark(node.marks[i], node.isInline, options)\n      if (wrap) {\n        ;(wrap.contentDOM || wrap.dom).appendChild(dom)\n        dom = wrap.dom\n      }\n    }\n    return dom\n  }\n\n  serializeMark(mark, inline, options = {}) {\n    let toDOM = this.marks[mark.type.name]\n    return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline))\n  }\n\n  // :: (dom.Document, DOMOutputSpec) → {dom: dom.Node, contentDOM: ?dom.Node}\n  // Render an [output spec](#model.DOMOutputSpec) to a DOM node. If\n  // the spec has a hole (zero) in it, `contentDOM` will point at the\n  // node with the hole.\n  static renderSpec(doc, structure, xmlNS = null) {\n    if (typeof structure == \"string\")\n      return {dom: doc.createTextNode(structure)}\n    if (structure.nodeType != null)\n      return {dom: structure}\n    let tagName = structure[0], space = tagName.indexOf(\" \")\n    if (space > 0) {\n      xmlNS = tagName.slice(0, space)\n      tagName = tagName.slice(space + 1)\n    }\n    let contentDOM = null, dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName)\n    let attrs = structure[1], start = 1\n    if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n      start = 2\n      for (let name in attrs) if (attrs[name] != null) {\n        let space = name.indexOf(\" \")\n        if (space > 0) dom.setAttributeNS(name.slice(0, space), name.slice(space + 1), attrs[name])\n        else dom.setAttribute(name, attrs[name])\n      }\n    }\n    for (let i = start; i < structure.length; i++) {\n      let child = structure[i]\n      if (child === 0) {\n        if (i < structure.length - 1 || i > start)\n          throw new RangeError(\"Content hole must be the only child of its parent node\")\n        return {dom, contentDOM: dom}\n      } else {\n        let {dom: inner, contentDOM: innerContent} = DOMSerializer.renderSpec(doc, child, xmlNS)\n        dom.appendChild(inner)\n        if (innerContent) {\n          if (contentDOM) throw new RangeError(\"Multiple content holes\")\n          contentDOM = innerContent\n        }\n      }\n    }\n    return {dom, contentDOM}\n  }\n\n  // :: (Schema) → DOMSerializer\n  // Build a serializer using the [`toDOM`](#model.NodeSpec.toDOM)\n  // properties in a schema's node and mark specs.\n  static fromSchema(schema) {\n    return schema.cached.domSerializer ||\n      (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)))\n  }\n\n  // : (Schema) → Object<(node: Node) → DOMOutputSpec>\n  // Gather the serializers in a schema's node specs into an object.\n  // This can be useful as a base to build a custom serializer from.\n  static nodesFromSchema(schema) {\n    let result = gatherToDOM(schema.nodes)\n    if (!result.text) result.text = node => node.text\n    return result\n  }\n\n  // : (Schema) → Object<(mark: Mark) → DOMOutputSpec>\n  // Gather the serializers in a schema's mark specs into an object.\n  static marksFromSchema(schema) {\n    return gatherToDOM(schema.marks)\n  }\n}\n\nfunction gatherToDOM(obj) {\n  let result = {}\n  for (let name in obj) {\n    let toDOM = obj[name].spec.toDOM\n    if (toDOM) result[name] = toDOM\n  }\n  return result\n}\n\nfunction doc(options) {\n  // declare global: window\n  return options.document || window.document\n}\n"]},"metadata":{},"sourceType":"module"}