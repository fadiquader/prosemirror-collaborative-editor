{"ast":null,"code":"import { Plugin } from 'prosemirror-state';\nimport { findWrapping, canJoin } from 'prosemirror-transform'; // ::- Input rules are regular expressions describing a piece of text\n// that, when typed, causes something to happen. This might be\n// changing two dashes into an emdash, wrapping a paragraph starting\n// with `\"> \"` into a blockquote, or something entirely different.\n\nvar InputRule = function InputRule(match, handler) {\n  this.match = match;\n  this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler;\n};\n\nfunction stringHandler(string) {\n  return function (state, match, start, end) {\n    var insert = string;\n\n    if (match[1]) {\n      var offset = match[0].lastIndexOf(match[1]);\n      insert += match[0].slice(offset + match[1].length);\n      start += offset;\n      var cutOff = start - end;\n\n      if (cutOff > 0) {\n        insert = match[0].slice(offset - cutOff, offset) + insert;\n        start = end;\n      }\n    }\n\n    return state.tr.insertText(insert, start, end);\n  };\n}\n\nvar MAX_MATCH = 500; // :: (config: {rules: [InputRule]}) → Plugin\n// Create an input rules plugin. When enabled, it will cause text\n// input that matches any of the given rules to trigger the rule's\n// action.\n\nfunction inputRules(ref) {\n  var rules = ref.rules;\n  var plugin = new Plugin({\n    state: {\n      init: function init() {\n        return null;\n      },\n      apply: function apply(tr, prev) {\n        var stored = tr.getMeta(this);\n\n        if (stored) {\n          return stored;\n        }\n\n        return tr.selectionSet || tr.docChanged ? null : prev;\n      }\n    },\n    props: {\n      handleTextInput: function handleTextInput(view, from, to, text) {\n        return run(view, from, to, text, rules, plugin);\n      },\n      handleDOMEvents: {\n        compositionend: function (view) {\n          setTimeout(function () {\n            var ref = view.state.selection;\n            var $cursor = ref.$cursor;\n\n            if ($cursor) {\n              run(view, $cursor.pos, $cursor.pos, \"\", rules, plugin);\n            }\n          });\n        }\n      }\n    },\n    isInputRules: true\n  });\n  return plugin;\n}\n\nfunction run(view, from, to, text, rules, plugin) {\n  if (view.composing) {\n    return false;\n  }\n\n  var state = view.state,\n      $from = state.doc.resolve(from);\n\n  if ($from.parent.type.spec.code) {\n    return false;\n  }\n\n  var textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset, null, \"\\ufffc\") + text;\n\n  for (var i = 0; i < rules.length; i++) {\n    var match = rules[i].match.exec(textBefore);\n    var tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to);\n\n    if (!tr) {\n      continue;\n    }\n\n    view.dispatch(tr.setMeta(plugin, {\n      transform: tr,\n      from: from,\n      to: to,\n      text: text\n    }));\n    return true;\n  }\n\n  return false;\n} // :: (EditorState, ?(Transaction)) → bool\n// This is a command that will undo an input rule, if applying such a\n// rule was the last thing that the user did.\n\n\nfunction undoInputRule(state, dispatch) {\n  var plugins = state.plugins;\n\n  for (var i = 0; i < plugins.length; i++) {\n    var plugin = plugins[i],\n        undoable = void 0;\n\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        var tr = state.tr,\n            toUndo = undoable.transform;\n\n        for (var j = toUndo.steps.length - 1; j >= 0; j--) {\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n        }\n\n        var marks = tr.doc.resolve(undoable.from).marks();\n        dispatch(tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks)));\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n} // :: InputRule Converts double dashes to an emdash.\n\n\nvar emDash = new InputRule(/--$/, \"—\"); // :: InputRule Converts three dots to an ellipsis character.\n\nvar ellipsis = new InputRule(/\\.\\.\\.$/, \"…\"); // :: InputRule “Smart” opening double quotes.\n\nvar openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(\")$/, \"“\"); // :: InputRule “Smart” closing double quotes.\n\nvar closeDoubleQuote = new InputRule(/\"$/, \"”\"); // :: InputRule “Smart” opening single quotes.\n\nvar openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(')$/, \"‘\"); // :: InputRule “Smart” closing single quotes.\n\nvar closeSingleQuote = new InputRule(/'$/, \"’\"); // :: [InputRule] Smart-quote related input rules.\n\nvar smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote]; // :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>, ?([string], Node) → bool) → InputRule\n// Build an input rule for automatically wrapping a textblock when a\n// given string is typed. The `regexp` argument is\n// directly passed through to the `InputRule` constructor. You'll\n// probably want the regexp to start with `^`, so that the pattern can\n// only occur at the start of a textblock.\n//\n// `nodeType` is the type of node to wrap in. If it needs attributes,\n// you can either pass them directly, or pass a function that will\n// compute them from the regular expression match.\n//\n// By default, if there's a node with the same type above the newly\n// wrapped node, the rule will try to [join](#transform.Transform.join) those\n// two nodes. You can pass a join predicate, which takes a regular\n// expression match and the node before the wrapped node, and can\n// return a boolean to indicate whether a join should happen.\n\nfunction wrappingInputRule(regexp, nodeType, getAttrs, joinPredicate) {\n  return new InputRule(regexp, function (state, match, start, end) {\n    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n    var tr = state.tr.delete(start, end);\n    var $start = tr.doc.resolve(start),\n        range = $start.blockRange(),\n        wrapping = range && findWrapping(range, nodeType, attrs);\n\n    if (!wrapping) {\n      return null;\n    }\n\n    tr.wrap(range, wrapping);\n    var before = tr.doc.resolve(start - 1).nodeBefore;\n\n    if (before && before.type == nodeType && canJoin(tr.doc, start - 1) && (!joinPredicate || joinPredicate(match, before))) {\n      tr.join(start - 1);\n    }\n\n    return tr;\n  });\n} // :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>) → InputRule\n// Build an input rule that changes the type of a textblock when the\n// matched text is typed into it. You'll usually want to start your\n// regexp with `^` to that it is only matched at the start of a\n// textblock. The optional `getAttrs` parameter can be used to compute\n// the new node's attributes, and works the same as in the\n// `wrappingInputRule` function.\n\n\nfunction textblockTypeInputRule(regexp, nodeType, getAttrs) {\n  return new InputRule(regexp, function (state, match, start, end) {\n    var $start = state.doc.resolve(start);\n    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n\n    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType)) {\n      return null;\n    }\n\n    return state.tr.delete(start, end).setBlockType(start, start, nodeType, attrs);\n  });\n}\n\nexport { InputRule, closeDoubleQuote, closeSingleQuote, ellipsis, emDash, inputRules, openDoubleQuote, openSingleQuote, smartQuotes, textblockTypeInputRule, undoInputRule, wrappingInputRule };","map":{"version":3,"sources":["../src/inputrules.js","../src/rules.js","../src/rulebuilders.js"],"names":["let","const"],"mappings":"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","sourcesContent":["import {Plugin} from \"prosemirror-state\"\n\n// ::- Input rules are regular expressions describing a piece of text\n// that, when typed, causes something to happen. This might be\n// changing two dashes into an emdash, wrapping a paragraph starting\n// with `\"> \"` into a blockquote, or something entirely different.\nexport class InputRule {\n  // :: (RegExp, union<string, (state: EditorState, match: [string], start: number, end: number) → ?Transaction>)\n  // Create an input rule. The rule applies when the user typed\n  // something and the text directly in front of the cursor matches\n  // `match`, which should probably end with `$`.\n  //\n  // The `handler` can be a string, in which case the matched text, or\n  // the first matched group in the regexp, is replaced by that\n  // string.\n  //\n  // Or a it can be a function, which will be called with the match\n  // array produced by\n  // [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),\n  // as well as the start and end of the matched range, and which can\n  // return a [transaction](#state.Transaction) that describes the\n  // rule's effect, or null to indicate the input was not handled.\n  constructor(match, handler) {\n    this.match = match\n    this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler\n  }\n}\n\nfunction stringHandler(string) {\n  return function(state, match, start, end) {\n    let insert = string\n    if (match[1]) {\n      let offset = match[0].lastIndexOf(match[1])\n      insert += match[0].slice(offset + match[1].length)\n      start += offset\n      let cutOff = start - end\n      if (cutOff > 0) {\n        insert = match[0].slice(offset - cutOff, offset) + insert\n        start = end\n      }\n    }\n    return state.tr.insertText(insert, start, end)\n  }\n}\n\nconst MAX_MATCH = 500\n\n// :: (config: {rules: [InputRule]}) → Plugin\n// Create an input rules plugin. When enabled, it will cause text\n// input that matches any of the given rules to trigger the rule's\n// action.\nexport function inputRules({rules}) {\n  let plugin = new Plugin({\n    state: {\n      init() { return null },\n      apply(tr, prev) {\n        let stored = tr.getMeta(this)\n        if (stored) return stored\n        return tr.selectionSet || tr.docChanged ? null : prev\n      }\n    },\n\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run(view, from, to, text, rules, plugin)\n      },\n      handleDOMEvents: {\n        compositionend: (view) => {\n          setTimeout(() => {\n            let {$cursor} = view.state.selection\n            if ($cursor) run(view, $cursor.pos, $cursor.pos, \"\", rules, plugin)\n          })\n        }\n      }\n    },\n\n    isInputRules: true\n  })\n  return plugin\n}\n\nfunction run(view, from, to, text, rules, plugin) {\n  if (view.composing) return false\n  let state = view.state, $from = state.doc.resolve(from)\n  if ($from.parent.type.spec.code) return false\n  let textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset,\n                                            null, \"\\ufffc\") + text\n  for (let i = 0; i < rules.length; i++) {\n    let match = rules[i].match.exec(textBefore)\n    let tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to)\n    if (!tr) continue\n    view.dispatch(tr.setMeta(plugin, {transform: tr, from, to, text}))\n    return true\n  }\n  return false\n}\n\n// :: (EditorState, ?(Transaction)) → bool\n// This is a command that will undo an input rule, if applying such a\n// rule was the last thing that the user did.\nexport function undoInputRule(state, dispatch) {\n  let plugins = state.plugins\n  for (let i = 0; i < plugins.length; i++) {\n    let plugin = plugins[i], undoable\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        let tr = state.tr, toUndo = undoable.transform\n        for (let j = toUndo.steps.length - 1; j >= 0; j--)\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]))\n        let marks = tr.doc.resolve(undoable.from).marks()\n        dispatch(tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks)))\n      }\n      return true\n    }\n  }\n  return false\n}\n","import {InputRule} from \"./inputrules\"\n\n// :: InputRule Converts double dashes to an emdash.\nexport const emDash = new InputRule(/--$/, \"—\")\n// :: InputRule Converts three dots to an ellipsis character.\nexport const ellipsis = new InputRule(/\\.\\.\\.$/, \"…\")\n// :: InputRule “Smart” opening double quotes.\nexport const openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(\")$/, \"“\")\n// :: InputRule “Smart” closing double quotes.\nexport const closeDoubleQuote = new InputRule(/\"$/, \"”\")\n// :: InputRule “Smart” opening single quotes.\nexport const openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(')$/, \"‘\")\n// :: InputRule “Smart” closing single quotes.\nexport const closeSingleQuote = new InputRule(/'$/, \"’\")\n\n// :: [InputRule] Smart-quote related input rules.\nexport const smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote]\n","import {InputRule} from \"./inputrules\"\nimport {findWrapping, canJoin} from \"prosemirror-transform\"\n\n// :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>, ?([string], Node) → bool) → InputRule\n// Build an input rule for automatically wrapping a textblock when a\n// given string is typed. The `regexp` argument is\n// directly passed through to the `InputRule` constructor. You'll\n// probably want the regexp to start with `^`, so that the pattern can\n// only occur at the start of a textblock.\n//\n// `nodeType` is the type of node to wrap in. If it needs attributes,\n// you can either pass them directly, or pass a function that will\n// compute them from the regular expression match.\n//\n// By default, if there's a node with the same type above the newly\n// wrapped node, the rule will try to [join](#transform.Transform.join) those\n// two nodes. You can pass a join predicate, which takes a regular\n// expression match and the node before the wrapped node, and can\n// return a boolean to indicate whether a join should happen.\nexport function wrappingInputRule(regexp, nodeType, getAttrs, joinPredicate) {\n  return new InputRule(regexp, (state, match, start, end) => {\n    let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs\n    let tr = state.tr.delete(start, end)\n    let $start = tr.doc.resolve(start), range = $start.blockRange(), wrapping = range && findWrapping(range, nodeType, attrs)\n    if (!wrapping) return null\n    tr.wrap(range, wrapping)\n    let before = tr.doc.resolve(start - 1).nodeBefore\n    if (before && before.type == nodeType && canJoin(tr.doc, start - 1) &&\n        (!joinPredicate || joinPredicate(match, before)))\n      tr.join(start - 1)\n    return tr\n  })\n}\n\n// :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>) → InputRule\n// Build an input rule that changes the type of a textblock when the\n// matched text is typed into it. You'll usually want to start your\n// regexp with `^` to that it is only matched at the start of a\n// textblock. The optional `getAttrs` parameter can be used to compute\n// the new node's attributes, and works the same as in the\n// `wrappingInputRule` function.\nexport function textblockTypeInputRule(regexp, nodeType, getAttrs) {\n  return new InputRule(regexp, (state, match, start, end) => {\n    let $start = state.doc.resolve(start)\n    let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs\n    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType)) return null\n    return state.tr\n      .delete(start, end)\n      .setBlockType(start, start, nodeType, attrs)\n  })\n}\n"]},"metadata":{},"sourceType":"module"}