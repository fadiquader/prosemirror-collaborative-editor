{"ast":null,"code":"import { inputRules, wrappingInputRule, textblockTypeInputRule, smartQuotes, emDash, ellipsis } from \"prosemirror-inputrules\"; // : (NodeType) → InputRule\n// Given a blockquote node type, returns an input rule that turns `\"> \"`\n// at the start of a textblock into a blockquote.\n\nexport function blockQuoteRule(nodeType) {\n  return wrappingInputRule(/^\\s*>\\s$/, nodeType);\n} // : (NodeType) → InputRule\n// Given a list node type, returns an input rule that turns a number\n// followed by a dot at the start of a textblock into an ordered list.\n\nexport function orderedListRule(nodeType) {\n  return wrappingInputRule(/^(\\d+)\\.\\s$/, nodeType, match => ({\n    order: +match[1]\n  }), (match, node) => node.childCount + node.attrs.order == +match[1]);\n} // : (NodeType) → InputRule\n// Given a list node type, returns an input rule that turns a bullet\n// (dash, plush, or asterisk) at the start of a textblock into a\n// bullet list.\n\nexport function bulletListRule(nodeType) {\n  return wrappingInputRule(/^\\s*([-+*])\\s$/, nodeType);\n} // : (NodeType) → InputRule\n// Given a code block node type, returns an input rule that turns a\n// textblock starting with three backticks into a code block.\n\nexport function codeBlockRule(nodeType) {\n  return textblockTypeInputRule(/^```$/, nodeType);\n} // : (NodeType, number) → InputRule\n// Given a node type and a maximum level, creates an input rule that\n// turns up to that number of `#` characters followed by a space at\n// the start of a textblock into a heading whose level corresponds to\n// the number of `#` signs.\n\nexport function headingRule(nodeType, maxLevel) {\n  return textblockTypeInputRule(new RegExp(\"^(#{1,\" + maxLevel + \"})\\\\s$\"), nodeType, match => ({\n    level: match[1].length\n  }));\n} // : (Schema) → Plugin\n// A set of input rules for creating the basic block quotes, lists,\n// code blocks, and heading.\n\nexport function buildInputRules(schema) {\n  let rules = smartQuotes.concat(ellipsis, emDash),\n      type;\n  if (type = schema.nodes.blockquote) rules.push(blockQuoteRule(type));\n  if (type = schema.nodes.ordered_list) rules.push(orderedListRule(type));\n  if (type = schema.nodes.bullet_list) rules.push(bulletListRule(type));\n  if (type = schema.nodes.code_block) rules.push(codeBlockRule(type));\n  if (type = schema.nodes.heading) rules.push(headingRule(type, 6));\n  return inputRules({\n    rules\n  });\n}","map":{"version":3,"sources":["/Users/meeopp/Development/Others/editor-yjs/client/src/prosmirror/inputrules.js"],"names":["inputRules","wrappingInputRule","textblockTypeInputRule","smartQuotes","emDash","ellipsis","blockQuoteRule","nodeType","orderedListRule","match","order","node","childCount","attrs","bulletListRule","codeBlockRule","headingRule","maxLevel","RegExp","level","length","buildInputRules","schema","rules","concat","type","nodes","blockquote","push","ordered_list","bullet_list","code_block","heading"],"mappings":"AAAA,SAAQA,UAAR,EAAoBC,iBAApB,EAAuCC,sBAAvC,EACEC,WADF,EACeC,MADf,EACuBC,QADvB,QACsC,wBADtC,C,CAGA;AACA;AACA;;AACA,OAAO,SAASC,cAAT,CAAwBC,QAAxB,EAAkC;AACvC,SAAON,iBAAiB,CAAC,UAAD,EAAaM,QAAb,CAAxB;AACD,C,CAED;AACA;AACA;;AACA,OAAO,SAASC,eAAT,CAAyBD,QAAzB,EAAmC;AACxC,SAAON,iBAAiB,CAAC,aAAD,EAAgBM,QAAhB,EAA0BE,KAAK,KAAK;AAACC,IAAAA,KAAK,EAAE,CAACD,KAAK,CAAC,CAAD;AAAd,GAAL,CAA/B,EACtB,CAACA,KAAD,EAAQE,IAAR,KAAiBA,IAAI,CAACC,UAAL,GAAkBD,IAAI,CAACE,KAAL,CAAWH,KAA7B,IAAsC,CAACD,KAAK,CAAC,CAAD,CADvC,CAAxB;AAED,C,CAED;AACA;AACA;AACA;;AACA,OAAO,SAASK,cAAT,CAAwBP,QAAxB,EAAkC;AACvC,SAAON,iBAAiB,CAAC,gBAAD,EAAmBM,QAAnB,CAAxB;AACD,C,CAED;AACA;AACA;;AACA,OAAO,SAASQ,aAAT,CAAuBR,QAAvB,EAAiC;AACtC,SAAOL,sBAAsB,CAAC,OAAD,EAAUK,QAAV,CAA7B;AACD,C,CAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASS,WAAT,CAAqBT,QAArB,EAA+BU,QAA/B,EAAyC;AAC9C,SAAOf,sBAAsB,CAAC,IAAIgB,MAAJ,CAAW,WAAWD,QAAX,GAAsB,QAAjC,CAAD,EAC3BV,QAD2B,EACjBE,KAAK,KAAK;AAACU,IAAAA,KAAK,EAAEV,KAAK,CAAC,CAAD,CAAL,CAASW;AAAjB,GAAL,CADY,CAA7B;AAED,C,CAED;AACA;AACA;;AACA,OAAO,SAASC,eAAT,CAAyBC,MAAzB,EAAiC;AACtC,MAAIC,KAAK,GAAGpB,WAAW,CAACqB,MAAZ,CAAmBnB,QAAnB,EAA6BD,MAA7B,CAAZ;AAAA,MAAkDqB,IAAlD;AACA,MAAIA,IAAI,GAAGH,MAAM,CAACI,KAAP,CAAaC,UAAxB,EAAoCJ,KAAK,CAACK,IAAN,CAAWtB,cAAc,CAACmB,IAAD,CAAzB;AACpC,MAAIA,IAAI,GAAGH,MAAM,CAACI,KAAP,CAAaG,YAAxB,EAAsCN,KAAK,CAACK,IAAN,CAAWpB,eAAe,CAACiB,IAAD,CAA1B;AACtC,MAAIA,IAAI,GAAGH,MAAM,CAACI,KAAP,CAAaI,WAAxB,EAAqCP,KAAK,CAACK,IAAN,CAAWd,cAAc,CAACW,IAAD,CAAzB;AACrC,MAAIA,IAAI,GAAGH,MAAM,CAACI,KAAP,CAAaK,UAAxB,EAAoCR,KAAK,CAACK,IAAN,CAAWb,aAAa,CAACU,IAAD,CAAxB;AACpC,MAAIA,IAAI,GAAGH,MAAM,CAACI,KAAP,CAAaM,OAAxB,EAAiCT,KAAK,CAACK,IAAN,CAAWZ,WAAW,CAACS,IAAD,EAAO,CAAP,CAAtB;AACjC,SAAOzB,UAAU,CAAC;AAACuB,IAAAA;AAAD,GAAD,CAAjB;AACD","sourcesContent":["import {inputRules, wrappingInputRule, textblockTypeInputRule,\n  smartQuotes, emDash, ellipsis} from \"prosemirror-inputrules\"\n\n// : (NodeType) → InputRule\n// Given a blockquote node type, returns an input rule that turns `\"> \"`\n// at the start of a textblock into a blockquote.\nexport function blockQuoteRule(nodeType) {\n  return wrappingInputRule(/^\\s*>\\s$/, nodeType)\n}\n\n// : (NodeType) → InputRule\n// Given a list node type, returns an input rule that turns a number\n// followed by a dot at the start of a textblock into an ordered list.\nexport function orderedListRule(nodeType) {\n  return wrappingInputRule(/^(\\d+)\\.\\s$/, nodeType, match => ({order: +match[1]}),\n    (match, node) => node.childCount + node.attrs.order == +match[1])\n}\n\n// : (NodeType) → InputRule\n// Given a list node type, returns an input rule that turns a bullet\n// (dash, plush, or asterisk) at the start of a textblock into a\n// bullet list.\nexport function bulletListRule(nodeType) {\n  return wrappingInputRule(/^\\s*([-+*])\\s$/, nodeType)\n}\n\n// : (NodeType) → InputRule\n// Given a code block node type, returns an input rule that turns a\n// textblock starting with three backticks into a code block.\nexport function codeBlockRule(nodeType) {\n  return textblockTypeInputRule(/^```$/, nodeType)\n}\n\n// : (NodeType, number) → InputRule\n// Given a node type and a maximum level, creates an input rule that\n// turns up to that number of `#` characters followed by a space at\n// the start of a textblock into a heading whose level corresponds to\n// the number of `#` signs.\nexport function headingRule(nodeType, maxLevel) {\n  return textblockTypeInputRule(new RegExp(\"^(#{1,\" + maxLevel + \"})\\\\s$\"),\n    nodeType, match => ({level: match[1].length}))\n}\n\n// : (Schema) → Plugin\n// A set of input rules for creating the basic block quotes, lists,\n// code blocks, and heading.\nexport function buildInputRules(schema) {\n  let rules = smartQuotes.concat(ellipsis, emDash), type\n  if (type = schema.nodes.blockquote) rules.push(blockQuoteRule(type))\n  if (type = schema.nodes.ordered_list) rules.push(orderedListRule(type))\n  if (type = schema.nodes.bullet_list) rules.push(bulletListRule(type))\n  if (type = schema.nodes.code_block) rules.push(codeBlockRule(type))\n  if (type = schema.nodes.heading) rules.push(headingRule(type, 6))\n  return inputRules({rules})\n}\n"]},"metadata":{},"sourceType":"module"}