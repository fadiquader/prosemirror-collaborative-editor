{"ast":null,"code":"import { findWrapping, ReplaceAroundStep, canSplit, liftTarget } from 'prosemirror-transform';\nimport { NodeRange, Fragment, Slice } from 'prosemirror-model';\nvar olDOM = [\"ol\", 0],\n    ulDOM = [\"ul\", 0],\n    liDOM = [\"li\", 0]; // :: NodeSpec\n// An ordered list [node spec](#model.NodeSpec). Has a single\n// attribute, `order`, which determines the number at which the list\n// starts counting, and defaults to 1. Represented as an `<ol>`\n// element.\n\nvar orderedList = {\n  attrs: {\n    order: {\n      default: 1\n    }\n  },\n  parseDOM: [{\n    tag: \"ol\",\n    getAttrs: function getAttrs(dom) {\n      return {\n        order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1\n      };\n    }\n  }],\n  toDOM: function toDOM(node) {\n    return node.attrs.order == 1 ? olDOM : [\"ol\", {\n      start: node.attrs.order\n    }, 0];\n  }\n}; // :: NodeSpec\n// A bullet list node spec, represented in the DOM as `<ul>`.\n\nvar bulletList = {\n  parseDOM: [{\n    tag: \"ul\"\n  }],\n  toDOM: function toDOM() {\n    return ulDOM;\n  }\n}; // :: NodeSpec\n// A list item (`<li>`) spec.\n\nvar listItem = {\n  parseDOM: [{\n    tag: \"li\"\n  }],\n  toDOM: function toDOM() {\n    return liDOM;\n  },\n  defining: true\n};\n\nfunction add(obj, props) {\n  var copy = {};\n\n  for (var prop in obj) {\n    copy[prop] = obj[prop];\n  }\n\n  for (var prop$1 in props) {\n    copy[prop$1] = props[prop$1];\n  }\n\n  return copy;\n} // :: (OrderedMap<NodeSpec>, string, ?string) → OrderedMap<NodeSpec>\n// Convenience function for adding list-related node types to a map\n// specifying the nodes for a schema. Adds\n// [`orderedList`](#schema-list.orderedList) as `\"ordered_list\"`,\n// [`bulletList`](#schema-list.bulletList) as `\"bullet_list\"`, and\n// [`listItem`](#schema-list.listItem) as `\"list_item\"`.\n//\n// `itemContent` determines the content expression for the list items.\n// If you want the commands defined in this module to apply to your\n// list structure, it should have a shape like `\"paragraph block*\"` or\n// `\"paragraph (ordered_list | bullet_list)*\"`. `listGroup` can be\n// given to assign a group name to the list node types, for example\n// `\"block\"`.\n\n\nfunction addListNodes(nodes, itemContent, listGroup) {\n  return nodes.append({\n    ordered_list: add(orderedList, {\n      content: \"list_item+\",\n      group: listGroup\n    }),\n    bullet_list: add(bulletList, {\n      content: \"list_item+\",\n      group: listGroup\n    }),\n    list_item: add(listItem, {\n      content: itemContent\n    })\n  });\n} // :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command function that wraps the selection in a list with\n// the given type an attributes. If `dispatch` is null, only return a\n// value to indicate whether this is possible, but don't actually\n// perform the change.\n\n\nfunction wrapInList(listType, attrs) {\n  return function (state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var range = $from.blockRange($to),\n        doJoin = false,\n        outerRange = range;\n\n    if (!range) {\n      return false;\n    } // This is at the top of an existing list item\n\n\n    if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {\n      // Don't do anything if this is the top of the list\n      if ($from.index(range.depth - 1) == 0) {\n        return false;\n      }\n\n      var $insert = state.doc.resolve(range.start - 2);\n      outerRange = new NodeRange($insert, $insert, range.depth);\n\n      if (range.endIndex < range.parent.childCount) {\n        range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);\n      }\n\n      doJoin = true;\n    }\n\n    var wrap = findWrapping(outerRange, listType, attrs, range);\n\n    if (!wrap) {\n      return false;\n    }\n\n    if (dispatch) {\n      dispatch(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView());\n    }\n\n    return true;\n  };\n}\n\nfunction doWrapInList(tr, range, wrappers, joinBefore, listType) {\n  var content = Fragment.empty;\n\n  for (var i = wrappers.length - 1; i >= 0; i--) {\n    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n  }\n\n  tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));\n  var found = 0;\n\n  for (var i$1 = 0; i$1 < wrappers.length; i$1++) {\n    if (wrappers[i$1].type == listType) {\n      found = i$1 + 1;\n    }\n  }\n\n  var splitDepth = wrappers.length - found;\n  var splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0),\n      parent = range.parent;\n\n  for (var i$2 = range.startIndex, e = range.endIndex, first = true; i$2 < e; i$2++, first = false) {\n    if (!first && canSplit(tr.doc, splitPos, splitDepth)) {\n      tr.split(splitPos, splitDepth);\n      splitPos += 2 * splitDepth;\n    }\n\n    splitPos += parent.child(i$2).nodeSize;\n  }\n\n  return tr;\n} // :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Build a command that splits a non-empty textblock at the top level\n// of a list item by also splitting that list item.\n\n\nfunction splitListItem(itemType) {\n  return function (state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var node = ref.node;\n\n    if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {\n      return false;\n    }\n\n    var grandParent = $from.node(-1);\n\n    if (grandParent.type != itemType) {\n      return false;\n    }\n\n    if ($from.parent.content.size == 0) {\n      // In an empty block. If this is a nested list, the wrapping\n      // list item should be split. Otherwise, bail out and let next\n      // command handle lifting.\n      if ($from.depth == 2 || $from.node(-3).type != itemType || $from.index(-2) != $from.node(-2).childCount - 1) {\n        return false;\n      }\n\n      if (dispatch) {\n        var wrap = Fragment.empty,\n            keepItem = $from.index(-1) > 0; // Build a fragment containing empty versions of the structure\n        // from the outer list item to the parent node of the cursor\n\n        for (var d = $from.depth - (keepItem ? 1 : 2); d >= $from.depth - 3; d--) {\n          wrap = Fragment.from($from.node(d).copy(wrap));\n        } // Add a second list item with an empty default start node\n\n\n        wrap = wrap.append(Fragment.from(itemType.createAndFill()));\n        var tr$1 = state.tr.replace($from.before(keepItem ? null : -1), $from.after(-3), new Slice(wrap, keepItem ? 3 : 2, 2));\n        tr$1.setSelection(state.selection.constructor.near(tr$1.doc.resolve($from.pos + (keepItem ? 3 : 2))));\n        dispatch(tr$1.scrollIntoView());\n      }\n\n      return true;\n    }\n\n    var nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n    var tr = state.tr.delete($from.pos, $to.pos);\n    var types = nextType && [null, {\n      type: nextType\n    }];\n\n    if (!canSplit(tr.doc, $from.pos, 2, types)) {\n      return false;\n    }\n\n    if (dispatch) {\n      dispatch(tr.split($from.pos, 2, types).scrollIntoView());\n    }\n\n    return true;\n  };\n} // :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Create a command to lift the list item around the selection up into\n// a wrapping list.\n\n\nfunction liftListItem(itemType) {\n  return function (state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var range = $from.blockRange($to, function (node) {\n      return node.childCount && node.firstChild.type == itemType;\n    });\n\n    if (!range) {\n      return false;\n    }\n\n    if (!dispatch) {\n      return true;\n    }\n\n    if ($from.node(range.depth - 1).type == itemType) // Inside a parent list\n      {\n        return liftToOuterList(state, dispatch, itemType, range);\n      } else // Outer list node\n      {\n        return liftOutOfList(state, dispatch, range);\n      }\n  };\n}\n\nfunction liftToOuterList(state, dispatch, itemType, range) {\n  var tr = state.tr,\n      end = range.end,\n      endOfList = range.$to.end(range.depth);\n\n  if (end < endOfList) {\n    // There are siblings after the lifted items, which must become\n    // children of the last item\n    tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));\n    range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);\n  }\n\n  dispatch(tr.lift(range, liftTarget(range)).scrollIntoView());\n  return true;\n}\n\nfunction liftOutOfList(state, dispatch, range) {\n  var tr = state.tr,\n      list = range.parent; // Merge the list items into a single big item\n\n  for (var pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {\n    pos -= list.child(i).nodeSize;\n    tr.delete(pos - 1, pos + 1);\n  }\n\n  var $start = tr.doc.resolve(range.start),\n      item = $start.nodeAfter;\n  var atStart = range.startIndex == 0,\n      atEnd = range.endIndex == list.childCount;\n  var parent = $start.node(-1),\n      indexBefore = $start.index(-1);\n\n  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list)))) {\n    return false;\n  }\n\n  var start = $start.pos,\n      end = start + item.nodeSize; // Strip off the surrounding list. At the sides where we're not at\n  // the end of the list, the existing list is closed. At sides where\n  // this is the end, it is overwritten to its end.\n\n  tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));\n  dispatch(tr.scrollIntoView());\n  return true;\n} // :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Create a command to sink the list item around the selection down\n// into an inner list.\n\n\nfunction sinkListItem(itemType) {\n  return function (state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var range = $from.blockRange($to, function (node) {\n      return node.childCount && node.firstChild.type == itemType;\n    });\n\n    if (!range) {\n      return false;\n    }\n\n    var startIndex = range.startIndex;\n\n    if (startIndex == 0) {\n      return false;\n    }\n\n    var parent = range.parent,\n        nodeBefore = parent.child(startIndex - 1);\n\n    if (nodeBefore.type != itemType) {\n      return false;\n    }\n\n    if (dispatch) {\n      var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;\n      var inner = Fragment.from(nestedBefore ? itemType.create() : null);\n      var slice = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);\n      var before = range.start,\n          after = range.end;\n      dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true)).scrollIntoView());\n    }\n\n    return true;\n  };\n}\n\nexport { addListNodes, bulletList, liftListItem, listItem, orderedList, sinkListItem, splitListItem, wrapInList };","map":{"version":3,"sources":["../src/schema-list.js"],"names":["const","let","prop","i","tr"],"mappings":"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","sourcesContent":["import {findWrapping, liftTarget, canSplit, ReplaceAroundStep} from \"prosemirror-transform\"\nimport {Slice, Fragment, NodeRange} from \"prosemirror-model\"\n\nconst olDOM = [\"ol\", 0], ulDOM = [\"ul\", 0], liDOM = [\"li\", 0]\n\n// :: NodeSpec\n// An ordered list [node spec](#model.NodeSpec). Has a single\n// attribute, `order`, which determines the number at which the list\n// starts counting, and defaults to 1. Represented as an `<ol>`\n// element.\nexport const orderedList = {\n  attrs: {order: {default: 1}},\n  parseDOM: [{tag: \"ol\", getAttrs(dom) {\n    return {order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1}\n  }}],\n  toDOM(node) {\n    return node.attrs.order == 1 ? olDOM : [\"ol\", {start: node.attrs.order}, 0]\n  }\n}\n\n// :: NodeSpec\n// A bullet list node spec, represented in the DOM as `<ul>`.\nexport const bulletList = {\n  parseDOM: [{tag: \"ul\"}],\n  toDOM() { return ulDOM }\n}\n\n// :: NodeSpec\n// A list item (`<li>`) spec.\nexport const listItem = {\n  parseDOM: [{tag: \"li\"}],\n  toDOM() { return liDOM },\n  defining: true\n}\n\nfunction add(obj, props) {\n  let copy = {}\n  for (let prop in obj) copy[prop] = obj[prop]\n  for (let prop in props) copy[prop] = props[prop]\n  return copy\n}\n\n// :: (OrderedMap<NodeSpec>, string, ?string) → OrderedMap<NodeSpec>\n// Convenience function for adding list-related node types to a map\n// specifying the nodes for a schema. Adds\n// [`orderedList`](#schema-list.orderedList) as `\"ordered_list\"`,\n// [`bulletList`](#schema-list.bulletList) as `\"bullet_list\"`, and\n// [`listItem`](#schema-list.listItem) as `\"list_item\"`.\n//\n// `itemContent` determines the content expression for the list items.\n// If you want the commands defined in this module to apply to your\n// list structure, it should have a shape like `\"paragraph block*\"` or\n// `\"paragraph (ordered_list | bullet_list)*\"`. `listGroup` can be\n// given to assign a group name to the list node types, for example\n// `\"block\"`.\nexport function addListNodes(nodes, itemContent, listGroup) {\n  return nodes.append({\n    ordered_list: add(orderedList, {content: \"list_item+\", group: listGroup}),\n    bullet_list: add(bulletList, {content: \"list_item+\", group: listGroup}),\n    list_item: add(listItem, {content: itemContent})\n  })\n}\n\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command function that wraps the selection in a list with\n// the given type an attributes. If `dispatch` is null, only return a\n// value to indicate whether this is possible, but don't actually\n// perform the change.\nexport function wrapInList(listType, attrs) {\n  return function(state, dispatch) {\n    let {$from, $to} = state.selection\n    let range = $from.blockRange($to), doJoin = false, outerRange = range\n    if (!range) return false\n    // This is at the top of an existing list item\n    if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {\n      // Don't do anything if this is the top of the list\n      if ($from.index(range.depth - 1) == 0) return false\n      let $insert = state.doc.resolve(range.start - 2)\n      outerRange = new NodeRange($insert, $insert, range.depth)\n      if (range.endIndex < range.parent.childCount)\n        range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth)\n      doJoin = true\n    }\n    let wrap = findWrapping(outerRange, listType, attrs, range)\n    if (!wrap) return false\n    if (dispatch) dispatch(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView())\n    return true\n  }\n}\n\nfunction doWrapInList(tr, range, wrappers, joinBefore, listType) {\n  let content = Fragment.empty\n  for (let i = wrappers.length - 1; i >= 0; i--)\n    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content))\n\n  tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end,\n                                new Slice(content, 0, 0), wrappers.length, true))\n\n  let found = 0\n  for (let i = 0; i < wrappers.length; i++) if (wrappers[i].type == listType) found = i + 1\n  let splitDepth = wrappers.length - found\n\n  let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent\n  for (let i = range.startIndex, e = range.endIndex, first = true; i < e; i++, first = false) {\n    if (!first && canSplit(tr.doc, splitPos, splitDepth)) {\n      tr.split(splitPos, splitDepth)\n      splitPos += 2 * splitDepth\n    }\n    splitPos += parent.child(i).nodeSize\n  }\n  return tr\n}\n\n// :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Build a command that splits a non-empty textblock at the top level\n// of a list item by also splitting that list item.\nexport function splitListItem(itemType) {\n  return function(state, dispatch) {\n    let {$from, $to, node} = state.selection\n    if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) return false\n    let grandParent = $from.node(-1)\n    if (grandParent.type != itemType) return false\n    if ($from.parent.content.size == 0) {\n      // In an empty block. If this is a nested list, the wrapping\n      // list item should be split. Otherwise, bail out and let next\n      // command handle lifting.\n      if ($from.depth == 2 || $from.node(-3).type != itemType ||\n          $from.index(-2) != $from.node(-2).childCount - 1) return false\n      if (dispatch) {\n        let wrap = Fragment.empty, keepItem = $from.index(-1) > 0\n        // Build a fragment containing empty versions of the structure\n        // from the outer list item to the parent node of the cursor\n        for (let d = $from.depth - (keepItem ? 1 : 2); d >= $from.depth - 3; d--)\n          wrap = Fragment.from($from.node(d).copy(wrap))\n        // Add a second list item with an empty default start node\n        wrap = wrap.append(Fragment.from(itemType.createAndFill()))\n        let tr = state.tr.replace($from.before(keepItem ? null : -1), $from.after(-3), new Slice(wrap, keepItem ? 3 : 2, 2))\n        tr.setSelection(state.selection.constructor.near(tr.doc.resolve($from.pos + (keepItem ? 3 : 2))))\n        dispatch(tr.scrollIntoView())\n      }\n      return true\n    }\n    let nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null\n    let tr = state.tr.delete($from.pos, $to.pos)\n    let types = nextType && [null, {type: nextType}]\n    if (!canSplit(tr.doc, $from.pos, 2, types)) return false\n    if (dispatch) dispatch(tr.split($from.pos, 2, types).scrollIntoView())\n    return true\n  }\n}\n\n// :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Create a command to lift the list item around the selection up into\n// a wrapping list.\nexport function liftListItem(itemType) {\n  return function(state, dispatch) {\n    let {$from, $to} = state.selection\n    let range = $from.blockRange($to, node => node.childCount && node.firstChild.type == itemType)\n    if (!range) return false\n    if (!dispatch) return true\n    if ($from.node(range.depth - 1).type == itemType) // Inside a parent list\n      return liftToOuterList(state, dispatch, itemType, range)\n    else // Outer list node\n      return liftOutOfList(state, dispatch, range)\n  }\n}\n\nfunction liftToOuterList(state, dispatch, itemType, range) {\n  let tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth)\n  if (end < endOfList) {\n    // There are siblings after the lifted items, which must become\n    // children of the last item\n    tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList,\n                                  new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true))\n    range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth)\n  }\n  dispatch(tr.lift(range, liftTarget(range)).scrollIntoView())\n  return true\n}\n\nfunction liftOutOfList(state, dispatch, range) {\n  let tr = state.tr, list = range.parent\n  // Merge the list items into a single big item\n  for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {\n    pos -= list.child(i).nodeSize\n    tr.delete(pos - 1, pos + 1)\n  }\n  let $start = tr.doc.resolve(range.start), item = $start.nodeAfter\n  let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount\n  let parent = $start.node(-1), indexBefore = $start.index(-1)\n  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1,\n                         item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))\n    return false\n  let start = $start.pos, end = start + item.nodeSize\n  // Strip off the surrounding list. At the sides where we're not at\n  // the end of the list, the existing list is closed. At sides where\n  // this is the end, it is overwritten to its end.\n  tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1,\n                                new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty)))\n                                          .append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))),\n                                          atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1))\n  dispatch(tr.scrollIntoView())\n  return true\n}\n\n// :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Create a command to sink the list item around the selection down\n// into an inner list.\nexport function sinkListItem(itemType) {\n  return function(state, dispatch) {\n    let {$from, $to} = state.selection\n    let range = $from.blockRange($to, node => node.childCount && node.firstChild.type == itemType)\n    if (!range) return false\n    let startIndex = range.startIndex\n    if (startIndex == 0) return false\n    let parent = range.parent, nodeBefore = parent.child(startIndex - 1)\n    if (nodeBefore.type != itemType) return false\n\n    if (dispatch) {\n      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type\n      let inner = Fragment.from(nestedBefore ? itemType.create() : null)\n      let slice = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))),\n                            nestedBefore ? 3 : 1, 0)\n      let before = range.start, after = range.end\n      dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after,\n                                                   before, after, slice, 1, true))\n               .scrollIntoView())\n    }\n    return true\n  }\n}\n"]},"metadata":{},"sourceType":"module"}