{"ast":null,"code":"/**\n * @module bindings/prosemirror\n */\nimport { createMutex } from 'lib0/mutex.js';\nimport * as PModel from 'prosemirror-model';\nimport { Plugin, PluginKey, EditorState, TextSelection } from 'prosemirror-state'; // eslint-disable-line\n\nimport * as math from 'lib0/math.js';\nimport * as object from 'lib0/object.js';\nimport * as set from 'lib0/set.js';\nimport { simpleDiff } from 'lib0/diff.js';\nimport * as error from 'lib0/error.js';\nimport * as Y from 'yjs';\nimport { absolutePositionToRelativePosition, relativePositionToAbsolutePosition } from '../lib.js';\nimport * as random from 'lib0/random.js';\n/**\n * @param {Y.Item} item\n * @param {Y.Snapshot} [snapshot]\n */\n\nexport const isVisible = (item, snapshot) => snapshot === undefined ? !item.deleted : snapshot.sv.has(item.id.client) &&\n/** @type {number} */\nsnapshot.sv.get(item.id.client) > item.id.clock && !Y.isDeleted(snapshot.ds, item.id);\n/**\n * Either a node if type is YXmlElement or an Array of text nodes if YXmlText\n * @typedef {Map<Y.AbstractType, PModel.Node | Array<PModel.Node>>} ProsemirrorMapping\n */\n\n/**\n * The unique prosemirror plugin key for prosemirrorPlugin.\n *\n * @public\n */\n\nexport const ySyncPluginKey = new PluginKey('y-sync');\n/**\n * @typedef {Object} ColorDef\n * @property {string} ColorDef.light\n * @property {string} ColorDef.dark\n */\n\n/**\n * @typedef {Object} YSyncOpts\n * @property {Array<ColorDef>} [YSyncOpts.colors]\n * @property {Map<string,ColorDef>} [YSyncOpts.colorMapping]\n * @property {Y.PermanentUserData|null} [YSyncOpts.permanentUserData]\n */\n\n/**\n * @type {Array<ColorDef>}\n */\n\nconst defaultColors = [{\n  light: '#ecd44433',\n  dark: '#ecd444'\n}];\n/**\n * @param {Map<string,ColorDef>} colorMapping\n * @param {Array<ColorDef>} colors\n * @param {string} user\n * @return {ColorDef}\n */\n\nconst getUserColor = (colorMapping, colors, user) => {\n  // @todo do not hit the same color twice if possible\n  if (!colorMapping.has(user)) {\n    if (colorMapping.size < colors.length) {\n      const usedColors = set.create();\n      colorMapping.forEach(color => usedColors.add(color));\n      colors = colors.filter(color => !usedColors.has(color));\n    }\n\n    colorMapping.set(user, random.oneOf(colors));\n  }\n\n  return (\n    /** @type {ColorDef} */\n    colorMapping.get(user)\n  );\n};\n/**\n * This plugin listens to changes in prosemirror view and keeps yXmlState and view in sync.\n *\n * This plugin also keeps references to the type and the shared document so other plugins can access it.\n * @param {Y.XmlFragment} yXmlFragment\n * @param {YSyncOpts} opts\n * @return {any} Returns a prosemirror plugin that binds to this type\n */\n\n\nexport const ySyncPlugin = (yXmlFragment, {\n  colors = defaultColors,\n  colorMapping = new Map(),\n  permanentUserData = null\n} = {}) => {\n  let changedInitialContent = false;\n  const plugin = new Plugin({\n    props: {\n      editable: state => {\n        const syncState = ySyncPluginKey.getState(state);\n        return syncState.snapshot == null && syncState.prevSnapshot == null;\n      }\n    },\n    key: ySyncPluginKey,\n    state: {\n      init: (initargs, state) => {\n        return {\n          type: yXmlFragment,\n          doc: yXmlFragment.doc,\n          binding: null,\n          snapshot: null,\n          prevSnapshot: null,\n          isChangeOrigin: false,\n          colors,\n          colorMapping,\n          permanentUserData\n        };\n      },\n      apply: (tr, pluginState) => {\n        const change = tr.getMeta(ySyncPluginKey);\n\n        if (change !== undefined) {\n          pluginState = Object.assign({}, pluginState);\n\n          for (const key in change) {\n            pluginState[key] = change[key];\n          }\n        } // always set isChangeOrigin. If undefined, this is not change origin.\n\n\n        pluginState.isChangeOrigin = change !== undefined && !!change.isChangeOrigin;\n\n        if (pluginState.binding !== null) {\n          if (change !== undefined && (change.snapshot != null || change.prevSnapshot != null)) {\n            // snapshot changed, rerender next\n            setTimeout(() => {\n              if (change.restore == null) {\n                pluginState.binding._renderSnapshot(change.snapshot, change.prevSnapshot, pluginState);\n              } else {\n                pluginState.binding._renderSnapshot(change.snapshot, change.snapshot, pluginState); // reset to current prosemirror state\n\n\n                delete pluginState.restore;\n                delete pluginState.snapshot;\n                delete pluginState.prevSnapshot;\n\n                pluginState.binding._prosemirrorChanged(pluginState.binding.prosemirrorView.state.doc);\n              }\n            }, 0);\n          }\n        }\n\n        return pluginState;\n      }\n    },\n    view: view => {\n      const binding = new ProsemirrorBinding(yXmlFragment, view); // Make sure this is called in a separate context\n\n      setTimeout(() => {\n        binding._forceRerender();\n\n        view.dispatch(view.state.tr.setMeta(ySyncPluginKey, {\n          binding\n        }));\n      }, 0);\n      return {\n        update: () => {\n          const pluginState = plugin.getState(view.state);\n\n          if (pluginState.snapshot == null && pluginState.prevSnapshot == null) {\n            const emptySize = view.state.doc.type.createAndFill().content.size;\n\n            if (changedInitialContent || view.state.doc.content.size > emptySize) {\n              changedInitialContent = true;\n\n              binding._prosemirrorChanged(view.state.doc);\n            }\n          }\n        },\n        destroy: () => {\n          binding.destroy();\n        }\n      };\n    }\n  });\n  return plugin;\n};\n/**\n * @param {any} tr\n * @param {any} relSel\n * @param {ProsemirrorBinding} binding\n */\n\nconst restoreRelativeSelection = (tr, relSel, binding) => {\n  if (relSel !== null && relSel.anchor !== null && relSel.head !== null) {\n    const anchor = relativePositionToAbsolutePosition(binding.doc, binding.type, relSel.anchor, binding.mapping);\n    const head = relativePositionToAbsolutePosition(binding.doc, binding.type, relSel.head, binding.mapping);\n\n    if (anchor !== null && head !== null) {\n      tr = tr.setSelection(TextSelection.create(tr.doc, anchor, head));\n    }\n  }\n};\n\nexport const getRelativeSelection = (pmbinding, state) => ({\n  anchor: absolutePositionToRelativePosition(state.selection.anchor, pmbinding.type, pmbinding.mapping),\n  head: absolutePositionToRelativePosition(state.selection.head, pmbinding.type, pmbinding.mapping)\n});\n/**\n * Binding for prosemirror.\n *\n * @protected\n */\n\nexport class ProsemirrorBinding {\n  /**\n   * @param {Y.XmlFragment} yXmlFragment The bind source\n   * @param {any} prosemirrorView The target binding\n   */\n  constructor(yXmlFragment, prosemirrorView) {\n    this.type = yXmlFragment;\n    this.prosemirrorView = prosemirrorView;\n    this.mux = createMutex();\n    /**\n     * @type {ProsemirrorMapping}\n     */\n\n    this.mapping = new Map();\n    this._observeFunction = this._typeChanged.bind(this);\n    /**\n     * @type {Y.Doc}\n     */\n    // @ts-ignore\n\n    this.doc = yXmlFragment.doc;\n    /**\n     * current selection as relative positions in the Yjs model\n     */\n\n    this.beforeTransactionSelection = null;\n    this.doc.on('beforeTransaction', e => {\n      if (this.beforeTransactionSelection === null) {\n        this.beforeTransactionSelection = getRelativeSelection(this, prosemirrorView.state);\n      }\n    });\n    this.doc.on('afterTransaction', e => {\n      this.beforeTransactionSelection = null;\n    });\n    yXmlFragment.observeDeep(this._observeFunction);\n  }\n\n  renderSnapshot(snapshot, prevSnapshot) {\n    if (!prevSnapshot) {\n      prevSnapshot = Y.createSnapshot(Y.createDeleteSet(), new Map());\n    }\n\n    this.prosemirrorView.dispatch(this.prosemirrorView.state.tr.setMeta(ySyncPluginKey, {\n      snapshot,\n      prevSnapshot\n    }));\n  }\n\n  unrenderSnapshot() {\n    this.mapping = new Map();\n    this.mux(() => {\n      const fragmentContent = this.type.toArray().map(t => createNodeFromYElement(\n      /** @type {Y.XmlElement} */\n      t, this.prosemirrorView.state.schema, this.mapping)).filter(n => n !== null); // @ts-ignore\n\n      const tr = this.prosemirrorView.state.tr.replace(0, this.prosemirrorView.state.doc.content.size, new PModel.Slice(new PModel.Fragment(fragmentContent), 0, 0));\n      tr.setMeta(ySyncPluginKey, {\n        snapshot: null,\n        prevSnapshot: null\n      });\n      this.prosemirrorView.dispatch(tr);\n    });\n  }\n\n  _forceRerender() {\n    this.mapping = new Map();\n    this.mux(() => {\n      const fragmentContent = this.type.toArray().map(t => createNodeFromYElement(\n      /** @type {Y.XmlElement} */\n      t, this.prosemirrorView.state.schema, this.mapping)).filter(n => n !== null); // @ts-ignore\n\n      const tr = this.prosemirrorView.state.tr.replace(0, this.prosemirrorView.state.doc.content.size, new PModel.Slice(new PModel.Fragment(fragmentContent), 0, 0));\n      this.prosemirrorView.dispatch(tr);\n    });\n  }\n  /**\n   * @param {Y.Snapshot} snapshot\n   * @param {Y.Snapshot} prevSnapshot\n   * @param {Object} pluginState\n   */\n\n\n  _renderSnapshot(snapshot, prevSnapshot, pluginState) {\n    if (!snapshot) {\n      snapshot = Y.snapshot(this.doc);\n    } // clear mapping because we are going to rerender\n\n\n    this.mapping = new Map();\n    this.mux(() => {\n      this.doc.transact(transaction => {\n        // before rendering, we are going to sanitize ops and split deleted ops\n        // if they were deleted by seperate users.\n        const pud = pluginState.permanentUserData;\n\n        if (pud) {\n          pud.dss.forEach(ds => {\n            Y.iterateDeletedStructs(transaction, ds, item => {});\n          });\n        }\n\n        const computeYChange = (type, id) => {\n          const user = type === 'added' ? pud.getUserByClientId(id.client) : pud.getUserByDeletedId(id);\n          return {\n            user,\n            type,\n            color: getUserColor(pluginState.colorMapping, pluginState.colors, user)\n          };\n        }; // Create document fragment and render\n\n\n        const fragmentContent = Y.typeListToArraySnapshot(this.type, new Y.Snapshot(prevSnapshot.ds, snapshot.sv)).map(t => {\n          if (!t._item.deleted || isVisible(t._item, snapshot) || isVisible(t._item, prevSnapshot)) {\n            return createNodeFromYElement(t, this.prosemirrorView.state.schema, new Map(), snapshot, prevSnapshot, computeYChange);\n          } else {\n            // No need to render elements that are not visible by either snapshot.\n            // If a client adds and deletes content in the same snapshot the element is not visible by either snapshot.\n            return null;\n          }\n        }).filter(n => n !== null); // @ts-ignore\n\n        const tr = this.prosemirrorView.state.tr.replace(0, this.prosemirrorView.state.doc.content.size, new PModel.Slice(new PModel.Fragment(fragmentContent), 0, 0));\n        this.prosemirrorView.dispatch(tr);\n      }, ySyncPluginKey);\n    });\n  }\n  /**\n   * @param {Array<Y.YEvent>} events\n   * @param {Y.Transaction} transaction\n   */\n\n\n  _typeChanged(events, transaction) {\n    const syncState = ySyncPluginKey.getState(this.prosemirrorView.state);\n\n    if (events.length === 0 || syncState.snapshot != null || syncState.prevSnapshot != null) {\n      // drop out if snapshot is active\n      this.renderSnapshot(syncState.snapshot, syncState.prevSnapshot);\n      return;\n    }\n\n    this.mux(() => {\n      /**\n       * @param {any} _\n       * @param {Y.AbstractType} type\n       */\n      const delType = (_, type) => this.mapping.delete(type);\n\n      Y.iterateDeletedStructs(transaction, transaction.deleteSet, struct => struct.constructor === Y.Item && this.mapping.delete(\n      /** @type {Y.ContentType} */\n\n      /** @type {Y.Item} */\n      struct.content.type));\n      transaction.changed.forEach(delType);\n      transaction.changedParentTypes.forEach(delType);\n      const fragmentContent = this.type.toArray().map(t => createNodeIfNotExists(\n      /** @type {Y.XmlElement | Y.XmlHook} */\n      t, this.prosemirrorView.state.schema, this.mapping)).filter(n => n !== null); // @ts-ignore\n\n      let tr = this.prosemirrorView.state.tr.replace(0, this.prosemirrorView.state.doc.content.size, new PModel.Slice(new PModel.Fragment(fragmentContent), 0, 0));\n      restoreRelativeSelection(tr, this.beforeTransactionSelection, this);\n      tr = tr.setMeta(ySyncPluginKey, {\n        isChangeOrigin: true\n      });\n\n      if (this.beforeTransactionSelection !== null && this.prosemirrorView.hasFocus()) {\n        tr.scrollIntoView();\n      }\n\n      this.prosemirrorView.dispatch(tr);\n    });\n  }\n\n  _prosemirrorChanged(doc) {\n    this.mux(() => {\n      this.doc.transact(() => {\n        updateYFragment(this.doc, this.type, doc, this.mapping);\n        this.beforeTransactionSelection = getRelativeSelection(this, this.prosemirrorView.state);\n      }, ySyncPluginKey);\n    });\n  }\n\n  destroy() {\n    this.type.unobserveDeep(this._observeFunction);\n  }\n\n}\n/**\n * @private\n * @param {Y.XmlElement | Y.XmlHook} el\n * @param {PModel.Schema} schema\n * @param {ProsemirrorMapping} mapping\n * @param {Y.Snapshot} [snapshot]\n * @param {Y.Snapshot} [prevSnapshot]\n * @param {function('removed' | 'added', Y.ID):any} [computeYChange]\n * @return {PModel.Node | null}\n */\n\nexport const createNodeIfNotExists = (el, schema, mapping, snapshot, prevSnapshot, computeYChange) => {\n  const node =\n  /** @type {PModel.Node} */\n  mapping.get(el);\n\n  if (node === undefined) {\n    if (el instanceof Y.XmlElement) {\n      return createNodeFromYElement(el, schema, mapping, snapshot, prevSnapshot, computeYChange);\n    } else {\n      throw error.methodUnimplemented(); // we are currently not handling hooks\n    }\n  }\n\n  return node;\n};\n/**\n * @private\n * @param {Y.XmlElement} el\n * @param {any} schema\n * @param {ProsemirrorMapping} mapping\n * @param {Y.Snapshot} [snapshot]\n * @param {Y.Snapshot} [prevSnapshot]\n * @param {function('removed' | 'added', Y.ID):any} [computeYChange]\n * @return {PModel.Node | null} Returns node if node could be created. Otherwise it deletes the yjs type and returns null\n */\n\nexport const createNodeFromYElement = (el, schema, mapping, snapshot, prevSnapshot, computeYChange) => {\n  const children = [];\n\n  const createChildren = type => {\n    if (type.constructor === Y.XmlElement) {\n      const n = createNodeIfNotExists(type, schema, mapping, snapshot, prevSnapshot, computeYChange);\n\n      if (n !== null) {\n        children.push(n);\n      }\n    } else {\n      const ns = createTextNodesFromYText(type, schema, mapping, snapshot, prevSnapshot, computeYChange);\n\n      if (ns !== null) {\n        ns.forEach(textchild => {\n          if (textchild !== null) {\n            children.push(textchild);\n          }\n        });\n      }\n    }\n  };\n\n  if (snapshot === undefined || prevSnapshot === undefined) {\n    el.toArray().forEach(createChildren);\n  } else {\n    Y.typeListToArraySnapshot(el, new Y.Snapshot(prevSnapshot.ds, snapshot.sv)).forEach(createChildren);\n  }\n\n  try {\n    const attrs = el.getAttributes(snapshot);\n\n    if (snapshot !== undefined) {\n      if (!isVisible(\n      /** @type {Y.Item} */\n      el._item, snapshot)) {\n        attrs.ychange = computeYChange ? computeYChange('removed',\n        /** @type {Y.Item} */\n        el._item.id) : {\n          type: 'removed'\n        };\n      } else if (!isVisible(\n      /** @type {Y.Item} */\n      el._item, prevSnapshot)) {\n        attrs.ychange = computeYChange ? computeYChange('added',\n        /** @type {Y.Item} */\n        el._item.id) : {\n          type: 'added'\n        };\n      }\n    }\n\n    const node = schema.node(el.nodeName, attrs, children);\n    mapping.set(el, node);\n    return node;\n  } catch (e) {\n    // an error occured while creating the node. This is probably a result of a concurrent action.\n\n    /** @type {Y.Doc} */\n    el.doc.transact(transaction => {\n      /** @type {Y.Item} */\n      el._item.delete(transaction);\n    }, ySyncPluginKey);\n    mapping.delete(el);\n    return null;\n  }\n};\n/**\n * @private\n * @param {Y.XmlText} text\n * @param {any} schema\n * @param {ProsemirrorMapping} mapping\n * @param {Y.Snapshot} [snapshot]\n * @param {Y.Snapshot} [prevSnapshot]\n * @param {function('removed' | 'added', Y.ID):any} [computeYChange]\n * @return {Array<PModel.Node>|null}\n */\n\nexport const createTextNodesFromYText = (text, schema, mapping, snapshot, prevSnapshot, computeYChange) => {\n  const nodes = [];\n  const deltas = text.toDelta(snapshot, prevSnapshot, computeYChange);\n\n  try {\n    for (let i = 0; i < deltas.length; i++) {\n      const delta = deltas[i];\n      const marks = [];\n\n      for (const markName in delta.attributes) {\n        marks.push(schema.mark(markName, delta.attributes[markName]));\n      }\n\n      nodes.push(schema.text(delta.insert, marks));\n    }\n  } catch (e) {\n    // an error occured while creating the node. This is probably a result of a concurrent action.\n\n    /** @type {Y.Doc} */\n    text.doc.transact(transaction => {\n      /** @type {Y.Item} */\n      text._item.delete(transaction);\n    }, ySyncPluginKey);\n    return null;\n  } // @ts-ignore\n\n\n  return nodes;\n};\n/**\n * @private\n * @param {Array<any>} nodes prosemirror node\n * @param {ProsemirrorMapping} mapping\n * @return {Y.XmlText}\n */\n\nexport const createTypeFromTextNodes = (nodes, mapping) => {\n  const type = new Y.XmlText();\n  const delta = nodes.map(node => ({\n    // @ts-ignore\n    insert: node.text,\n    attributes: marksToAttributes(node.marks)\n  }));\n  type.applyDelta(delta);\n  mapping.set(type, nodes);\n  return type;\n};\n/**\n * @private\n * @param {any} node prosemirror node\n * @param {ProsemirrorMapping} mapping\n * @return {Y.XmlElement}\n */\n\nexport const createTypeFromElementNode = (node, mapping) => {\n  const type = new Y.XmlElement(node.type.name);\n\n  for (const key in node.attrs) {\n    const val = node.attrs[key];\n\n    if (val !== null && key !== 'ychange') {\n      type.setAttribute(key, val);\n    }\n  }\n\n  type.insert(0, normalizePNodeContent(node).map(n => createTypeFromTextOrElementNode(n, mapping)));\n  mapping.set(type, node);\n  return type;\n};\n/**\n * @private\n * @param {PModel.Node|Array<PModel.Node>} node prosemirror text node\n * @param {ProsemirrorMapping} mapping\n * @return {Y.XmlElement|Y.XmlText}\n */\n\nexport const createTypeFromTextOrElementNode = (node, mapping) => node instanceof Array ? createTypeFromTextNodes(node, mapping) : createTypeFromElementNode(node, mapping);\n\nconst equalAttrs = (pattrs, yattrs) => {\n  const keys = Object.keys(pattrs).filter(key => pattrs[key] !== null);\n  let eq = keys.length === Object.keys(yattrs).filter(key => yattrs[key] !== null).length;\n\n  for (let i = 0; i < keys.length && eq; i++) {\n    const key = keys[i];\n    const l = pattrs[key];\n    const r = yattrs[key];\n    eq = key === 'ychange' || l === r || typeof l === 'object' && typeof r === 'object' && equalAttrs(l, r);\n  }\n\n  return eq;\n};\n/**\n * @typedef {Array<Array<PModel.Node>|PModel.Node>} NormalizedPNodeContent\n */\n\n/**\n * @param {any} pnode\n * @return {NormalizedPNodeContent}\n */\n\n\nexport const normalizePNodeContent = pnode => {\n  const c = pnode.content.content;\n  const res = [];\n\n  for (let i = 0; i < c.length; i++) {\n    const n = c[i];\n\n    if (n.isText) {\n      const textNodes = [];\n\n      for (let tnode = c[i]; i < c.length && tnode.isText; tnode = c[++i]) {\n        textNodes.push(tnode);\n      }\n\n      i--;\n      res.push(textNodes);\n    } else {\n      res.push(n);\n    }\n  }\n\n  return res;\n};\n/**\n * @param {Y.XmlText} ytext\n * @param {Array<any>} ptexts\n */\n\nconst equalYTextPText = (ytext, ptexts) => {\n  const delta = ytext.toDelta();\n  return delta.length === ptexts.length && delta.every((d, i) => d.insert ===\n  /** @type {any} */\n  ptexts[i].text && object.keys(d.attributes || {}).length === ptexts[i].marks.length && ptexts[i].marks.every(mark => equalAttrs(d.attributes[mark.type.name] || {}, mark.attrs)));\n};\n/**\n * @param {Y.XmlElement|Y.XmlText|Y.XmlHook} ytype\n * @param {any|Array<any>} pnode\n */\n\n\nconst equalYTypePNode = (ytype, pnode) => {\n  if (ytype instanceof Y.XmlElement && !(pnode instanceof Array) && matchNodeName(ytype, pnode)) {\n    const normalizedContent = normalizePNodeContent(pnode);\n    return ytype._length === normalizedContent.length && equalAttrs(ytype.getAttributes(), pnode.attrs) && ytype.toArray().every((ychild, i) => equalYTypePNode(ychild, normalizedContent[i]));\n  }\n\n  return ytype instanceof Y.XmlText && pnode instanceof Array && equalYTextPText(ytype, pnode);\n};\n/**\n * @param {PModel.Node | Array<PModel.Node> | undefined} mapped\n * @param {PModel.Node | Array<PModel.Node>} pcontent\n */\n\n\nconst mappedIdentity = (mapped, pcontent) => mapped === pcontent || mapped instanceof Array && pcontent instanceof Array && mapped.length === pcontent.length && mapped.every((a, i) => pcontent[i] === a);\n/**\n * @param {Y.XmlElement} ytype\n * @param {PModel.Node} pnode\n * @param {ProsemirrorMapping} mapping\n * @return {{ foundMappedChild: boolean, equalityFactor: number }}\n */\n\n\nconst computeChildEqualityFactor = (ytype, pnode, mapping) => {\n  const yChildren = ytype.toArray();\n  const pChildren = normalizePNodeContent(pnode);\n  const pChildCnt = pChildren.length;\n  const yChildCnt = yChildren.length;\n  const minCnt = math.min(yChildCnt, pChildCnt);\n  let left = 0;\n  let right = 0;\n  let foundMappedChild = false;\n\n  for (; left < minCnt; left++) {\n    const leftY = yChildren[left];\n    const leftP = pChildren[left];\n\n    if (mappedIdentity(mapping.get(leftY), leftP)) {\n      foundMappedChild = true; // definite (good) match!\n    } else if (!equalYTypePNode(leftY, leftP)) {\n      break;\n    }\n  }\n\n  for (; left + right < minCnt; right++) {\n    const rightY = yChildren[yChildCnt - right - 1];\n    const rightP = pChildren[pChildCnt - right - 1];\n\n    if (mappedIdentity(mapping.get(rightY), rightP)) {\n      foundMappedChild = true;\n    } else if (!equalYTypePNode(rightY, rightP)) {\n      break;\n    }\n  }\n\n  return {\n    equalityFactor: left + right,\n    foundMappedChild\n  };\n};\n\nconst ytextTrans = ytext => {\n  let str = '';\n  /**\n   * @type {Y.Item|null}\n   */\n\n  let n = ytext._start;\n  const nAttrs = {};\n\n  while (n !== null) {\n    if (!n.deleted) {\n      if (n.countable && n.content instanceof Y.ContentString) {\n        str += n.content.str;\n      } else if (n.content instanceof Y.ContentFormat) {\n        nAttrs[n.content.key] = null;\n      }\n    }\n\n    n = n.right;\n  }\n\n  return {\n    str,\n    nAttrs\n  };\n};\n/**\n * @todo test this more\n *\n * @param {Y.Text} ytext\n * @param {Array<any>} ptexts\n * @param {ProsemirrorMapping} mapping\n */\n\n\nconst updateYText = (ytext, ptexts, mapping) => {\n  mapping.set(ytext, ptexts);\n  const {\n    nAttrs,\n    str\n  } = ytextTrans(ytext);\n  const content = ptexts.map(p => ({\n    insert:\n    /** @type {any} */\n    p.text,\n    attributes: Object.assign({}, nAttrs, marksToAttributes(p.marks))\n  }));\n  const {\n    insert,\n    remove,\n    index\n  } = simpleDiff(str, content.map(c => c.insert).join(''));\n  ytext.delete(index, remove);\n  ytext.insert(index, insert);\n  ytext.applyDelta(content.map(c => ({\n    retain: c.insert.length,\n    attributes: c.attributes\n  })));\n};\n\nconst marksToAttributes = marks => {\n  const pattrs = {};\n  marks.forEach(mark => {\n    if (mark.type.name !== 'ychange') {\n      pattrs[mark.type.name] = mark.attrs;\n    }\n  });\n  return pattrs;\n};\n/**\n * @private\n * @param {Y.Doc} y\n * @param {Y.XmlFragment} yDomFragment\n * @param {any} pNode\n * @param {ProsemirrorMapping} mapping\n */\n\n\nconst updateYFragment = (y, yDomFragment, pNode, mapping) => {\n  if (yDomFragment instanceof Y.XmlElement && yDomFragment.nodeName !== pNode.type.name) {\n    throw new Error('node name mismatch!');\n  }\n\n  mapping.set(yDomFragment, pNode); // update attributes\n\n  if (yDomFragment instanceof Y.XmlElement) {\n    const yDomAttrs = yDomFragment.getAttributes();\n    const pAttrs = pNode.attrs;\n\n    for (const key in pAttrs) {\n      if (pAttrs[key] !== null) {\n        if (yDomAttrs[key] !== pAttrs[key] && key !== 'ychange') {\n          yDomFragment.setAttribute(key, pAttrs[key]);\n        }\n      } else {\n        yDomFragment.removeAttribute(key);\n      }\n    } // remove all keys that are no longer in pAttrs\n\n\n    for (const key in yDomAttrs) {\n      if (pAttrs[key] === undefined) {\n        yDomFragment.removeAttribute(key);\n      }\n    }\n  } // update children\n\n\n  const pChildren = normalizePNodeContent(pNode);\n  const pChildCnt = pChildren.length;\n  const yChildren = yDomFragment.toArray();\n  const yChildCnt = yChildren.length;\n  const minCnt = math.min(pChildCnt, yChildCnt);\n  let left = 0;\n  let right = 0; // find number of matching elements from left\n\n  for (; left < minCnt; left++) {\n    const leftY = yChildren[left];\n    const leftP = pChildren[left];\n\n    if (!mappedIdentity(mapping.get(leftY), leftP)) {\n      if (equalYTypePNode(leftY, leftP)) {\n        // update mapping\n        mapping.set(leftY, leftP);\n      } else {\n        break;\n      }\n    }\n  } // find number of matching elements from right\n\n\n  for (; right + left + 1 < minCnt; right++) {\n    const rightY = yChildren[yChildCnt - right - 1];\n    const rightP = pChildren[pChildCnt - right - 1];\n\n    if (!mappedIdentity(mapping.get(rightY), rightP)) {\n      if (equalYTypePNode(rightY, rightP)) {\n        // update mapping\n        mapping.set(rightY, rightP);\n      } else {\n        break;\n      }\n    }\n  }\n\n  y.transact(() => {\n    // try to compare and update\n    while (yChildCnt - left - right > 0 && pChildCnt - left - right > 0) {\n      const leftY = yChildren[left];\n      const leftP = pChildren[left];\n      const rightY = yChildren[yChildCnt - right - 1];\n      const rightP = pChildren[pChildCnt - right - 1];\n\n      if (leftY instanceof Y.XmlText && leftP instanceof Array) {\n        if (!equalYTextPText(leftY, leftP)) {\n          updateYText(leftY, leftP, mapping);\n        }\n\n        left += 1;\n      } else {\n        let updateLeft = leftY instanceof Y.XmlElement && matchNodeName(leftY, leftP);\n        let updateRight = rightY instanceof Y.XmlElement && matchNodeName(rightY, rightP);\n\n        if (updateLeft && updateRight) {\n          // decide which which element to update\n          const equalityLeft = computeChildEqualityFactor(\n          /** @type {Y.XmlElement} */\n          leftY,\n          /** @type {PModel.Node} */\n          leftP, mapping);\n          const equalityRight = computeChildEqualityFactor(\n          /** @type {Y.XmlElement} */\n          rightY,\n          /** @type {PModel.Node} */\n          rightP, mapping);\n\n          if (equalityLeft.foundMappedChild && !equalityRight.foundMappedChild) {\n            updateRight = false;\n          } else if (!equalityLeft.foundMappedChild && equalityRight.foundMappedChild) {\n            updateLeft = false;\n          } else if (equalityLeft.equalityFactor < equalityRight.equalityFactor) {\n            updateLeft = false;\n          } else {\n            updateRight = false;\n          }\n        }\n\n        if (updateLeft) {\n          updateYFragment(y,\n          /** @type {Y.XmlFragment} */\n          leftY,\n          /** @type {PModel.Node} */\n          leftP, mapping);\n          left += 1;\n        } else if (updateRight) {\n          updateYFragment(y,\n          /** @type {Y.XmlFragment} */\n          rightY,\n          /** @type {PModel.Node} */\n          rightP, mapping);\n          right += 1;\n        } else {\n          yDomFragment.delete(left, 1);\n          yDomFragment.insert(left, [createTypeFromTextOrElementNode(leftP, mapping)]);\n          left += 1;\n        }\n      }\n    }\n\n    const yDelLen = yChildCnt - left - right;\n\n    if (yDelLen > 0) {\n      yDomFragment.delete(left, yDelLen);\n    }\n\n    if (left + right < pChildCnt) {\n      const ins = [];\n\n      for (let i = left; i < pChildCnt - right; i++) {\n        ins.push(createTypeFromTextOrElementNode(pChildren[i], mapping));\n      }\n\n      yDomFragment.insert(left, ins);\n    }\n  }, ySyncPluginKey);\n};\n/**\n * @function\n * @param {Y.XmlElement} yElement\n * @param {any} pNode Prosemirror Node\n */\n\n\nconst matchNodeName = (yElement, pNode) => !(pNode instanceof Array) && yElement.nodeName === pNode.type.name;","map":{"version":3,"sources":["/Users/meeopp/Development/Others/editor-yjs/client/node_modules/y-prosemirror/src/plugins/sync-plugin.js"],"names":["createMutex","PModel","Plugin","PluginKey","EditorState","TextSelection","math","object","set","simpleDiff","error","Y","absolutePositionToRelativePosition","relativePositionToAbsolutePosition","random","isVisible","item","snapshot","undefined","deleted","sv","has","id","client","get","clock","isDeleted","ds","ySyncPluginKey","defaultColors","light","dark","getUserColor","colorMapping","colors","user","size","length","usedColors","create","forEach","color","add","filter","oneOf","ySyncPlugin","yXmlFragment","Map","permanentUserData","changedInitialContent","plugin","props","editable","state","syncState","getState","prevSnapshot","key","init","initargs","type","doc","binding","isChangeOrigin","apply","tr","pluginState","change","getMeta","Object","assign","setTimeout","restore","_renderSnapshot","_prosemirrorChanged","prosemirrorView","view","ProsemirrorBinding","_forceRerender","dispatch","setMeta","update","emptySize","createAndFill","content","destroy","restoreRelativeSelection","relSel","anchor","head","mapping","setSelection","getRelativeSelection","pmbinding","selection","constructor","mux","_observeFunction","_typeChanged","bind","beforeTransactionSelection","on","e","observeDeep","renderSnapshot","createSnapshot","createDeleteSet","unrenderSnapshot","fragmentContent","toArray","map","t","createNodeFromYElement","schema","n","replace","Slice","Fragment","transact","transaction","pud","dss","iterateDeletedStructs","computeYChange","getUserByClientId","getUserByDeletedId","typeListToArraySnapshot","Snapshot","_item","events","delType","_","delete","deleteSet","struct","Item","changed","changedParentTypes","createNodeIfNotExists","hasFocus","scrollIntoView","updateYFragment","unobserveDeep","el","node","XmlElement","methodUnimplemented","children","createChildren","push","ns","createTextNodesFromYText","textchild","attrs","getAttributes","ychange","nodeName","text","nodes","deltas","toDelta","i","delta","marks","markName","attributes","mark","insert","createTypeFromTextNodes","XmlText","marksToAttributes","applyDelta","createTypeFromElementNode","name","val","setAttribute","normalizePNodeContent","createTypeFromTextOrElementNode","Array","equalAttrs","pattrs","yattrs","keys","eq","l","r","pnode","c","res","isText","textNodes","tnode","equalYTextPText","ytext","ptexts","every","d","equalYTypePNode","ytype","matchNodeName","normalizedContent","_length","ychild","mappedIdentity","mapped","pcontent","a","computeChildEqualityFactor","yChildren","pChildren","pChildCnt","yChildCnt","minCnt","min","left","right","foundMappedChild","leftY","leftP","rightY","rightP","equalityFactor","ytextTrans","str","_start","nAttrs","countable","ContentString","ContentFormat","updateYText","p","remove","index","join","retain","y","yDomFragment","pNode","Error","yDomAttrs","pAttrs","removeAttribute","updateLeft","updateRight","equalityLeft","equalityRight","yDelLen","ins","yElement"],"mappings":"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","sourcesContent":["/**\n * @module bindings/prosemirror\n */\n\nimport { createMutex } from 'lib0/mutex.js'\nimport * as PModel from 'prosemirror-model'\nimport { Plugin, PluginKey, EditorState, TextSelection } from 'prosemirror-state' // eslint-disable-line\nimport * as math from 'lib0/math.js'\nimport * as object from 'lib0/object.js'\nimport * as set from 'lib0/set.js'\nimport { simpleDiff } from 'lib0/diff.js'\nimport * as error from 'lib0/error.js'\nimport * as Y from 'yjs'\nimport { absolutePositionToRelativePosition, relativePositionToAbsolutePosition } from '../lib.js'\nimport * as random from 'lib0/random.js'\n\n/**\n * @param {Y.Item} item\n * @param {Y.Snapshot} [snapshot]\n */\nexport const isVisible = (item, snapshot) => snapshot === undefined ? !item.deleted : (snapshot.sv.has(item.id.client) && /** @type {number} */ (snapshot.sv.get(item.id.client)) > item.id.clock && !Y.isDeleted(snapshot.ds, item.id))\n\n/**\n * Either a node if type is YXmlElement or an Array of text nodes if YXmlText\n * @typedef {Map<Y.AbstractType, PModel.Node | Array<PModel.Node>>} ProsemirrorMapping\n */\n\n/**\n * The unique prosemirror plugin key for prosemirrorPlugin.\n *\n * @public\n */\nexport const ySyncPluginKey = new PluginKey('y-sync')\n\n/**\n * @typedef {Object} ColorDef\n * @property {string} ColorDef.light\n * @property {string} ColorDef.dark\n */\n\n/**\n * @typedef {Object} YSyncOpts\n * @property {Array<ColorDef>} [YSyncOpts.colors]\n * @property {Map<string,ColorDef>} [YSyncOpts.colorMapping]\n * @property {Y.PermanentUserData|null} [YSyncOpts.permanentUserData]\n */\n\n/**\n * @type {Array<ColorDef>}\n */\nconst defaultColors = [{ light: '#ecd44433', dark: '#ecd444' }]\n\n/**\n * @param {Map<string,ColorDef>} colorMapping\n * @param {Array<ColorDef>} colors\n * @param {string} user\n * @return {ColorDef}\n */\nconst getUserColor = (colorMapping, colors, user) => {\n  // @todo do not hit the same color twice if possible\n  if (!colorMapping.has(user)) {\n    if (colorMapping.size < colors.length) {\n      const usedColors = set.create()\n      colorMapping.forEach(color => usedColors.add(color))\n      colors = colors.filter(color => !usedColors.has(color))\n    }\n    colorMapping.set(user, random.oneOf(colors))\n  }\n  return /** @type {ColorDef} */ (colorMapping.get(user))\n}\n\n/**\n * This plugin listens to changes in prosemirror view and keeps yXmlState and view in sync.\n *\n * This plugin also keeps references to the type and the shared document so other plugins can access it.\n * @param {Y.XmlFragment} yXmlFragment\n * @param {YSyncOpts} opts\n * @return {any} Returns a prosemirror plugin that binds to this type\n */\nexport const ySyncPlugin = (yXmlFragment, { colors = defaultColors, colorMapping = new Map(), permanentUserData = null } = {}) => {\n  let changedInitialContent = false\n  const plugin = new Plugin({\n    props: {\n      editable: (state) => {\n        const syncState = ySyncPluginKey.getState(state)\n        return syncState.snapshot == null && syncState.prevSnapshot == null\n      }\n    },\n    key: ySyncPluginKey,\n    state: {\n      init: (initargs, state) => {\n        return {\n          type: yXmlFragment,\n          doc: yXmlFragment.doc,\n          binding: null,\n          snapshot: null,\n          prevSnapshot: null,\n          isChangeOrigin: false,\n          colors,\n          colorMapping,\n          permanentUserData\n        }\n      },\n      apply: (tr, pluginState) => {\n        const change = tr.getMeta(ySyncPluginKey)\n        if (change !== undefined) {\n          pluginState = Object.assign({}, pluginState)\n          for (const key in change) {\n            pluginState[key] = change[key]\n          }\n        }\n        // always set isChangeOrigin. If undefined, this is not change origin.\n        pluginState.isChangeOrigin = change !== undefined && !!change.isChangeOrigin\n        if (pluginState.binding !== null) {\n          if (change !== undefined && (change.snapshot != null || change.prevSnapshot != null)) {\n            // snapshot changed, rerender next\n            setTimeout(() => {\n              if (change.restore == null) {\n                pluginState.binding._renderSnapshot(change.snapshot, change.prevSnapshot, pluginState)\n              } else {\n                pluginState.binding._renderSnapshot(change.snapshot, change.snapshot, pluginState)\n                // reset to current prosemirror state\n                delete pluginState.restore\n                delete pluginState.snapshot\n                delete pluginState.prevSnapshot\n                pluginState.binding._prosemirrorChanged(pluginState.binding.prosemirrorView.state.doc)\n              }\n            }, 0)\n          }\n        }\n        return pluginState\n      }\n    },\n    view: view => {\n      const binding = new ProsemirrorBinding(yXmlFragment, view)\n      // Make sure this is called in a separate context\n      setTimeout(() => {\n        binding._forceRerender()\n        view.dispatch(view.state.tr.setMeta(ySyncPluginKey, { binding }))\n      }, 0)\n      return {\n        update: () => {\n          const pluginState = plugin.getState(view.state)\n          if (pluginState.snapshot == null && pluginState.prevSnapshot == null) {\n            const emptySize = view.state.doc.type.createAndFill().content.size\n            if (changedInitialContent || view.state.doc.content.size > emptySize) {\n              changedInitialContent = true\n              binding._prosemirrorChanged(view.state.doc)\n            }\n          }\n        },\n        destroy: () => {\n          binding.destroy()\n        }\n      }\n    }\n  })\n  return plugin\n}\n\n/**\n * @param {any} tr\n * @param {any} relSel\n * @param {ProsemirrorBinding} binding\n */\nconst restoreRelativeSelection = (tr, relSel, binding) => {\n  if (relSel !== null && relSel.anchor !== null && relSel.head !== null) {\n    const anchor = relativePositionToAbsolutePosition(binding.doc, binding.type, relSel.anchor, binding.mapping)\n    const head = relativePositionToAbsolutePosition(binding.doc, binding.type, relSel.head, binding.mapping)\n    if (anchor !== null && head !== null) {\n      tr = tr.setSelection(TextSelection.create(tr.doc, anchor, head))\n    }\n  }\n}\n\nexport const getRelativeSelection = (pmbinding, state) => ({\n  anchor: absolutePositionToRelativePosition(state.selection.anchor, pmbinding.type, pmbinding.mapping),\n  head: absolutePositionToRelativePosition(state.selection.head, pmbinding.type, pmbinding.mapping)\n})\n\n/**\n * Binding for prosemirror.\n *\n * @protected\n */\nexport class ProsemirrorBinding {\n  /**\n   * @param {Y.XmlFragment} yXmlFragment The bind source\n   * @param {any} prosemirrorView The target binding\n   */\n  constructor (yXmlFragment, prosemirrorView) {\n    this.type = yXmlFragment\n    this.prosemirrorView = prosemirrorView\n    this.mux = createMutex()\n    /**\n     * @type {ProsemirrorMapping}\n     */\n    this.mapping = new Map()\n    this._observeFunction = this._typeChanged.bind(this)\n    /**\n     * @type {Y.Doc}\n     */\n    // @ts-ignore\n    this.doc = yXmlFragment.doc\n    /**\n     * current selection as relative positions in the Yjs model\n     */\n    this.beforeTransactionSelection = null\n    this.doc.on('beforeTransaction', e => {\n      if (this.beforeTransactionSelection === null) {\n        this.beforeTransactionSelection = getRelativeSelection(this, prosemirrorView.state)\n      }\n    })\n    this.doc.on('afterTransaction', e => {\n      this.beforeTransactionSelection = null\n    })\n    yXmlFragment.observeDeep(this._observeFunction)\n  }\n\n  renderSnapshot (snapshot, prevSnapshot) {\n    if (!prevSnapshot) {\n      prevSnapshot = Y.createSnapshot(Y.createDeleteSet(), new Map())\n    }\n    this.prosemirrorView.dispatch(this.prosemirrorView.state.tr.setMeta(ySyncPluginKey, { snapshot, prevSnapshot }))\n  }\n\n  unrenderSnapshot () {\n    this.mapping = new Map()\n    this.mux(() => {\n      const fragmentContent = this.type.toArray().map(t => createNodeFromYElement(/** @type {Y.XmlElement} */ (t), this.prosemirrorView.state.schema, this.mapping)).filter(n => n !== null)\n      // @ts-ignore\n      const tr = this.prosemirrorView.state.tr.replace(0, this.prosemirrorView.state.doc.content.size, new PModel.Slice(new PModel.Fragment(fragmentContent), 0, 0))\n      tr.setMeta(ySyncPluginKey, { snapshot: null, prevSnapshot: null })\n      this.prosemirrorView.dispatch(tr)\n    })\n  }\n\n  _forceRerender () {\n    this.mapping = new Map()\n    this.mux(() => {\n      const fragmentContent = this.type.toArray().map(t => createNodeFromYElement(/** @type {Y.XmlElement} */ (t), this.prosemirrorView.state.schema, this.mapping)).filter(n => n !== null)\n      // @ts-ignore\n      const tr = this.prosemirrorView.state.tr.replace(0, this.prosemirrorView.state.doc.content.size, new PModel.Slice(new PModel.Fragment(fragmentContent), 0, 0))\n      this.prosemirrorView.dispatch(tr)\n    })\n  }\n\n  /**\n   * @param {Y.Snapshot} snapshot\n   * @param {Y.Snapshot} prevSnapshot\n   * @param {Object} pluginState\n   */\n  _renderSnapshot (snapshot, prevSnapshot, pluginState) {\n    if (!snapshot) {\n      snapshot = Y.snapshot(this.doc)\n    }\n    // clear mapping because we are going to rerender\n    this.mapping = new Map()\n    this.mux(() => {\n      this.doc.transact(transaction => {\n        // before rendering, we are going to sanitize ops and split deleted ops\n        // if they were deleted by seperate users.\n        const pud = pluginState.permanentUserData\n        if (pud) {\n          pud.dss.forEach(ds => {\n            Y.iterateDeletedStructs(transaction, ds, item => {})\n          })\n        }\n        const computeYChange = (type, id) => {\n          const user = type === 'added' ? pud.getUserByClientId(id.client) : pud.getUserByDeletedId(id)\n          return {\n            user,\n            type,\n            color: getUserColor(pluginState.colorMapping, pluginState.colors, user)\n          }\n        }\n        // Create document fragment and render\n        const fragmentContent = Y.typeListToArraySnapshot(this.type, new Y.Snapshot(prevSnapshot.ds, snapshot.sv)).map(t => {\n          if (!t._item.deleted || isVisible(t._item, snapshot) || isVisible(t._item, prevSnapshot)) {\n            return createNodeFromYElement(t, this.prosemirrorView.state.schema, new Map(), snapshot, prevSnapshot, computeYChange)\n          } else {\n            // No need to render elements that are not visible by either snapshot.\n            // If a client adds and deletes content in the same snapshot the element is not visible by either snapshot.\n            return null\n          }\n        }).filter(n => n !== null)\n        // @ts-ignore\n        const tr = this.prosemirrorView.state.tr.replace(0, this.prosemirrorView.state.doc.content.size, new PModel.Slice(new PModel.Fragment(fragmentContent), 0, 0))\n        this.prosemirrorView.dispatch(tr)\n      }, ySyncPluginKey)\n    })\n  }\n\n  /**\n   * @param {Array<Y.YEvent>} events\n   * @param {Y.Transaction} transaction\n   */\n  _typeChanged (events, transaction) {\n    const syncState = ySyncPluginKey.getState(this.prosemirrorView.state)\n    if (events.length === 0 || syncState.snapshot != null || syncState.prevSnapshot != null) {\n      // drop out if snapshot is active\n      this.renderSnapshot(syncState.snapshot, syncState.prevSnapshot)\n      return\n    }\n    this.mux(() => {\n      /**\n       * @param {any} _\n       * @param {Y.AbstractType} type\n       */\n      const delType = (_, type) => this.mapping.delete(type)\n      Y.iterateDeletedStructs(transaction, transaction.deleteSet, struct => struct.constructor === Y.Item && this.mapping.delete(/** @type {Y.ContentType} */ (/** @type {Y.Item} */ (struct).content).type))\n      transaction.changed.forEach(delType)\n      transaction.changedParentTypes.forEach(delType)\n      const fragmentContent = this.type.toArray().map(t => createNodeIfNotExists(/** @type {Y.XmlElement | Y.XmlHook} */ (t), this.prosemirrorView.state.schema, this.mapping)).filter(n => n !== null)\n      // @ts-ignore\n      let tr = this.prosemirrorView.state.tr.replace(0, this.prosemirrorView.state.doc.content.size, new PModel.Slice(new PModel.Fragment(fragmentContent), 0, 0))\n      restoreRelativeSelection(tr, this.beforeTransactionSelection, this)\n      tr = tr.setMeta(ySyncPluginKey, { isChangeOrigin: true })\n      if (this.beforeTransactionSelection !== null && this.prosemirrorView.hasFocus()) {\n        tr.scrollIntoView()\n      }\n      this.prosemirrorView.dispatch(tr)\n    })\n  }\n\n  _prosemirrorChanged (doc) {\n    this.mux(() => {\n      this.doc.transact(() => {\n        updateYFragment(this.doc, this.type, doc, this.mapping)\n        this.beforeTransactionSelection = getRelativeSelection(this, this.prosemirrorView.state)\n      }, ySyncPluginKey)\n    })\n  }\n\n  destroy () {\n    this.type.unobserveDeep(this._observeFunction)\n  }\n}\n\n/**\n * @private\n * @param {Y.XmlElement | Y.XmlHook} el\n * @param {PModel.Schema} schema\n * @param {ProsemirrorMapping} mapping\n * @param {Y.Snapshot} [snapshot]\n * @param {Y.Snapshot} [prevSnapshot]\n * @param {function('removed' | 'added', Y.ID):any} [computeYChange]\n * @return {PModel.Node | null}\n */\nexport const createNodeIfNotExists = (el, schema, mapping, snapshot, prevSnapshot, computeYChange) => {\n  const node = /** @type {PModel.Node} */ (mapping.get(el))\n  if (node === undefined) {\n    if (el instanceof Y.XmlElement) {\n      return createNodeFromYElement(el, schema, mapping, snapshot, prevSnapshot, computeYChange)\n    } else {\n      throw error.methodUnimplemented() // we are currently not handling hooks\n    }\n  }\n  return node\n}\n\n/**\n * @private\n * @param {Y.XmlElement} el\n * @param {any} schema\n * @param {ProsemirrorMapping} mapping\n * @param {Y.Snapshot} [snapshot]\n * @param {Y.Snapshot} [prevSnapshot]\n * @param {function('removed' | 'added', Y.ID):any} [computeYChange]\n * @return {PModel.Node | null} Returns node if node could be created. Otherwise it deletes the yjs type and returns null\n */\nexport const createNodeFromYElement = (el, schema, mapping, snapshot, prevSnapshot, computeYChange) => {\n  const children = []\n  const createChildren = type => {\n    if (type.constructor === Y.XmlElement) {\n      const n = createNodeIfNotExists(type, schema, mapping, snapshot, prevSnapshot, computeYChange)\n      if (n !== null) {\n        children.push(n)\n      }\n    } else {\n      const ns = createTextNodesFromYText(type, schema, mapping, snapshot, prevSnapshot, computeYChange)\n      if (ns !== null) {\n        ns.forEach(textchild => {\n          if (textchild !== null) {\n            children.push(textchild)\n          }\n        })\n      }\n    }\n  }\n  if (snapshot === undefined || prevSnapshot === undefined) {\n    el.toArray().forEach(createChildren)\n  } else {\n    Y.typeListToArraySnapshot(el, new Y.Snapshot(prevSnapshot.ds, snapshot.sv)).forEach(createChildren)\n  }\n  try {\n    const attrs = el.getAttributes(snapshot)\n    if (snapshot !== undefined) {\n      if (!isVisible(/** @type {Y.Item} */ (el._item), snapshot)) {\n        attrs.ychange = computeYChange ? computeYChange('removed', /** @type {Y.Item} */ (el._item).id) : { type: 'removed' }\n      } else if (!isVisible(/** @type {Y.Item} */ (el._item), prevSnapshot)) {\n        attrs.ychange = computeYChange ? computeYChange('added', /** @type {Y.Item} */ (el._item).id) : { type: 'added' }\n      }\n    }\n    const node = schema.node(el.nodeName, attrs, children)\n    mapping.set(el, node)\n    return node\n  } catch (e) {\n    // an error occured while creating the node. This is probably a result of a concurrent action.\n    /** @type {Y.Doc} */ (el.doc).transact(transaction => {\n      /** @type {Y.Item} */ (el._item).delete(transaction)\n    }, ySyncPluginKey)\n    mapping.delete(el)\n    return null\n  }\n}\n\n/**\n * @private\n * @param {Y.XmlText} text\n * @param {any} schema\n * @param {ProsemirrorMapping} mapping\n * @param {Y.Snapshot} [snapshot]\n * @param {Y.Snapshot} [prevSnapshot]\n * @param {function('removed' | 'added', Y.ID):any} [computeYChange]\n * @return {Array<PModel.Node>|null}\n */\nexport const createTextNodesFromYText = (text, schema, mapping, snapshot, prevSnapshot, computeYChange) => {\n  const nodes = []\n  const deltas = text.toDelta(snapshot, prevSnapshot, computeYChange)\n  try {\n    for (let i = 0; i < deltas.length; i++) {\n      const delta = deltas[i]\n      const marks = []\n      for (const markName in delta.attributes) {\n        marks.push(schema.mark(markName, delta.attributes[markName]))\n      }\n      nodes.push(schema.text(delta.insert, marks))\n    }\n  } catch (e) {\n    // an error occured while creating the node. This is probably a result of a concurrent action.\n    /** @type {Y.Doc} */ (text.doc).transact(transaction => {\n      /** @type {Y.Item} */ (text._item).delete(transaction)\n    }, ySyncPluginKey)\n    return null\n  }\n  // @ts-ignore\n  return nodes\n}\n\n/**\n * @private\n * @param {Array<any>} nodes prosemirror node\n * @param {ProsemirrorMapping} mapping\n * @return {Y.XmlText}\n */\nexport const createTypeFromTextNodes = (nodes, mapping) => {\n  const type = new Y.XmlText()\n  const delta = nodes.map(node => ({\n    // @ts-ignore\n    insert: node.text,\n    attributes: marksToAttributes(node.marks)\n  }))\n  type.applyDelta(delta)\n  mapping.set(type, nodes)\n  return type\n}\n\n/**\n * @private\n * @param {any} node prosemirror node\n * @param {ProsemirrorMapping} mapping\n * @return {Y.XmlElement}\n */\nexport const createTypeFromElementNode = (node, mapping) => {\n  const type = new Y.XmlElement(node.type.name)\n  for (const key in node.attrs) {\n    const val = node.attrs[key]\n    if (val !== null && key !== 'ychange') {\n      type.setAttribute(key, val)\n    }\n  }\n  type.insert(0, normalizePNodeContent(node).map(n => createTypeFromTextOrElementNode(n, mapping)))\n  mapping.set(type, node)\n  return type\n}\n\n/**\n * @private\n * @param {PModel.Node|Array<PModel.Node>} node prosemirror text node\n * @param {ProsemirrorMapping} mapping\n * @return {Y.XmlElement|Y.XmlText}\n */\nexport const createTypeFromTextOrElementNode = (node, mapping) => node instanceof Array ? createTypeFromTextNodes(node, mapping) : createTypeFromElementNode(node, mapping)\n\nconst equalAttrs = (pattrs, yattrs) => {\n  const keys = Object.keys(pattrs).filter(key => pattrs[key] !== null)\n  let eq = keys.length === Object.keys(yattrs).filter(key => yattrs[key] !== null).length\n  for (let i = 0; i < keys.length && eq; i++) {\n    const key = keys[i]\n    const l = pattrs[key]\n    const r = yattrs[key]\n    eq = key === 'ychange' || l === r || (typeof l === 'object' && typeof r === 'object' && equalAttrs(l, r))\n  }\n  return eq\n}\n\n/**\n * @typedef {Array<Array<PModel.Node>|PModel.Node>} NormalizedPNodeContent\n */\n\n/**\n * @param {any} pnode\n * @return {NormalizedPNodeContent}\n */\nexport const normalizePNodeContent = pnode => {\n  const c = pnode.content.content\n  const res = []\n  for (let i = 0; i < c.length; i++) {\n    const n = c[i]\n    if (n.isText) {\n      const textNodes = []\n      for (let tnode = c[i]; i < c.length && tnode.isText; tnode = c[++i]) {\n        textNodes.push(tnode)\n      }\n      i--\n      res.push(textNodes)\n    } else {\n      res.push(n)\n    }\n  }\n  return res\n}\n\n/**\n * @param {Y.XmlText} ytext\n * @param {Array<any>} ptexts\n */\nconst equalYTextPText = (ytext, ptexts) => {\n  const delta = ytext.toDelta()\n  return delta.length === ptexts.length && delta.every((d, i) => d.insert === /** @type {any} */ (ptexts[i]).text && object.keys(d.attributes || {}).length === ptexts[i].marks.length && ptexts[i].marks.every(mark => equalAttrs(d.attributes[mark.type.name] || {}, mark.attrs)))\n}\n\n/**\n * @param {Y.XmlElement|Y.XmlText|Y.XmlHook} ytype\n * @param {any|Array<any>} pnode\n */\nconst equalYTypePNode = (ytype, pnode) => {\n  if (ytype instanceof Y.XmlElement && !(pnode instanceof Array) && matchNodeName(ytype, pnode)) {\n    const normalizedContent = normalizePNodeContent(pnode)\n    return ytype._length === normalizedContent.length && equalAttrs(ytype.getAttributes(), pnode.attrs) && ytype.toArray().every((ychild, i) => equalYTypePNode(ychild, normalizedContent[i]))\n  }\n  return ytype instanceof Y.XmlText && pnode instanceof Array && equalYTextPText(ytype, pnode)\n}\n\n/**\n * @param {PModel.Node | Array<PModel.Node> | undefined} mapped\n * @param {PModel.Node | Array<PModel.Node>} pcontent\n */\nconst mappedIdentity = (mapped, pcontent) => mapped === pcontent || (mapped instanceof Array && pcontent instanceof Array && mapped.length === pcontent.length && mapped.every((a, i) => pcontent[i] === a))\n\n/**\n * @param {Y.XmlElement} ytype\n * @param {PModel.Node} pnode\n * @param {ProsemirrorMapping} mapping\n * @return {{ foundMappedChild: boolean, equalityFactor: number }}\n */\nconst computeChildEqualityFactor = (ytype, pnode, mapping) => {\n  const yChildren = ytype.toArray()\n  const pChildren = normalizePNodeContent(pnode)\n  const pChildCnt = pChildren.length\n  const yChildCnt = yChildren.length\n  const minCnt = math.min(yChildCnt, pChildCnt)\n  let left = 0\n  let right = 0\n  let foundMappedChild = false\n  for (; left < minCnt; left++) {\n    const leftY = yChildren[left]\n    const leftP = pChildren[left]\n    if (mappedIdentity(mapping.get(leftY), leftP)) {\n      foundMappedChild = true// definite (good) match!\n    } else if (!equalYTypePNode(leftY, leftP)) {\n      break\n    }\n  }\n  for (; left + right < minCnt; right++) {\n    const rightY = yChildren[yChildCnt - right - 1]\n    const rightP = pChildren[pChildCnt - right - 1]\n    if (mappedIdentity(mapping.get(rightY), rightP)) {\n      foundMappedChild = true\n    } else if (!equalYTypePNode(rightY, rightP)) {\n      break\n    }\n  }\n  return {\n    equalityFactor: left + right,\n    foundMappedChild\n  }\n}\n\nconst ytextTrans = ytext => {\n  let str = ''\n  /**\n   * @type {Y.Item|null}\n   */\n  let n = ytext._start\n  const nAttrs = {}\n  while (n !== null) {\n    if (!n.deleted) {\n      if (n.countable && n.content instanceof Y.ContentString) {\n        str += n.content.str\n      } else if (n.content instanceof Y.ContentFormat) {\n        nAttrs[n.content.key] = null\n      }\n    }\n    n = n.right\n  }\n  return {\n    str,\n    nAttrs\n  }\n}\n\n/**\n * @todo test this more\n *\n * @param {Y.Text} ytext\n * @param {Array<any>} ptexts\n * @param {ProsemirrorMapping} mapping\n */\nconst updateYText = (ytext, ptexts, mapping) => {\n  mapping.set(ytext, ptexts)\n  const { nAttrs, str } = ytextTrans(ytext)\n  const content = ptexts.map(p => ({ insert: /** @type {any} */ (p).text, attributes: Object.assign({}, nAttrs, marksToAttributes(p.marks)) }))\n  const { insert, remove, index } = simpleDiff(str, content.map(c => c.insert).join(''))\n  ytext.delete(index, remove)\n  ytext.insert(index, insert)\n  ytext.applyDelta(content.map(c => ({ retain: c.insert.length, attributes: c.attributes })))\n}\n\nconst marksToAttributes = marks => {\n  const pattrs = {}\n  marks.forEach(mark => {\n    if (mark.type.name !== 'ychange') {\n      pattrs[mark.type.name] = mark.attrs\n    }\n  })\n  return pattrs\n}\n\n/**\n * @private\n * @param {Y.Doc} y\n * @param {Y.XmlFragment} yDomFragment\n * @param {any} pNode\n * @param {ProsemirrorMapping} mapping\n */\nconst updateYFragment = (y, yDomFragment, pNode, mapping) => {\n  if (yDomFragment instanceof Y.XmlElement && yDomFragment.nodeName !== pNode.type.name) {\n    throw new Error('node name mismatch!')\n  }\n  mapping.set(yDomFragment, pNode)\n  // update attributes\n  if (yDomFragment instanceof Y.XmlElement) {\n    const yDomAttrs = yDomFragment.getAttributes()\n    const pAttrs = pNode.attrs\n    for (const key in pAttrs) {\n      if (pAttrs[key] !== null) {\n        if (yDomAttrs[key] !== pAttrs[key] && key !== 'ychange') {\n          yDomFragment.setAttribute(key, pAttrs[key])\n        }\n      } else {\n        yDomFragment.removeAttribute(key)\n      }\n    }\n    // remove all keys that are no longer in pAttrs\n    for (const key in yDomAttrs) {\n      if (pAttrs[key] === undefined) {\n        yDomFragment.removeAttribute(key)\n      }\n    }\n  }\n  // update children\n  const pChildren = normalizePNodeContent(pNode)\n  const pChildCnt = pChildren.length\n  const yChildren = yDomFragment.toArray()\n  const yChildCnt = yChildren.length\n  const minCnt = math.min(pChildCnt, yChildCnt)\n  let left = 0\n  let right = 0\n  // find number of matching elements from left\n  for (;left < minCnt; left++) {\n    const leftY = yChildren[left]\n    const leftP = pChildren[left]\n    if (!mappedIdentity(mapping.get(leftY), leftP)) {\n      if (equalYTypePNode(leftY, leftP)) {\n        // update mapping\n        mapping.set(leftY, leftP)\n      } else {\n        break\n      }\n    }\n  }\n  // find number of matching elements from right\n  for (;right + left + 1 < minCnt; right++) {\n    const rightY = yChildren[yChildCnt - right - 1]\n    const rightP = pChildren[pChildCnt - right - 1]\n    if (!mappedIdentity(mapping.get(rightY), rightP)) {\n      if (equalYTypePNode(rightY, rightP)) {\n        // update mapping\n        mapping.set(rightY, rightP)\n      } else {\n        break\n      }\n    }\n  }\n  y.transact(() => {\n    // try to compare and update\n    while (yChildCnt - left - right > 0 && pChildCnt - left - right > 0) {\n      const leftY = yChildren[left]\n      const leftP = pChildren[left]\n      const rightY = yChildren[yChildCnt - right - 1]\n      const rightP = pChildren[pChildCnt - right - 1]\n      if (leftY instanceof Y.XmlText && leftP instanceof Array) {\n        if (!equalYTextPText(leftY, leftP)) {\n          updateYText(leftY, leftP, mapping)\n        }\n        left += 1\n      } else {\n        let updateLeft = leftY instanceof Y.XmlElement && matchNodeName(leftY, leftP)\n        let updateRight = rightY instanceof Y.XmlElement && matchNodeName(rightY, rightP)\n        if (updateLeft && updateRight) {\n          // decide which which element to update\n          const equalityLeft = computeChildEqualityFactor(/** @type {Y.XmlElement} */ (leftY), /** @type {PModel.Node} */ (leftP), mapping)\n          const equalityRight = computeChildEqualityFactor(/** @type {Y.XmlElement} */ (rightY), /** @type {PModel.Node} */ (rightP), mapping)\n          if (equalityLeft.foundMappedChild && !equalityRight.foundMappedChild) {\n            updateRight = false\n          } else if (!equalityLeft.foundMappedChild && equalityRight.foundMappedChild) {\n            updateLeft = false\n          } else if (equalityLeft.equalityFactor < equalityRight.equalityFactor) {\n            updateLeft = false\n          } else {\n            updateRight = false\n          }\n        }\n        if (updateLeft) {\n          updateYFragment(y, /** @type {Y.XmlFragment} */ (leftY), /** @type {PModel.Node} */ (leftP), mapping)\n          left += 1\n        } else if (updateRight) {\n          updateYFragment(y, /** @type {Y.XmlFragment} */ (rightY), /** @type {PModel.Node} */ (rightP), mapping)\n          right += 1\n        } else {\n          yDomFragment.delete(left, 1)\n          yDomFragment.insert(left, [createTypeFromTextOrElementNode(leftP, mapping)])\n          left += 1\n        }\n      }\n    }\n    const yDelLen = yChildCnt - left - right\n    if (yDelLen > 0) {\n      yDomFragment.delete(left, yDelLen)\n    }\n    if (left + right < pChildCnt) {\n      const ins = []\n      for (let i = left; i < pChildCnt - right; i++) {\n        ins.push(createTypeFromTextOrElementNode(pChildren[i], mapping))\n      }\n      yDomFragment.insert(left, ins)\n    }\n  }, ySyncPluginKey)\n}\n\n/**\n * @function\n * @param {Y.XmlElement} yElement\n * @param {any} pNode Prosemirror Node\n */\nconst matchNodeName = (yElement, pNode) => !(pNode instanceof Array) && yElement.nodeName === pNode.type.name\n"]},"metadata":{},"sourceType":"module"}