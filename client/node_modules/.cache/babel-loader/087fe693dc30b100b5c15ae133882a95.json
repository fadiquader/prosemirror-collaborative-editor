{"ast":null,"code":"/*\nUnlike stated in the LICENSE file, it is not necessary to include the copyright notice and permission notice when you copy code from this file.\n*/\n\n/**\n * @module provider/websocket\n */\n\n/* eslint-env browser */\nimport * as Y from 'yjs'; // eslint-disable-line\n\nimport * as bc from 'lib0/broadcastchannel.js';\nimport * as time from 'lib0/time.js';\nimport * as encoding from 'lib0/encoding.js';\nimport * as decoding from 'lib0/decoding.js';\nimport * as syncProtocol from 'y-protocols/sync.js';\nimport * as authProtocol from 'y-protocols/auth.js';\nimport * as awarenessProtocol from 'y-protocols/awareness.js';\nimport * as mutex from 'lib0/mutex.js';\nimport { Observable } from 'lib0/observable.js';\nimport * as math from 'lib0/math.js';\nimport * as url from 'lib0/url.js';\nconst messageSync = 0;\nconst messageQueryAwareness = 3;\nconst messageAwareness = 1;\nconst messageAuth = 2;\nconst reconnectTimeoutBase = 1200;\nconst maxReconnectTimeout = 2500; // @todo - this should depend on awareness.outdatedTime\n\nconst messageReconnectTimeout = 30000;\n/**\n * @param {WebsocketProvider} provider\n * @param {string} reason\n */\n\nconst permissionDeniedHandler = (provider, reason) => console.warn(`Permission denied to access ${provider.url}.\\n${reason}`);\n/**\n * @param {WebsocketProvider} provider\n * @param {Uint8Array} buf\n * @param {boolean} emitSynced\n * @return {encoding.Encoder}\n */\n\n\nconst readMessage = (provider, buf, emitSynced) => {\n  const decoder = decoding.createDecoder(buf);\n  const encoder = encoding.createEncoder();\n  const messageType = decoding.readVarUint(decoder);\n\n  switch (messageType) {\n    case messageSync:\n      {\n        encoding.writeVarUint(encoder, messageSync);\n        const syncMessageType = syncProtocol.readSyncMessage(decoder, encoder, provider.doc, provider);\n\n        if (emitSynced && syncMessageType === syncProtocol.messageYjsSyncStep2 && !provider.synced) {\n          provider.synced = true;\n        }\n\n        break;\n      }\n\n    case messageQueryAwareness:\n      encoding.writeVarUint(encoder, messageAwareness);\n      encoding.writeVarUint8Array(encoder, awarenessProtocol.encodeAwarenessUpdate(provider.awareness, Array.from(provider.awareness.getStates().keys())));\n      break;\n\n    case messageAwareness:\n      awarenessProtocol.applyAwarenessUpdate(provider.awareness, decoding.readVarUint8Array(decoder), provider);\n      break;\n\n    case messageAuth:\n      authProtocol.readAuthMessage(decoder, provider.doc, permissionDeniedHandler);\n      break;\n\n    default:\n      console.error('Unable to compute message');\n      return encoder;\n  }\n\n  return encoder;\n};\n/**\n * @param {WebsocketProvider} provider\n */\n\n\nconst setupWS = provider => {\n  if (provider.shouldConnect && provider.ws === null) {\n    const websocket = new provider._WS(provider.url);\n    websocket.binaryType = 'arraybuffer';\n    provider.ws = websocket;\n    provider.wsconnecting = true;\n    provider.wsconnected = false;\n    provider.synced = false;\n\n    websocket.onmessage = event => {\n      provider.wsLastMessageReceived = time.getUnixTime();\n      const encoder = readMessage(provider, new Uint8Array(event.data), true);\n\n      if (encoding.length(encoder) > 1) {\n        websocket.send(encoding.toUint8Array(encoder));\n      }\n    };\n\n    websocket.onclose = () => {\n      provider.ws = null;\n      provider.wsconnecting = false;\n\n      if (provider.wsconnected) {\n        provider.wsconnected = false;\n        provider.synced = false; // update awareness (all users left)\n\n        awarenessProtocol.removeAwarenessStates(provider.awareness, Array.from(provider.awareness.getStates().keys()), provider);\n        provider.emit('status', [{\n          status: 'disconnected'\n        }]);\n      } else {\n        provider.wsUnsuccessfulReconnects++;\n      } // Start with no reconnect timeout and increase timeout by\n      // log10(wsUnsuccessfulReconnects).\n      // The idea is to increase reconnect timeout slowly and have no reconnect\n      // timeout at the beginning (log(1) = 0)\n\n\n      setTimeout(setupWS, math.min(math.log10(provider.wsUnsuccessfulReconnects + 1) * reconnectTimeoutBase, maxReconnectTimeout), provider);\n    };\n\n    websocket.onopen = () => {\n      provider.wsLastMessageReceived = time.getUnixTime();\n      provider.wsconnecting = false;\n      provider.wsconnected = true;\n      provider.wsUnsuccessfulReconnects = 0;\n      provider.emit('status', [{\n        status: 'connected'\n      }]); // always send sync step 1 when connected\n\n      const encoder = encoding.createEncoder();\n      encoding.writeVarUint(encoder, messageSync);\n      syncProtocol.writeSyncStep1(encoder, provider.doc);\n      websocket.send(encoding.toUint8Array(encoder)); // broadcast local awareness state\n\n      if (provider.awareness.getLocalState() !== null) {\n        const encoderAwarenessState = encoding.createEncoder();\n        encoding.writeVarUint(encoderAwarenessState, messageAwareness);\n        encoding.writeVarUint8Array(encoderAwarenessState, awarenessProtocol.encodeAwarenessUpdate(provider.awareness, [provider.doc.clientID]));\n        websocket.send(encoding.toUint8Array(encoderAwarenessState));\n      }\n    };\n  }\n};\n/**\n * @param {WebsocketProvider} provider\n * @param {ArrayBuffer} buf\n */\n\n\nconst broadcastMessage = (provider, buf) => {\n  if (provider.wsconnected) {\n    // @ts-ignore We know that wsconnected = true\n    provider.ws.send(buf);\n  }\n\n  if (provider.bcconnected) {\n    provider.mux(() => {\n      bc.publish(provider.url, buf);\n    });\n  }\n};\n/**\n * Websocket Provider for Yjs. Creates a websocket connection to sync the shared document.\n * The document name is attached to the provided url. I.e. the following example\n * creates a websocket connection to http://localhost:1234/my-document-name\n *\n * @example\n *   import * as Y from 'yjs'\n *   import { WebsocketProvider } from 'y-websocket'\n *   const doc = new Y.Doc()\n *   const provider = new WebsocketProvider('http://localhost:1234', 'my-document-name', doc)\n *\n * @extends {Observable<string>}\n */\n\n\nexport class WebsocketProvider extends Observable {\n  /**\n   * @param {string} serverUrl\n   * @param {string} roomname\n   * @param {Y.Doc} doc\n   * @param {object} [opts]\n   * @param {boolean} [opts.connect]\n   * @param {awarenessProtocol.Awareness} [opts.awareness]\n   * @param {Object<string,string>} [opts.params]\n   * @param {typeof WebSocket} [opts.WebSocketPolyfill] Optionall provide a WebSocket polyfill\n   * @param {number} [opts.resyncInterval] Request server state every `resyncInterval` milliseconds\n   */\n  constructor(serverUrl, roomname, doc, {\n    connect = true,\n    awareness = new awarenessProtocol.Awareness(doc),\n    params = {},\n    WebSocketPolyfill = WebSocket,\n    resyncInterval = -1\n  } = {}) {\n    super(); // ensure that url is always ends with /\n\n    while (serverUrl[serverUrl.length - 1] === '/') {\n      serverUrl = serverUrl.slice(0, serverUrl.length - 1);\n    }\n\n    const encodedParams = url.encodeQueryParams(params);\n    this.bcChannel = serverUrl + '/' + roomname;\n    this.url = serverUrl + '/' + roomname + (encodedParams.length === 0 ? '' : '?' + encodedParams);\n    this.roomname = roomname;\n    this.doc = doc;\n    this._WS = WebSocketPolyfill;\n    /**\n     * @type {Object<string,Object>}\n     */\n\n    this._localAwarenessState = {};\n    this.awareness = awareness;\n    this.wsconnected = false;\n    this.wsconnecting = false;\n    this.bcconnected = false;\n    this.wsUnsuccessfulReconnects = 0;\n    this.mux = mutex.createMutex();\n    /**\n     * @type {boolean}\n     */\n\n    this._synced = false;\n    /**\n     * @type {WebSocket?}\n     */\n\n    this.ws = null;\n    this.wsLastMessageReceived = 0;\n    /**\n     * Whether to connect to other peers or not\n     * @type {boolean}\n     */\n\n    this.shouldConnect = connect;\n    /**\n     * @type {NodeJS.Timeout | number}\n     */\n\n    this._resyncInterval = 0;\n\n    if (resyncInterval > 0) {\n      this._resyncInterval = setInterval(() => {\n        if (this.ws) {\n          if (!this.synced) {\n            alert(`\n  Please report that this message was shown to https://github.com/yjs/y-websocket/issues\n\n  Thank you! ❤\n\n  (Sorry for showing this message..`);\n            console.warn('Client was unsynced anyway');\n          } // resend sync step 1\n\n\n          const encoder = encoding.createEncoder();\n          encoding.writeVarUint(encoder, messageSync);\n          syncProtocol.writeSyncStep1(encoder, doc);\n          this.ws.send(encoding.toUint8Array(encoder));\n        }\n      }, resyncInterval);\n    }\n    /**\n     * @param {ArrayBuffer} data\n     */\n\n\n    this._bcSubscriber = data => {\n      this.mux(() => {\n        const encoder = readMessage(this, new Uint8Array(data), false);\n\n        if (encoding.length(encoder) > 1) {\n          bc.publish(this.bcChannel, encoding.toUint8Array(encoder));\n        }\n      });\n    };\n    /**\n     * Listens to Yjs updates and sends them to remote peers (ws and broadcastchannel)\n     * @param {Uint8Array} update\n     * @param {any} origin\n     */\n\n\n    this._updateHandler = (update, origin) => {\n      if (origin !== this || origin === null) {\n        const encoder = encoding.createEncoder();\n        encoding.writeVarUint(encoder, messageSync);\n        syncProtocol.writeUpdate(encoder, update);\n        broadcastMessage(this, encoding.toUint8Array(encoder));\n      }\n    };\n\n    this.doc.on('update', this._updateHandler);\n    /**\n     * @param {any} changed\n     * @param {any} origin\n     */\n\n    this._awarenessUpdateHandler = ({\n      added,\n      updated,\n      removed\n    }, origin) => {\n      const changedClients = added.concat(updated).concat(removed);\n      const encoder = encoding.createEncoder();\n      encoding.writeVarUint(encoder, messageAwareness);\n      encoding.writeVarUint8Array(encoder, awarenessProtocol.encodeAwarenessUpdate(awareness, changedClients));\n      broadcastMessage(this, encoding.toUint8Array(encoder));\n    };\n\n    window.addEventListener('beforeunload', () => {\n      awarenessProtocol.removeAwarenessStates(this.awareness, [doc.clientID], 'window unload');\n    });\n    awareness.on('update', this._awarenessUpdateHandler);\n    this._checkInterval = setInterval(() => {\n      if (this.wsconnected && messageReconnectTimeout < time.getUnixTime() - this.wsLastMessageReceived) {\n        // no message received in a long time - not even your own awareness\n        // updates (which are updated every 15 seconds)\n\n        /** @type {WebSocket} */\n        this.ws.close();\n      }\n    }, messageReconnectTimeout / 10);\n\n    if (connect) {\n      this.connect();\n    }\n  }\n  /**\n   * @type {boolean}\n   */\n\n\n  get synced() {\n    return this._synced;\n  }\n\n  set synced(state) {\n    if (this._synced !== state) {\n      this._synced = state;\n      this.emit('sync', [state]);\n    }\n  }\n\n  destroy() {\n    if (this._resyncInterval !== 0) {\n      clearInterval(\n      /** @type {NodeJS.Timeout} */\n      this._resyncInterval);\n    }\n\n    clearInterval(this._checkInterval);\n    this.disconnect();\n    this.awareness.off('update', this._awarenessUpdateHandler);\n    this.doc.off('update', this._updateHandler);\n    super.destroy();\n  }\n\n  connectBc() {\n    if (!this.bcconnected) {\n      bc.subscribe(this.bcChannel, this._bcSubscriber);\n      this.bcconnected = true;\n    } // send sync step1 to bc\n\n\n    this.mux(() => {\n      // write sync step 1\n      const encoderSync = encoding.createEncoder();\n      encoding.writeVarUint(encoderSync, messageSync);\n      syncProtocol.writeSyncStep1(encoderSync, this.doc);\n      bc.publish(this.bcChannel, encoding.toUint8Array(encoderSync)); // broadcast local state\n\n      const encoderState = encoding.createEncoder();\n      encoding.writeVarUint(encoderState, messageSync);\n      syncProtocol.writeSyncStep2(encoderState, this.doc);\n      bc.publish(this.bcChannel, encoding.toUint8Array(encoderState)); // write queryAwareness\n\n      const encoderAwarenessQuery = encoding.createEncoder();\n      encoding.writeVarUint(encoderAwarenessQuery, messageQueryAwareness);\n      bc.publish(this.bcChannel, encoding.toUint8Array(encoderAwarenessQuery)); // broadcast local awareness state\n\n      const encoderAwarenessState = encoding.createEncoder();\n      encoding.writeVarUint(encoderAwarenessState, messageAwareness);\n      encoding.writeVarUint8Array(encoderAwarenessState, awarenessProtocol.encodeAwarenessUpdate(this.awareness, [this.doc.clientID]));\n      bc.publish(this.bcChannel, encoding.toUint8Array(encoderAwarenessState));\n    });\n  }\n\n  disconnectBc() {\n    // broadcast message with local awareness state set to null (indicating disconnect)\n    const encoder = encoding.createEncoder();\n    encoding.writeVarUint(encoder, messageAwareness);\n    encoding.writeVarUint8Array(encoder, awarenessProtocol.encodeAwarenessUpdate(this.awareness, [this.doc.clientID], new Map()));\n    broadcastMessage(this, encoding.toUint8Array(encoder));\n\n    if (this.bcconnected) {\n      bc.unsubscribe(this.bcChannel, this._bcSubscriber);\n      this.bcconnected = false;\n    }\n  }\n\n  disconnect() {\n    this.shouldConnect = false;\n    this.disconnectBc();\n\n    if (this.ws !== null) {\n      this.ws.close();\n    }\n  }\n\n  connect() {\n    this.shouldConnect = true;\n\n    if (!this.wsconnected && this.ws === null) {\n      setupWS(this);\n      this.connectBc();\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/meeopp/Development/Others/editor-yjs/client/node_modules/y-websocket/src/y-websocket.js"],"names":["Y","bc","time","encoding","decoding","syncProtocol","authProtocol","awarenessProtocol","mutex","Observable","math","url","messageSync","messageQueryAwareness","messageAwareness","messageAuth","reconnectTimeoutBase","maxReconnectTimeout","messageReconnectTimeout","permissionDeniedHandler","provider","reason","console","warn","readMessage","buf","emitSynced","decoder","createDecoder","encoder","createEncoder","messageType","readVarUint","writeVarUint","syncMessageType","readSyncMessage","doc","messageYjsSyncStep2","synced","writeVarUint8Array","encodeAwarenessUpdate","awareness","Array","from","getStates","keys","applyAwarenessUpdate","readVarUint8Array","readAuthMessage","error","setupWS","shouldConnect","ws","websocket","_WS","binaryType","wsconnecting","wsconnected","onmessage","event","wsLastMessageReceived","getUnixTime","Uint8Array","data","length","send","toUint8Array","onclose","removeAwarenessStates","emit","status","wsUnsuccessfulReconnects","setTimeout","min","log10","onopen","writeSyncStep1","getLocalState","encoderAwarenessState","clientID","broadcastMessage","bcconnected","mux","publish","WebsocketProvider","constructor","serverUrl","roomname","connect","Awareness","params","WebSocketPolyfill","WebSocket","resyncInterval","slice","encodedParams","encodeQueryParams","bcChannel","_localAwarenessState","createMutex","_synced","_resyncInterval","setInterval","alert","_bcSubscriber","_updateHandler","update","origin","writeUpdate","on","_awarenessUpdateHandler","added","updated","removed","changedClients","concat","window","addEventListener","_checkInterval","close","state","destroy","clearInterval","disconnect","off","connectBc","subscribe","encoderSync","encoderState","writeSyncStep2","encoderAwarenessQuery","disconnectBc","Map","unsubscribe"],"mappings":"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","sourcesContent":["/*\nUnlike stated in the LICENSE file, it is not necessary to include the copyright notice and permission notice when you copy code from this file.\n*/\n\n/**\n * @module provider/websocket\n */\n\n/* eslint-env browser */\n\nimport * as Y from 'yjs' // eslint-disable-line\nimport * as bc from 'lib0/broadcastchannel.js'\nimport * as time from 'lib0/time.js'\nimport * as encoding from 'lib0/encoding.js'\nimport * as decoding from 'lib0/decoding.js'\nimport * as syncProtocol from 'y-protocols/sync.js'\nimport * as authProtocol from 'y-protocols/auth.js'\nimport * as awarenessProtocol from 'y-protocols/awareness.js'\nimport * as mutex from 'lib0/mutex.js'\nimport { Observable } from 'lib0/observable.js'\nimport * as math from 'lib0/math.js'\nimport * as url from 'lib0/url.js'\n\nconst messageSync = 0\nconst messageQueryAwareness = 3\nconst messageAwareness = 1\nconst messageAuth = 2\n\nconst reconnectTimeoutBase = 1200\nconst maxReconnectTimeout = 2500\n// @todo - this should depend on awareness.outdatedTime\nconst messageReconnectTimeout = 30000\n\n/**\n * @param {WebsocketProvider} provider\n * @param {string} reason\n */\nconst permissionDeniedHandler = (provider, reason) => console.warn(`Permission denied to access ${provider.url}.\\n${reason}`)\n\n/**\n * @param {WebsocketProvider} provider\n * @param {Uint8Array} buf\n * @param {boolean} emitSynced\n * @return {encoding.Encoder}\n */\nconst readMessage = (provider, buf, emitSynced) => {\n  const decoder = decoding.createDecoder(buf)\n  const encoder = encoding.createEncoder()\n  const messageType = decoding.readVarUint(decoder)\n  switch (messageType) {\n    case messageSync: {\n      encoding.writeVarUint(encoder, messageSync)\n      const syncMessageType = syncProtocol.readSyncMessage(decoder, encoder, provider.doc, provider)\n      if (emitSynced && syncMessageType === syncProtocol.messageYjsSyncStep2 && !provider.synced) {\n        provider.synced = true\n      }\n      break\n    }\n    case messageQueryAwareness:\n      encoding.writeVarUint(encoder, messageAwareness)\n      encoding.writeVarUint8Array(encoder, awarenessProtocol.encodeAwarenessUpdate(provider.awareness, Array.from(provider.awareness.getStates().keys())))\n      break\n    case messageAwareness:\n      awarenessProtocol.applyAwarenessUpdate(provider.awareness, decoding.readVarUint8Array(decoder), provider)\n      break\n    case messageAuth:\n      authProtocol.readAuthMessage(decoder, provider.doc, permissionDeniedHandler)\n      break\n    default:\n      console.error('Unable to compute message')\n      return encoder\n  }\n  return encoder\n}\n\n/**\n * @param {WebsocketProvider} provider\n */\nconst setupWS = provider => {\n  if (provider.shouldConnect && provider.ws === null) {\n    const websocket = new provider._WS(provider.url)\n    websocket.binaryType = 'arraybuffer'\n    provider.ws = websocket\n    provider.wsconnecting = true\n    provider.wsconnected = false\n    provider.synced = false\n    websocket.onmessage = event => {\n      provider.wsLastMessageReceived = time.getUnixTime()\n      const encoder = readMessage(provider, new Uint8Array(event.data), true)\n      if (encoding.length(encoder) > 1) {\n        websocket.send(encoding.toUint8Array(encoder))\n      }\n    }\n    websocket.onclose = () => {\n      provider.ws = null\n      provider.wsconnecting = false\n      if (provider.wsconnected) {\n        provider.wsconnected = false\n        provider.synced = false\n        // update awareness (all users left)\n        awarenessProtocol.removeAwarenessStates(provider.awareness, Array.from(provider.awareness.getStates().keys()), provider)\n        provider.emit('status', [{\n          status: 'disconnected'\n        }])\n      } else {\n        provider.wsUnsuccessfulReconnects++\n      }\n      // Start with no reconnect timeout and increase timeout by\n      // log10(wsUnsuccessfulReconnects).\n      // The idea is to increase reconnect timeout slowly and have no reconnect\n      // timeout at the beginning (log(1) = 0)\n      setTimeout(setupWS, math.min(math.log10(provider.wsUnsuccessfulReconnects + 1) * reconnectTimeoutBase, maxReconnectTimeout), provider)\n    }\n    websocket.onopen = () => {\n      provider.wsLastMessageReceived = time.getUnixTime()\n      provider.wsconnecting = false\n      provider.wsconnected = true\n      provider.wsUnsuccessfulReconnects = 0\n      provider.emit('status', [{\n        status: 'connected'\n      }])\n      // always send sync step 1 when connected\n      const encoder = encoding.createEncoder()\n      encoding.writeVarUint(encoder, messageSync)\n      syncProtocol.writeSyncStep1(encoder, provider.doc)\n      websocket.send(encoding.toUint8Array(encoder))\n      // broadcast local awareness state\n      if (provider.awareness.getLocalState() !== null) {\n        const encoderAwarenessState = encoding.createEncoder()\n        encoding.writeVarUint(encoderAwarenessState, messageAwareness)\n        encoding.writeVarUint8Array(encoderAwarenessState, awarenessProtocol.encodeAwarenessUpdate(provider.awareness, [provider.doc.clientID]))\n        websocket.send(encoding.toUint8Array(encoderAwarenessState))\n      }\n    }\n  }\n}\n\n/**\n * @param {WebsocketProvider} provider\n * @param {ArrayBuffer} buf\n */\nconst broadcastMessage = (provider, buf) => {\n  if (provider.wsconnected) {\n    // @ts-ignore We know that wsconnected = true\n    provider.ws.send(buf)\n  }\n  if (provider.bcconnected) {\n    provider.mux(() => {\n      bc.publish(provider.url, buf)\n    })\n  }\n}\n\n/**\n * Websocket Provider for Yjs. Creates a websocket connection to sync the shared document.\n * The document name is attached to the provided url. I.e. the following example\n * creates a websocket connection to http://localhost:1234/my-document-name\n *\n * @example\n *   import * as Y from 'yjs'\n *   import { WebsocketProvider } from 'y-websocket'\n *   const doc = new Y.Doc()\n *   const provider = new WebsocketProvider('http://localhost:1234', 'my-document-name', doc)\n *\n * @extends {Observable<string>}\n */\nexport class WebsocketProvider extends Observable {\n  /**\n   * @param {string} serverUrl\n   * @param {string} roomname\n   * @param {Y.Doc} doc\n   * @param {object} [opts]\n   * @param {boolean} [opts.connect]\n   * @param {awarenessProtocol.Awareness} [opts.awareness]\n   * @param {Object<string,string>} [opts.params]\n   * @param {typeof WebSocket} [opts.WebSocketPolyfill] Optionall provide a WebSocket polyfill\n   * @param {number} [opts.resyncInterval] Request server state every `resyncInterval` milliseconds\n   */\n  constructor (serverUrl, roomname, doc, { connect = true, awareness = new awarenessProtocol.Awareness(doc), params = {}, WebSocketPolyfill = WebSocket, resyncInterval = -1 } = {}) {\n    super()\n    // ensure that url is always ends with /\n    while (serverUrl[serverUrl.length - 1] === '/') {\n      serverUrl = serverUrl.slice(0, serverUrl.length - 1)\n    }\n    const encodedParams = url.encodeQueryParams(params)\n    this.bcChannel = serverUrl + '/' + roomname\n    this.url = serverUrl + '/' + roomname + (encodedParams.length === 0 ? '' : '?' + encodedParams)\n    this.roomname = roomname\n    this.doc = doc\n    this._WS = WebSocketPolyfill\n    /**\n     * @type {Object<string,Object>}\n     */\n    this._localAwarenessState = {}\n    this.awareness = awareness\n    this.wsconnected = false\n    this.wsconnecting = false\n    this.bcconnected = false\n    this.wsUnsuccessfulReconnects = 0\n    this.mux = mutex.createMutex()\n    /**\n     * @type {boolean}\n     */\n    this._synced = false\n    /**\n     * @type {WebSocket?}\n     */\n    this.ws = null\n    this.wsLastMessageReceived = 0\n    /**\n     * Whether to connect to other peers or not\n     * @type {boolean}\n     */\n    this.shouldConnect = connect\n\n    /**\n     * @type {NodeJS.Timeout | number}\n     */\n    this._resyncInterval = 0\n    if (resyncInterval > 0) {\n      this._resyncInterval = setInterval(() => {\n        if (this.ws) {\n          if (!this.synced) {\n            alert(`\n  Please report that this message was shown to https://github.com/yjs/y-websocket/issues\n\n  Thank you! ❤\n\n  (Sorry for showing this message..`)\n            console.warn('Client was unsynced anyway')\n          }\n          // resend sync step 1\n          const encoder = encoding.createEncoder()\n          encoding.writeVarUint(encoder, messageSync)\n          syncProtocol.writeSyncStep1(encoder, doc)\n          this.ws.send(encoding.toUint8Array(encoder))\n        }\n      }, resyncInterval)\n    }\n\n    /**\n     * @param {ArrayBuffer} data\n     */\n    this._bcSubscriber = data => {\n      this.mux(() => {\n        const encoder = readMessage(this, new Uint8Array(data), false)\n        if (encoding.length(encoder) > 1) {\n          bc.publish(this.bcChannel, encoding.toUint8Array(encoder))\n        }\n      })\n    }\n    /**\n     * Listens to Yjs updates and sends them to remote peers (ws and broadcastchannel)\n     * @param {Uint8Array} update\n     * @param {any} origin\n     */\n    this._updateHandler = (update, origin) => {\n      if (origin !== this || origin === null) {\n        const encoder = encoding.createEncoder()\n        encoding.writeVarUint(encoder, messageSync)\n        syncProtocol.writeUpdate(encoder, update)\n        broadcastMessage(this, encoding.toUint8Array(encoder))\n      }\n    }\n    this.doc.on('update', this._updateHandler)\n    /**\n     * @param {any} changed\n     * @param {any} origin\n     */\n    this._awarenessUpdateHandler = ({ added, updated, removed }, origin) => {\n      const changedClients = added.concat(updated).concat(removed)\n      const encoder = encoding.createEncoder()\n      encoding.writeVarUint(encoder, messageAwareness)\n      encoding.writeVarUint8Array(encoder, awarenessProtocol.encodeAwarenessUpdate(awareness, changedClients))\n      broadcastMessage(this, encoding.toUint8Array(encoder))\n    }\n    window.addEventListener('beforeunload', () => {\n      awarenessProtocol.removeAwarenessStates(this.awareness, [doc.clientID], 'window unload')\n    })\n    awareness.on('update', this._awarenessUpdateHandler)\n    this._checkInterval = setInterval(() => {\n      if (this.wsconnected && messageReconnectTimeout < time.getUnixTime() - this.wsLastMessageReceived) {\n        // no message received in a long time - not even your own awareness\n        // updates (which are updated every 15 seconds)\n        /** @type {WebSocket} */ (this.ws).close()\n      }\n    }, messageReconnectTimeout / 10)\n    if (connect) {\n      this.connect()\n    }\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get synced () {\n    return this._synced\n  }\n\n  set synced (state) {\n    if (this._synced !== state) {\n      this._synced = state\n      this.emit('sync', [state])\n    }\n  }\n\n  destroy () {\n    if (this._resyncInterval !== 0) {\n      clearInterval(/** @type {NodeJS.Timeout} */ (this._resyncInterval))\n    }\n    clearInterval(this._checkInterval)\n    this.disconnect()\n    this.awareness.off('update', this._awarenessUpdateHandler)\n    this.doc.off('update', this._updateHandler)\n    super.destroy()\n  }\n\n  connectBc () {\n    if (!this.bcconnected) {\n      bc.subscribe(this.bcChannel, this._bcSubscriber)\n      this.bcconnected = true\n    }\n    // send sync step1 to bc\n    this.mux(() => {\n      // write sync step 1\n      const encoderSync = encoding.createEncoder()\n      encoding.writeVarUint(encoderSync, messageSync)\n      syncProtocol.writeSyncStep1(encoderSync, this.doc)\n      bc.publish(this.bcChannel, encoding.toUint8Array(encoderSync))\n      // broadcast local state\n      const encoderState = encoding.createEncoder()\n      encoding.writeVarUint(encoderState, messageSync)\n      syncProtocol.writeSyncStep2(encoderState, this.doc)\n      bc.publish(this.bcChannel, encoding.toUint8Array(encoderState))\n      // write queryAwareness\n      const encoderAwarenessQuery = encoding.createEncoder()\n      encoding.writeVarUint(encoderAwarenessQuery, messageQueryAwareness)\n      bc.publish(this.bcChannel, encoding.toUint8Array(encoderAwarenessQuery))\n      // broadcast local awareness state\n      const encoderAwarenessState = encoding.createEncoder()\n      encoding.writeVarUint(encoderAwarenessState, messageAwareness)\n      encoding.writeVarUint8Array(encoderAwarenessState, awarenessProtocol.encodeAwarenessUpdate(this.awareness, [this.doc.clientID]))\n      bc.publish(this.bcChannel, encoding.toUint8Array(encoderAwarenessState))\n    })\n  }\n\n  disconnectBc () {\n    // broadcast message with local awareness state set to null (indicating disconnect)\n    const encoder = encoding.createEncoder()\n    encoding.writeVarUint(encoder, messageAwareness)\n    encoding.writeVarUint8Array(encoder, awarenessProtocol.encodeAwarenessUpdate(this.awareness, [this.doc.clientID], new Map()))\n    broadcastMessage(this, encoding.toUint8Array(encoder))\n    if (this.bcconnected) {\n      bc.unsubscribe(this.bcChannel, this._bcSubscriber)\n      this.bcconnected = false\n    }\n  }\n\n  disconnect () {\n    this.shouldConnect = false\n    this.disconnectBc()\n    if (this.ws !== null) {\n      this.ws.close()\n    }\n  }\n\n  connect () {\n    this.shouldConnect = true\n    if (!this.wsconnected && this.ws === null) {\n      setupWS(this)\n      this.connectBc()\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}