{"ast":null,"code":"import { liftTarget, canJoin, joinPoint, canSplit, ReplaceAroundStep, findWrapping } from 'prosemirror-transform';\nimport { Fragment, Slice } from 'prosemirror-model';\nimport { NodeSelection, Selection, TextSelection, AllSelection } from 'prosemirror-state'; // :: (EditorState, ?(tr: Transaction)) → bool\n// Delete the selection, if there is one.\n\nfunction deleteSelection(state, dispatch) {\n  if (state.selection.empty) {\n    return false;\n  }\n\n  if (dispatch) {\n    dispatch(state.tr.deleteSelection().scrollIntoView());\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// If the selection is empty and at the start of a textblock, try to\n// reduce the distance between that block and the one before it—if\n// there's a block directly before it that can be joined, join them.\n// If not, try to move the selected block closer to the next one in\n// the document structure by lifting it out of its parent or moving it\n// into a parent of the previous block. Will use the view for accurate\n// (bidi-aware) start-of-textblock detection if given.\n\n\nfunction joinBackward(state, dispatch, view) {\n  var ref = state.selection;\n  var $cursor = ref.$cursor;\n\n  if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state) : $cursor.parentOffset > 0)) {\n    return false;\n  }\n\n  var $cut = findCutBefore($cursor); // If there is no node before this, try to lift\n\n  if (!$cut) {\n    var range = $cursor.blockRange(),\n        target = range && liftTarget(range);\n\n    if (target == null) {\n      return false;\n    }\n\n    if (dispatch) {\n      dispatch(state.tr.lift(range, target).scrollIntoView());\n    }\n\n    return true;\n  }\n\n  var before = $cut.nodeBefore; // Apply the joining algorithm\n\n  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch)) {\n    return true;\n  } // If the node below has no content and the node above is\n  // selectable, delete the node below and select the one above.\n\n\n  if ($cursor.parent.content.size == 0 && (textblockAt(before, \"end\") || NodeSelection.isSelectable(before))) {\n    if (dispatch) {\n      var tr = state.tr.deleteRange($cursor.before(), $cursor.after());\n      tr.setSelection(textblockAt(before, \"end\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));\n      dispatch(tr.scrollIntoView());\n    }\n\n    return true;\n  } // If the node before is an atom, delete it\n\n\n  if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) {\n      dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction textblockAt(node, side) {\n  for (; node; node = side == \"start\" ? node.firstChild : node.lastChild) {\n    if (node.isTextblock) {\n      return true;\n    }\n  }\n\n  return false;\n} // :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// When the selection is empty and at the start of a textblock, select\n// the node before that textblock, if possible. This is intended to be\n// bound to keys like backspace, after\n// [`joinBackward`](#commands.joinBackward) or other deleting\n// commands, as a fall-back behavior when the schema doesn't allow\n// deletion at the selected point.\n\n\nfunction selectNodeBackward(state, dispatch, view) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var empty = ref.empty;\n  var $cut = $head;\n\n  if (!empty) {\n    return false;\n  }\n\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0) {\n      return false;\n    }\n\n    $cut = findCutBefore($head);\n  }\n\n  var node = $cut && $cut.nodeBefore;\n\n  if (!node || !NodeSelection.isSelectable(node)) {\n    return false;\n  }\n\n  if (dispatch) {\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());\n  }\n\n  return true;\n}\n\nfunction findCutBefore($pos) {\n  if (!$pos.parent.type.spec.isolating) {\n    for (var i = $pos.depth - 1; i >= 0; i--) {\n      if ($pos.index(i) > 0) {\n        return $pos.doc.resolve($pos.before(i + 1));\n      }\n\n      if ($pos.node(i).type.spec.isolating) {\n        break;\n      }\n    }\n  }\n\n  return null;\n} // :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// If the selection is empty and the cursor is at the end of a\n// textblock, try to reduce or remove the boundary between that block\n// and the one after it, either by joining them or by moving the other\n// block closer to this one in the tree structure. Will use the view\n// for accurate start-of-textblock detection if given.\n\n\nfunction joinForward(state, dispatch, view) {\n  var ref = state.selection;\n  var $cursor = ref.$cursor;\n\n  if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state) : $cursor.parentOffset < $cursor.parent.content.size)) {\n    return false;\n  }\n\n  var $cut = findCutAfter($cursor); // If there is no node after this, there's nothing to do\n\n  if (!$cut) {\n    return false;\n  }\n\n  var after = $cut.nodeAfter; // Try the joining algorithm\n\n  if (deleteBarrier(state, $cut, dispatch)) {\n    return true;\n  } // If the node above has no content and the node below is\n  // selectable, delete the node above and select the one below.\n\n\n  if ($cursor.parent.content.size == 0 && (textblockAt(after, \"start\") || NodeSelection.isSelectable(after))) {\n    if (dispatch) {\n      var tr = state.tr.deleteRange($cursor.before(), $cursor.after());\n      tr.setSelection(textblockAt(after, \"start\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));\n      dispatch(tr.scrollIntoView());\n    }\n\n    return true;\n  } // If the next node is an atom, delete it\n\n\n  if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) {\n      dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());\n    }\n\n    return true;\n  }\n\n  return false;\n} // :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// When the selection is empty and at the end of a textblock, select\n// the node coming after that textblock, if possible. This is intended\n// to be bound to keys like delete, after\n// [`joinForward`](#commands.joinForward) and similar deleting\n// commands, to provide a fall-back behavior when the schema doesn't\n// allow deletion at the selected point.\n\n\nfunction selectNodeForward(state, dispatch, view) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var empty = ref.empty;\n  var $cut = $head;\n\n  if (!empty) {\n    return false;\n  }\n\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size) {\n      return false;\n    }\n\n    $cut = findCutAfter($head);\n  }\n\n  var node = $cut && $cut.nodeAfter;\n\n  if (!node || !NodeSelection.isSelectable(node)) {\n    return false;\n  }\n\n  if (dispatch) {\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());\n  }\n\n  return true;\n}\n\nfunction findCutAfter($pos) {\n  if (!$pos.parent.type.spec.isolating) {\n    for (var i = $pos.depth - 1; i >= 0; i--) {\n      var parent = $pos.node(i);\n\n      if ($pos.index(i) + 1 < parent.childCount) {\n        return $pos.doc.resolve($pos.after(i + 1));\n      }\n\n      if (parent.type.spec.isolating) {\n        break;\n      }\n    }\n  }\n\n  return null;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// Join the selected block or, if there is a text selection, the\n// closest ancestor block of the selection that can be joined, with\n// the sibling above it.\n\n\nfunction joinUp(state, dispatch) {\n  var sel = state.selection,\n      nodeSel = sel instanceof NodeSelection,\n      point;\n\n  if (nodeSel) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.from)) {\n      return false;\n    }\n\n    point = sel.from;\n  } else {\n    point = joinPoint(state.doc, sel.from, -1);\n\n    if (point == null) {\n      return false;\n    }\n  }\n\n  if (dispatch) {\n    var tr = state.tr.join(point);\n\n    if (nodeSel) {\n      tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));\n    }\n\n    dispatch(tr.scrollIntoView());\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// Join the selected block, or the closest ancestor of the selection\n// that can be joined, with the sibling after it.\n\n\nfunction joinDown(state, dispatch) {\n  var sel = state.selection,\n      point;\n\n  if (sel instanceof NodeSelection) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.to)) {\n      return false;\n    }\n\n    point = sel.to;\n  } else {\n    point = joinPoint(state.doc, sel.to, 1);\n\n    if (point == null) {\n      return false;\n    }\n  }\n\n  if (dispatch) {\n    dispatch(state.tr.join(point).scrollIntoView());\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// Lift the selected block, or the closest ancestor block of the\n// selection that can be lifted, out of its parent node.\n\n\nfunction lift(state, dispatch) {\n  var ref = state.selection;\n  var $from = ref.$from;\n  var $to = ref.$to;\n  var range = $from.blockRange($to),\n      target = range && liftTarget(range);\n\n  if (target == null) {\n    return false;\n  }\n\n  if (dispatch) {\n    dispatch(state.tr.lift(range, target).scrollIntoView());\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// If the selection is in a node whose type has a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, replace the\n// selection with a newline character.\n\n\nfunction newlineInCode(state, dispatch) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var $anchor = ref.$anchor;\n\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) {\n    return false;\n  }\n\n  if (dispatch) {\n    dispatch(state.tr.insertText(\"\\n\").scrollIntoView());\n  }\n\n  return true;\n}\n\nfunction defaultBlockAt(match) {\n  for (var i = 0; i < match.edgeCount; i++) {\n    var ref = match.edge(i);\n    var type = ref.type;\n\n    if (type.isTextblock && !type.hasRequiredAttrs()) {\n      return type;\n    }\n  }\n\n  return null;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// When the selection is in a node with a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, create a\n// default block after the code block, and move the cursor there.\n\n\nfunction exitCode(state, dispatch) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var $anchor = ref.$anchor;\n\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) {\n    return false;\n  }\n\n  var above = $head.node(-1),\n      after = $head.indexAfter(-1),\n      type = defaultBlockAt(above.contentMatchAt(after));\n\n  if (!above.canReplaceWith(after, after, type)) {\n    return false;\n  }\n\n  if (dispatch) {\n    var pos = $head.after(),\n        tr = state.tr.replaceWith(pos, pos, type.createAndFill());\n    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));\n    dispatch(tr.scrollIntoView());\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// If a block node is selected, create an empty paragraph before (if\n// it is its parent's first child) or after it.\n\n\nfunction createParagraphNear(state, dispatch) {\n  var ref = state.selection;\n  var $from = ref.$from;\n  var $to = ref.$to;\n\n  if ($from.parent.inlineContent || $to.parent.inlineContent) {\n    return false;\n  }\n\n  var type = defaultBlockAt($from.parent.contentMatchAt($to.indexAfter()));\n\n  if (!type || !type.isTextblock) {\n    return false;\n  }\n\n  if (dispatch) {\n    var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;\n    var tr = state.tr.insert(side, type.createAndFill());\n    tr.setSelection(TextSelection.create(tr.doc, side + 1));\n    dispatch(tr.scrollIntoView());\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// If the cursor is in an empty textblock that can be lifted, lift the\n// block.\n\n\nfunction liftEmptyBlock(state, dispatch) {\n  var ref = state.selection;\n  var $cursor = ref.$cursor;\n\n  if (!$cursor || $cursor.parent.content.size) {\n    return false;\n  }\n\n  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n    var before = $cursor.before();\n\n    if (canSplit(state.doc, before)) {\n      if (dispatch) {\n        dispatch(state.tr.split(before).scrollIntoView());\n      }\n\n      return true;\n    }\n  }\n\n  var range = $cursor.blockRange(),\n      target = range && liftTarget(range);\n\n  if (target == null) {\n    return false;\n  }\n\n  if (dispatch) {\n    dispatch(state.tr.lift(range, target).scrollIntoView());\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// Split the parent block of the selection. If the selection is a text\n// selection, also delete its content.\n\n\nfunction splitBlock(state, dispatch) {\n  var ref = state.selection;\n  var $from = ref.$from;\n  var $to = ref.$to;\n\n  if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {\n    if (!$from.parentOffset || !canSplit(state.doc, $from.pos)) {\n      return false;\n    }\n\n    if (dispatch) {\n      dispatch(state.tr.split($from.pos).scrollIntoView());\n    }\n\n    return true;\n  }\n\n  if (!$from.parent.isBlock) {\n    return false;\n  }\n\n  if (dispatch) {\n    var atEnd = $to.parentOffset == $to.parent.content.size;\n    var tr = state.tr;\n\n    if (state.selection instanceof TextSelection) {\n      tr.deleteSelection();\n    }\n\n    var deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n    var types = atEnd && deflt ? [{\n      type: deflt\n    }] : null;\n    var can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);\n\n    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{\n      type: deflt\n    }])) {\n      types = [{\n        type: deflt\n      }];\n      can = true;\n    }\n\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types);\n\n      if (!atEnd && !$from.parentOffset && $from.parent.type != deflt && $from.node(-1).canReplace($from.index(-1), $from.indexAfter(-1), Fragment.from(deflt.create(), $from.parent))) {\n        tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n      }\n    }\n\n    dispatch(tr.scrollIntoView());\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// Acts like [`splitBlock`](#commands.splitBlock), but without\n// resetting the set of active marks at the cursor.\n\n\nfunction splitBlockKeepMarks(state, dispatch) {\n  return splitBlock(state, dispatch && function (tr) {\n    var marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n\n    if (marks) {\n      tr.ensureMarks(marks);\n    }\n\n    dispatch(tr);\n  });\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// Move the selection to the node wrapping the current selection, if\n// any. (Will not select the document node.)\n\n\nfunction selectParentNode(state, dispatch) {\n  var ref = state.selection;\n  var $from = ref.$from;\n  var to = ref.to;\n  var pos;\n  var same = $from.sharedDepth(to);\n\n  if (same == 0) {\n    return false;\n  }\n\n  pos = $from.before(same);\n\n  if (dispatch) {\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// Select the whole document.\n\n\nfunction selectAll(state, dispatch) {\n  if (dispatch) {\n    dispatch(state.tr.setSelection(new AllSelection(state.doc)));\n  }\n\n  return true;\n}\n\nfunction joinMaybeClear(state, $pos, dispatch) {\n  var before = $pos.nodeBefore,\n      after = $pos.nodeAfter,\n      index = $pos.index();\n\n  if (!before || !after || !before.type.compatibleContent(after.type)) {\n    return false;\n  }\n\n  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n    if (dispatch) {\n      dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());\n    }\n\n    return true;\n  }\n\n  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos))) {\n    return false;\n  }\n\n  if (dispatch) {\n    dispatch(state.tr.clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView());\n  }\n\n  return true;\n}\n\nfunction deleteBarrier(state, $cut, dispatch) {\n  var before = $cut.nodeBefore,\n      after = $cut.nodeAfter,\n      conn,\n      match;\n\n  if (before.type.spec.isolating || after.type.spec.isolating) {\n    return false;\n  }\n\n  if (joinMaybeClear(state, $cut, dispatch)) {\n    return true;\n  }\n\n  if ($cut.parent.canReplace($cut.index(), $cut.index() + 1) && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {\n    if (dispatch) {\n      var end = $cut.pos + after.nodeSize,\n          wrap = Fragment.empty;\n\n      for (var i = conn.length - 1; i >= 0; i--) {\n        wrap = Fragment.from(conn[i].create(null, wrap));\n      }\n\n      wrap = Fragment.from(before.copy(wrap));\n      var tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap, 1, 0), conn.length, true));\n      var joinAt = end + 2 * conn.length;\n\n      if (canJoin(tr.doc, joinAt)) {\n        tr.join(joinAt);\n      }\n\n      dispatch(tr.scrollIntoView());\n    }\n\n    return true;\n  }\n\n  var selAfter = Selection.findFrom($cut, 1);\n  var range = selAfter && selAfter.$from.blockRange(selAfter.$to),\n      target = range && liftTarget(range);\n\n  if (target != null && target >= $cut.depth) {\n    if (dispatch) {\n      dispatch(state.tr.lift(range, target).scrollIntoView());\n    }\n\n    return true;\n  }\n\n  return false;\n} // Parameterized commands\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Wrap the selection in a node of the given type with the given\n// attributes.\n\n\nfunction wrapIn(nodeType, attrs) {\n  return function (state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var range = $from.blockRange($to),\n        wrapping = range && findWrapping(range, nodeType, attrs);\n\n    if (!wrapping) {\n      return false;\n    }\n\n    if (dispatch) {\n      dispatch(state.tr.wrap(range, wrapping).scrollIntoView());\n    }\n\n    return true;\n  };\n} // :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command that tries to set the selected textblocks to the\n// given node type with the given attributes.\n\n\nfunction setBlockType(nodeType, attrs) {\n  return function (state, dispatch) {\n    var ref = state.selection;\n    var from = ref.from;\n    var to = ref.to;\n    var applicable = false;\n    state.doc.nodesBetween(from, to, function (node, pos) {\n      if (applicable) {\n        return false;\n      }\n\n      if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) {\n        return;\n      }\n\n      if (node.type == nodeType) {\n        applicable = true;\n      } else {\n        var $pos = state.doc.resolve(pos),\n            index = $pos.index();\n        applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);\n      }\n    });\n\n    if (!applicable) {\n      return false;\n    }\n\n    if (dispatch) {\n      dispatch(state.tr.setBlockType(from, to, nodeType, attrs).scrollIntoView());\n    }\n\n    return true;\n  };\n}\n\nfunction markApplies(doc, ranges, type) {\n  var loop = function (i) {\n    var ref = ranges[i];\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var can = $from.depth == 0 ? doc.type.allowsMarkType(type) : false;\n    doc.nodesBetween($from.pos, $to.pos, function (node) {\n      if (can) {\n        return false;\n      }\n\n      can = node.inlineContent && node.type.allowsMarkType(type);\n    });\n\n    if (can) {\n      return {\n        v: true\n      };\n    }\n  };\n\n  for (var i = 0; i < ranges.length; i++) {\n    var returned = loop(i);\n    if (returned) return returned.v;\n  }\n\n  return false;\n} // :: (MarkType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Create a command function that toggles the given mark with the\n// given attributes. Will return `false` when the current selection\n// doesn't support that mark. This will remove the mark if any marks\n// of that type exist in the selection, or add it otherwise. If the\n// selection is empty, this applies to the [stored\n// marks](#state.EditorState.storedMarks) instead of a range of the\n// document.\n\n\nfunction toggleMark(markType, attrs) {\n  return function (state, dispatch) {\n    var ref = state.selection;\n    var empty = ref.empty;\n    var $cursor = ref.$cursor;\n    var ranges = ref.ranges;\n\n    if (empty && !$cursor || !markApplies(state.doc, ranges, markType)) {\n      return false;\n    }\n\n    if (dispatch) {\n      if ($cursor) {\n        if (markType.isInSet(state.storedMarks || $cursor.marks())) {\n          dispatch(state.tr.removeStoredMark(markType));\n        } else {\n          dispatch(state.tr.addStoredMark(markType.create(attrs)));\n        }\n      } else {\n        var has = false,\n            tr = state.tr;\n\n        for (var i = 0; !has && i < ranges.length; i++) {\n          var ref$1 = ranges[i];\n          var $from = ref$1.$from;\n          var $to = ref$1.$to;\n          has = state.doc.rangeHasMark($from.pos, $to.pos, markType);\n        }\n\n        for (var i$1 = 0; i$1 < ranges.length; i$1++) {\n          var ref$2 = ranges[i$1];\n          var $from$1 = ref$2.$from;\n          var $to$1 = ref$2.$to;\n\n          if (has) {\n            tr.removeMark($from$1.pos, $to$1.pos, markType);\n          } else {\n            tr.addMark($from$1.pos, $to$1.pos, markType.create(attrs));\n          }\n        }\n\n        dispatch(tr.scrollIntoView());\n      }\n    }\n\n    return true;\n  };\n}\n\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n  return function (tr) {\n    if (!tr.isGeneric) {\n      return dispatch(tr);\n    }\n\n    var ranges = [];\n\n    for (var i = 0; i < tr.mapping.maps.length; i++) {\n      var map = tr.mapping.maps[i];\n\n      for (var j = 0; j < ranges.length; j++) {\n        ranges[j] = map.map(ranges[j]);\n      }\n\n      map.forEach(function (_s, _e, from, to) {\n        return ranges.push(from, to);\n      });\n    } // Figure out which joinable points exist inside those ranges,\n    // by checking all node boundaries in their parent nodes.\n\n\n    var joinable = [];\n\n    for (var i$1 = 0; i$1 < ranges.length; i$1 += 2) {\n      var from = ranges[i$1],\n          to = ranges[i$1 + 1];\n      var $from = tr.doc.resolve(from),\n          depth = $from.sharedDepth(to),\n          parent = $from.node(depth);\n\n      for (var index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {\n        var after = parent.maybeChild(index);\n\n        if (!after) {\n          break;\n        }\n\n        if (index && joinable.indexOf(pos) == -1) {\n          var before = parent.child(index - 1);\n\n          if (before.type == after.type && isJoinable(before, after)) {\n            joinable.push(pos);\n          }\n        }\n\n        pos += after.nodeSize;\n      }\n    } // Join the joinable points\n\n\n    joinable.sort(function (a, b) {\n      return a - b;\n    });\n\n    for (var i$2 = joinable.length - 1; i$2 >= 0; i$2--) {\n      if (canJoin(tr.doc, joinable[i$2])) {\n        tr.join(joinable[i$2]);\n      }\n    }\n\n    dispatch(tr);\n  };\n} // :: ((state: EditorState, ?(tr: Transaction)) → bool, union<(before: Node, after: Node) → bool, [string]>) → (state: EditorState, ?(tr: Transaction)) → bool\n// Wrap a command so that, when it produces a transform that causes\n// two joinable nodes to end up next to each other, those are joined.\n// Nodes are considered joinable when they are of the same type and\n// when the `isJoinable` predicate returns true for them or, if an\n// array of strings was passed, if their node type name is in that\n// array.\n\n\nfunction autoJoin(command, isJoinable) {\n  if (Array.isArray(isJoinable)) {\n    var types = isJoinable;\n\n    isJoinable = function (node) {\n      return types.indexOf(node.type.name) > -1;\n    };\n  }\n\n  return function (state, dispatch) {\n    return command(state, dispatch && wrapDispatchForJoin(dispatch, isJoinable));\n  };\n} // :: (...[(EditorState, ?(tr: Transaction), ?EditorView) → bool]) → (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// Combine a number of command functions into a single function (which\n// calls them one by one until one returns true).\n\n\nfunction chainCommands() {\n  var commands = [],\n      len = arguments.length;\n\n  while (len--) commands[len] = arguments[len];\n\n  return function (state, dispatch, view) {\n    for (var i = 0; i < commands.length; i++) {\n      if (commands[i](state, dispatch, view)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n}\n\nvar backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);\nvar del = chainCommands(deleteSelection, joinForward, selectNodeForward); // :: Object\n// A basic keymap containing bindings not specific to any schema.\n// Binds the following keys (when multiple commands are listed, they\n// are chained with [`chainCommands`](#commands.chainCommands)):\n//\n// * **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n// * **Mod-Enter** to `exitCode`\n// * **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n// * **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-a** to `selectAll`\n\nvar pcBaseKeymap = {\n  \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n  \"Mod-Enter\": exitCode,\n  \"Backspace\": backspace,\n  \"Mod-Backspace\": backspace,\n  \"Delete\": del,\n  \"Mod-Delete\": del,\n  \"Mod-a\": selectAll\n}; // :: Object\n// A copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n// **Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n// **Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\n// Ctrl-Delete.\n\nvar macBaseKeymap = {\n  \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n  \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n  \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n  \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"]\n};\n\nfor (var key in pcBaseKeymap) {\n  macBaseKeymap[key] = pcBaseKeymap[key];\n} // declare global: os, navigator\n\n\nvar mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform) : typeof os != \"undefined\" ? os.platform() == \"darwin\" : false; // :: Object\n// Depending on the detected platform, this will hold\n// [`pcBasekeymap`](#commands.pcBaseKeymap) or\n// [`macBaseKeymap`](#commands.macBaseKeymap).\n\nvar baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;\nexport { autoJoin, baseKeymap, chainCommands, createParagraphNear, deleteSelection, exitCode, joinBackward, joinDown, joinForward, joinUp, lift, liftEmptyBlock, macBaseKeymap, newlineInCode, pcBaseKeymap, selectAll, selectNodeBackward, selectNodeForward, selectParentNode, setBlockType, splitBlock, splitBlockKeepMarks, toggleMark, wrapIn };","map":{"version":3,"sources":["../src/commands.js"],"names":["let","i","$from","$to","const"],"mappings":"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","sourcesContent":["import {joinPoint, canJoin, findWrapping, liftTarget, canSplit, ReplaceAroundStep} from \"prosemirror-transform\"\nimport {Slice, Fragment} from \"prosemirror-model\"\nimport {Selection, TextSelection, NodeSelection, AllSelection} from \"prosemirror-state\"\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Delete the selection, if there is one.\nexport function deleteSelection(state, dispatch) {\n  if (state.selection.empty) return false\n  if (dispatch) dispatch(state.tr.deleteSelection().scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// If the selection is empty and at the start of a textblock, try to\n// reduce the distance between that block and the one before it—if\n// there's a block directly before it that can be joined, join them.\n// If not, try to move the selected block closer to the next one in\n// the document structure by lifting it out of its parent or moving it\n// into a parent of the previous block. Will use the view for accurate\n// (bidi-aware) start-of-textblock detection if given.\nexport function joinBackward(state, dispatch, view) {\n  let {$cursor} = state.selection\n  if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state)\n                        : $cursor.parentOffset > 0))\n    return false\n\n  let $cut = findCutBefore($cursor)\n\n  // If there is no node before this, try to lift\n  if (!$cut) {\n    let range = $cursor.blockRange(), target = range && liftTarget(range)\n    if (target == null) return false\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n    return true\n  }\n\n  let before = $cut.nodeBefore\n  // Apply the joining algorithm\n  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))\n    return true\n\n  // If the node below has no content and the node above is\n  // selectable, delete the node below and select the one above.\n  if ($cursor.parent.content.size == 0 &&\n      (textblockAt(before, \"end\") || NodeSelection.isSelectable(before))) {\n    if (dispatch) {\n      let tr = state.tr.deleteRange($cursor.before(), $cursor.after())\n      tr.setSelection(textblockAt(before, \"end\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1)\n                      : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize))\n      dispatch(tr.scrollIntoView())\n    }\n    return true\n  }\n\n  // If the node before is an atom, delete it\n  if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView())\n    return true\n  }\n\n  return false\n}\n\nfunction textblockAt(node, side) {\n  for (; node; node = (side == \"start\" ? node.firstChild : node.lastChild))\n    if (node.isTextblock) return true\n  return false\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// When the selection is empty and at the start of a textblock, select\n// the node before that textblock, if possible. This is intended to be\n// bound to keys like backspace, after\n// [`joinBackward`](#commands.joinBackward) or other deleting\n// commands, as a fall-back behavior when the schema doesn't allow\n// deletion at the selected point.\nexport function selectNodeBackward(state, dispatch, view) {\n  let {$head, empty} = state.selection, $cut = $head\n  if (!empty) return false\n\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0) return false\n    $cut = findCutBefore($head)\n  }\n  let node = $cut && $cut.nodeBefore\n  if (!node || !NodeSelection.isSelectable(node)) return false\n  if (dispatch)\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView())\n  return true\n}\n\nfunction findCutBefore($pos) {\n  if (!$pos.parent.type.spec.isolating) for (let i = $pos.depth - 1; i >= 0; i--) {\n    if ($pos.index(i) > 0) return $pos.doc.resolve($pos.before(i + 1))\n    if ($pos.node(i).type.spec.isolating) break\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// If the selection is empty and the cursor is at the end of a\n// textblock, try to reduce or remove the boundary between that block\n// and the one after it, either by joining them or by moving the other\n// block closer to this one in the tree structure. Will use the view\n// for accurate start-of-textblock detection if given.\nexport function joinForward(state, dispatch, view) {\n  let {$cursor} = state.selection\n  if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state)\n                        : $cursor.parentOffset < $cursor.parent.content.size))\n    return false\n\n  let $cut = findCutAfter($cursor)\n\n  // If there is no node after this, there's nothing to do\n  if (!$cut) return false\n\n  let after = $cut.nodeAfter\n  // Try the joining algorithm\n  if (deleteBarrier(state, $cut, dispatch)) return true\n\n  // If the node above has no content and the node below is\n  // selectable, delete the node above and select the one below.\n  if ($cursor.parent.content.size == 0 &&\n      (textblockAt(after, \"start\") || NodeSelection.isSelectable(after))) {\n    if (dispatch) {\n      let tr = state.tr.deleteRange($cursor.before(), $cursor.after())\n      tr.setSelection(textblockAt(after, \"start\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1)\n                      : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)))\n      dispatch(tr.scrollIntoView())\n    }\n    return true\n  }\n\n  // If the next node is an atom, delete it\n  if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView())\n    return true\n  }\n\n  return false\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// When the selection is empty and at the end of a textblock, select\n// the node coming after that textblock, if possible. This is intended\n// to be bound to keys like delete, after\n// [`joinForward`](#commands.joinForward) and similar deleting\n// commands, to provide a fall-back behavior when the schema doesn't\n// allow deletion at the selected point.\nexport function selectNodeForward(state, dispatch, view) {\n  let {$head, empty} = state.selection, $cut = $head\n  if (!empty) return false\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size)\n      return false\n    $cut = findCutAfter($head)\n  }\n  let node = $cut && $cut.nodeAfter\n  if (!node || !NodeSelection.isSelectable(node)) return false\n  if (dispatch)\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView())\n  return true\n}\n\nfunction findCutAfter($pos) {\n  if (!$pos.parent.type.spec.isolating) for (let i = $pos.depth - 1; i >= 0; i--) {\n    let parent = $pos.node(i)\n    if ($pos.index(i) + 1 < parent.childCount) return $pos.doc.resolve($pos.after(i + 1))\n    if (parent.type.spec.isolating) break\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Join the selected block or, if there is a text selection, the\n// closest ancestor block of the selection that can be joined, with\n// the sibling above it.\nexport function joinUp(state, dispatch) {\n  let sel = state.selection, nodeSel = sel instanceof NodeSelection, point\n  if (nodeSel) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.from)) return false\n    point = sel.from\n  } else {\n    point = joinPoint(state.doc, sel.from, -1)\n    if (point == null) return false\n  }\n  if (dispatch) {\n    let tr = state.tr.join(point)\n    if (nodeSel) tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Join the selected block, or the closest ancestor of the selection\n// that can be joined, with the sibling after it.\nexport function joinDown(state, dispatch) {\n  let sel = state.selection, point\n  if (sel instanceof NodeSelection) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.to)) return false\n    point = sel.to\n  } else {\n    point = joinPoint(state.doc, sel.to, 1)\n    if (point == null) return false\n  }\n  if (dispatch)\n    dispatch(state.tr.join(point).scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Lift the selected block, or the closest ancestor block of the\n// selection that can be lifted, out of its parent node.\nexport function lift(state, dispatch) {\n  let {$from, $to} = state.selection\n  let range = $from.blockRange($to), target = range && liftTarget(range)\n  if (target == null) return false\n  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If the selection is in a node whose type has a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, replace the\n// selection with a newline character.\nexport function newlineInCode(state, dispatch) {\n  let {$head, $anchor} = state.selection\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false\n  if (dispatch) dispatch(state.tr.insertText(\"\\n\").scrollIntoView())\n  return true\n}\n\nfunction defaultBlockAt(match) {\n  for (let i = 0; i < match.edgeCount; i++) {\n    let {type} = match.edge(i)\n    if (type.isTextblock && !type.hasRequiredAttrs()) return type\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// When the selection is in a node with a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, create a\n// default block after the code block, and move the cursor there.\nexport function exitCode(state, dispatch) {\n  let {$head, $anchor} = state.selection\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false\n  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after))\n  if (!above.canReplaceWith(after, after, type)) return false\n  if (dispatch) {\n    let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill())\n    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If a block node is selected, create an empty paragraph before (if\n// it is its parent's first child) or after it.\nexport function createParagraphNear(state, dispatch) {\n  let {$from, $to} = state.selection\n  if ($from.parent.inlineContent || $to.parent.inlineContent) return false\n  let type = defaultBlockAt($from.parent.contentMatchAt($to.indexAfter()))\n  if (!type || !type.isTextblock) return false\n  if (dispatch) {\n    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos\n    let tr = state.tr.insert(side, type.createAndFill())\n    tr.setSelection(TextSelection.create(tr.doc, side + 1))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If the cursor is in an empty textblock that can be lifted, lift the\n// block.\nexport function liftEmptyBlock(state, dispatch) {\n  let {$cursor} = state.selection\n  if (!$cursor || $cursor.parent.content.size) return false\n  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n    let before = $cursor.before()\n    if (canSplit(state.doc, before)) {\n      if (dispatch) dispatch(state.tr.split(before).scrollIntoView())\n      return true\n    }\n  }\n  let range = $cursor.blockRange(), target = range && liftTarget(range)\n  if (target == null) return false\n  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Split the parent block of the selection. If the selection is a text\n// selection, also delete its content.\nexport function splitBlock(state, dispatch) {\n  let {$from, $to} = state.selection\n  if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {\n    if (!$from.parentOffset || !canSplit(state.doc, $from.pos)) return false\n    if (dispatch) dispatch(state.tr.split($from.pos).scrollIntoView())\n    return true\n  }\n\n  if (!$from.parent.isBlock) return false\n\n  if (dispatch) {\n    let atEnd = $to.parentOffset == $to.parent.content.size\n    let tr = state.tr\n    if (state.selection instanceof TextSelection) tr.deleteSelection()\n    let deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)))\n    let types = atEnd && deflt ? [{type: deflt}] : null\n    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types)\n    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{type: deflt}])) {\n      types = [{type: deflt}]\n      can = true\n    }\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types)\n      if (!atEnd && !$from.parentOffset && $from.parent.type != deflt &&\n          $from.node(-1).canReplace($from.index(-1), $from.indexAfter(-1), Fragment.from(deflt.create(), $from.parent)))\n        tr.setNodeMarkup(tr.mapping.map($from.before()), deflt)\n    }\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Acts like [`splitBlock`](#commands.splitBlock), but without\n// resetting the set of active marks at the cursor.\nexport function splitBlockKeepMarks(state, dispatch) {\n  return splitBlock(state, dispatch && (tr => {\n    let marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks())\n    if (marks) tr.ensureMarks(marks)\n    dispatch(tr)\n  }))\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Move the selection to the node wrapping the current selection, if\n// any. (Will not select the document node.)\nexport function selectParentNode(state, dispatch) {\n  let {$from, to} = state.selection, pos\n  let same = $from.sharedDepth(to)\n  if (same == 0) return false\n  pos = $from.before(same)\n  if (dispatch) dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)))\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Select the whole document.\nexport function selectAll(state, dispatch) {\n  if (dispatch) dispatch(state.tr.setSelection(new AllSelection(state.doc)))\n  return true\n}\n\nfunction joinMaybeClear(state, $pos, dispatch) {\n  let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index()\n  if (!before || !after || !before.type.compatibleContent(after.type)) return false\n  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n    if (dispatch) dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView())\n    return true\n  }\n  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))\n    return false\n  if (dispatch)\n    dispatch(state.tr\n             .clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount))\n             .join($pos.pos)\n             .scrollIntoView())\n  return true\n}\n\nfunction deleteBarrier(state, $cut, dispatch) {\n  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match\n  if (before.type.spec.isolating || after.type.spec.isolating) return false\n  if (joinMaybeClear(state, $cut, dispatch)) return true\n\n  if ($cut.parent.canReplace($cut.index(), $cut.index() + 1) &&\n      (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) &&\n      match.matchType(conn[0] || after.type).validEnd) {\n    if (dispatch) {\n      let end = $cut.pos + after.nodeSize, wrap = Fragment.empty\n      for (let i = conn.length - 1; i >= 0; i--)\n        wrap = Fragment.from(conn[i].create(null, wrap))\n      wrap = Fragment.from(before.copy(wrap))\n      let tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap, 1, 0), conn.length, true))\n      let joinAt = end + 2 * conn.length\n      if (canJoin(tr.doc, joinAt)) tr.join(joinAt)\n      dispatch(tr.scrollIntoView())\n    }\n    return true\n  }\n\n  let selAfter = Selection.findFrom($cut, 1)\n  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range)\n  if (target != null && target >= $cut.depth) {\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n    return true\n  }\n\n  return false\n}\n\n// Parameterized commands\n\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Wrap the selection in a node of the given type with the given\n// attributes.\nexport function wrapIn(nodeType, attrs) {\n  return function(state, dispatch) {\n    let {$from, $to} = state.selection\n    let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs)\n    if (!wrapping) return false\n    if (dispatch) dispatch(state.tr.wrap(range, wrapping).scrollIntoView())\n    return true\n  }\n}\n\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command that tries to set the selected textblocks to the\n// given node type with the given attributes.\nexport function setBlockType(nodeType, attrs) {\n  return function(state, dispatch) {\n    let {from, to} = state.selection\n    let applicable = false\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (applicable) return false\n      if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) return\n      if (node.type == nodeType) {\n        applicable = true\n      } else {\n        let $pos = state.doc.resolve(pos), index = $pos.index()\n        applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType)\n      }\n    })\n    if (!applicable) return false\n    if (dispatch) dispatch(state.tr.setBlockType(from, to, nodeType, attrs).scrollIntoView())\n    return true\n  }\n}\n\nfunction markApplies(doc, ranges, type) {\n  for (let i = 0; i < ranges.length; i++) {\n    let {$from, $to} = ranges[i]\n    let can = $from.depth == 0 ? doc.type.allowsMarkType(type) : false\n    doc.nodesBetween($from.pos, $to.pos, node => {\n      if (can) return false\n      can = node.inlineContent && node.type.allowsMarkType(type)\n    })\n    if (can) return true\n  }\n  return false\n}\n\n// :: (MarkType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Create a command function that toggles the given mark with the\n// given attributes. Will return `false` when the current selection\n// doesn't support that mark. This will remove the mark if any marks\n// of that type exist in the selection, or add it otherwise. If the\n// selection is empty, this applies to the [stored\n// marks](#state.EditorState.storedMarks) instead of a range of the\n// document.\nexport function toggleMark(markType, attrs) {\n  return function(state, dispatch) {\n    let {empty, $cursor, ranges} = state.selection\n    if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType)) return false\n    if (dispatch) {\n      if ($cursor) {\n        if (markType.isInSet(state.storedMarks || $cursor.marks()))\n          dispatch(state.tr.removeStoredMark(markType))\n        else\n          dispatch(state.tr.addStoredMark(markType.create(attrs)))\n      } else {\n        let has = false, tr = state.tr\n        for (let i = 0; !has && i < ranges.length; i++) {\n          let {$from, $to} = ranges[i]\n          has = state.doc.rangeHasMark($from.pos, $to.pos, markType)\n        }\n        for (let i = 0; i < ranges.length; i++) {\n          let {$from, $to} = ranges[i]\n          if (has) tr.removeMark($from.pos, $to.pos, markType)\n          else tr.addMark($from.pos, $to.pos, markType.create(attrs))\n        }\n        dispatch(tr.scrollIntoView())\n      }\n    }\n    return true\n  }\n}\n\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n  return tr => {\n    if (!tr.isGeneric) return dispatch(tr)\n\n    let ranges = []\n    for (let i = 0; i < tr.mapping.maps.length; i++) {\n      let map = tr.mapping.maps[i]\n      for (let j = 0; j < ranges.length; j++)\n        ranges[j] = map.map(ranges[j])\n      map.forEach((_s, _e, from, to) => ranges.push(from, to))\n    }\n\n    // Figure out which joinable points exist inside those ranges,\n    // by checking all node boundaries in their parent nodes.\n    let joinable = []\n    for (let i = 0; i < ranges.length; i += 2) {\n      let from = ranges[i], to = ranges[i + 1]\n      let $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth)\n      for (let index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {\n        let after = parent.maybeChild(index)\n        if (!after) break\n        if (index && joinable.indexOf(pos) == -1) {\n          let before = parent.child(index - 1)\n          if (before.type == after.type && isJoinable(before, after))\n            joinable.push(pos)\n        }\n        pos += after.nodeSize\n      }\n    }\n    // Join the joinable points\n    joinable.sort((a, b) => a - b)\n    for (let i = joinable.length - 1; i >= 0; i--) {\n      if (canJoin(tr.doc, joinable[i])) tr.join(joinable[i])\n    }\n    dispatch(tr)\n  }\n}\n\n// :: ((state: EditorState, ?(tr: Transaction)) → bool, union<(before: Node, after: Node) → bool, [string]>) → (state: EditorState, ?(tr: Transaction)) → bool\n// Wrap a command so that, when it produces a transform that causes\n// two joinable nodes to end up next to each other, those are joined.\n// Nodes are considered joinable when they are of the same type and\n// when the `isJoinable` predicate returns true for them or, if an\n// array of strings was passed, if their node type name is in that\n// array.\nexport function autoJoin(command, isJoinable) {\n  if (Array.isArray(isJoinable)) {\n    let types = isJoinable\n    isJoinable = node => types.indexOf(node.type.name) > -1\n  }\n  return (state, dispatch) => command(state, dispatch && wrapDispatchForJoin(dispatch, isJoinable))\n}\n\n// :: (...[(EditorState, ?(tr: Transaction), ?EditorView) → bool]) → (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// Combine a number of command functions into a single function (which\n// calls them one by one until one returns true).\nexport function chainCommands(...commands) {\n  return function(state, dispatch, view) {\n    for (let i = 0; i < commands.length; i++)\n      if (commands[i](state, dispatch, view)) return true\n    return false\n  }\n}\n\nlet backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward)\nlet del = chainCommands(deleteSelection, joinForward, selectNodeForward)\n\n// :: Object\n// A basic keymap containing bindings not specific to any schema.\n// Binds the following keys (when multiple commands are listed, they\n// are chained with [`chainCommands`](#commands.chainCommands)):\n//\n// * **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n// * **Mod-Enter** to `exitCode`\n// * **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n// * **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-a** to `selectAll`\nexport let pcBaseKeymap = {\n  \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n  \"Mod-Enter\": exitCode,\n  \"Backspace\": backspace,\n  \"Mod-Backspace\": backspace,\n  \"Delete\": del,\n  \"Mod-Delete\": del,\n  \"Mod-a\": selectAll\n}\n\n// :: Object\n// A copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n// **Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n// **Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\n// Ctrl-Delete.\nexport let macBaseKeymap = {\n  \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n  \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n  \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n  \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"]\n}\nfor (let key in pcBaseKeymap) macBaseKeymap[key] = pcBaseKeymap[key]\n\n// declare global: os, navigator\nconst mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform)\n          : typeof os != \"undefined\" ? os.platform() == \"darwin\" : false\n\n// :: Object\n// Depending on the detected platform, this will hold\n// [`pcBasekeymap`](#commands.pcBaseKeymap) or\n// [`macBaseKeymap`](#commands.macBaseKeymap).\nexport let baseKeymap = mac ? macBaseKeymap : pcBaseKeymap\n"]},"metadata":{},"sourceType":"module"}