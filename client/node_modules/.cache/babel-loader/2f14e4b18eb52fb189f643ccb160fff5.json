{"ast":null,"code":"/**\n * Observable class prototype.\n *\n * @module observable\n */\nimport * as map from './map.js';\nimport * as set from './set.js';\nimport * as array from './array.js';\n/**\n * Handles named events.\n *\n * @template N\n */\n\nexport class Observable {\n  constructor() {\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = map.create();\n  }\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n\n\n  on(name, f) {\n    map.setIfUndefined(this._observers, name, set.create).add(f);\n  }\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n\n\n  once(name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, f);\n      f(...args);\n    };\n\n    this.on(name, _f);\n  }\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n\n\n  off(name, f) {\n    const observers = this._observers.get(name);\n\n    if (observers !== undefined) {\n      observers.delete(f);\n\n      if (observers.size === 0) {\n        this._observers.delete(name);\n      }\n    }\n  }\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n\n\n  emit(name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return array.from((this._observers.get(name) || map.create()).values()).forEach(f => f(...args));\n  }\n\n  destroy() {\n    this._observers = map.create();\n  }\n\n}","map":{"version":3,"sources":["/Users/meeopp/Development/Others/editor-yjs/client/node_modules/lib0/observable.js"],"names":["map","set","array","Observable","constructor","_observers","create","on","name","f","setIfUndefined","add","once","_f","args","off","observers","get","undefined","delete","size","emit","from","values","forEach","destroy"],"mappings":"AAAA;;;;;AAMA,OAAO,KAAKA,GAAZ,MAAqB,UAArB;AACA,OAAO,KAAKC,GAAZ,MAAqB,UAArB;AACA,OAAO,KAAKC,KAAZ,MAAuB,YAAvB;AAEA;;;;;;AAKA,OAAO,MAAMC,UAAN,CAAiB;AACtBC,EAAAA,WAAW,GAAI;AACb;;;;AAIA,SAAKC,UAAL,GAAkBL,GAAG,CAACM,MAAJ,EAAlB;AACD;AAED;;;;;;AAIAC,EAAAA,EAAE,CAAEC,IAAF,EAAQC,CAAR,EAAW;AACXT,IAAAA,GAAG,CAACU,cAAJ,CAAmB,KAAKL,UAAxB,EAAoCG,IAApC,EAA0CP,GAAG,CAACK,MAA9C,EAAsDK,GAAtD,CAA0DF,CAA1D;AACD;AAED;;;;;;AAIAG,EAAAA,IAAI,CAAEJ,IAAF,EAAQC,CAAR,EAAW;AACb;;;AAGA,UAAMI,EAAE,GAAG,CAAC,GAAGC,IAAJ,KAAa;AACtB,WAAKC,GAAL,CAASP,IAAT,EAAeC,CAAf;AACAA,MAAAA,CAAC,CAAC,GAAGK,IAAJ,CAAD;AACD,KAHD;;AAIA,SAAKP,EAAL,CAAQC,IAAR,EAAcK,EAAd;AACD;AAED;;;;;;AAIAE,EAAAA,GAAG,CAAEP,IAAF,EAAQC,CAAR,EAAW;AACZ,UAAMO,SAAS,GAAG,KAAKX,UAAL,CAAgBY,GAAhB,CAAoBT,IAApB,CAAlB;;AACA,QAAIQ,SAAS,KAAKE,SAAlB,EAA6B;AAC3BF,MAAAA,SAAS,CAACG,MAAV,CAAiBV,CAAjB;;AACA,UAAIO,SAAS,CAACI,IAAV,KAAmB,CAAvB,EAA0B;AACxB,aAAKf,UAAL,CAAgBc,MAAhB,CAAuBX,IAAvB;AACD;AACF;AACF;AAED;;;;;;;;;;;AASAa,EAAAA,IAAI,CAAEb,IAAF,EAAQM,IAAR,EAAc;AAChB;AACA,WAAOZ,KAAK,CAACoB,IAAN,CAAW,CAAC,KAAKjB,UAAL,CAAgBY,GAAhB,CAAoBT,IAApB,KAA6BR,GAAG,CAACM,MAAJ,EAA9B,EAA4CiB,MAA5C,EAAX,EAAiEC,OAAjE,CAAyEf,CAAC,IAAIA,CAAC,CAAC,GAAGK,IAAJ,CAA/E,CAAP;AACD;;AAEDW,EAAAA,OAAO,GAAI;AACT,SAAKpB,UAAL,GAAkBL,GAAG,CAACM,MAAJ,EAAlB;AACD;;AA9DqB","sourcesContent":["/**\n * Observable class prototype.\n *\n * @module observable\n */\n\nimport * as map from './map.js'\nimport * as set from './set.js'\nimport * as array from './array.js'\n\n/**\n * Handles named events.\n *\n * @template N\n */\nexport class Observable {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = map.create()\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on (name, f) {\n    map.setIfUndefined(this._observers, name, set.create).add(f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, f)\n      f(...args)\n    }\n    this.on(name, _f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return array.from((this._observers.get(name) || map.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = map.create()\n  }\n}\n"]},"metadata":{},"sourceType":"module"}