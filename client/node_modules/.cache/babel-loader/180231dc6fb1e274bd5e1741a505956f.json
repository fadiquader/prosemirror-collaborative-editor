{"ast":null,"code":"/**\n * @module awareness-protocol\n */\nimport * as encoding from 'lib0/encoding.js';\nimport * as decoding from 'lib0/decoding.js';\nimport * as time from 'lib0/time.js';\nimport * as math from 'lib0/math.js';\nimport { Observable } from 'lib0/observable.js';\nimport * as Y from 'yjs'; // eslint-disable-line\n\nexport const outdatedTimeout = 30000;\n/**\n * @typedef {Object} MetaClientState\n * @property {number} MetaClientState.clock\n * @property {number} MetaClientState.lastUpdated unix timestamp\n */\n\n/**\n * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information\n * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of\n * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.\n *\n * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override\n * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is\n * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that\n * a remote client is offline, it may propagate a message with\n * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a\n * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.\n *\n * Before a client disconnects, it should propagate a `null` state with an updated clock.\n *\n * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.\n *\n * @extends {Observable<string>}\n */\n\nexport class Awareness extends Observable {\n  /**\n   * @param {Y.Doc} doc\n   */\n  constructor(doc) {\n    super();\n    this.doc = doc;\n    /**\n     * Maps from client id to client state\n     * @type {Map<number, Object<string, any>>}\n     */\n\n    this.states = new Map();\n    /**\n     * @type {Map<number, MetaClientState>}\n     */\n\n    this.meta = new Map();\n    this._checkInterval = setInterval(() => {\n      const now = time.getUnixTime();\n\n      if (this.getLocalState() !== null && outdatedTimeout / 2 <= now -\n      /** @type {{lastUpdated:number}} */\n      this.meta.get(doc.clientID).lastUpdated) {\n        // renew local clock\n        this.setLocalState(this.getLocalState());\n      }\n      /**\n       * @type {Array<number>}\n       */\n\n\n      const remove = [];\n      this.meta.forEach((meta, clientid) => {\n        if (clientid !== doc.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {\n          remove.push(clientid);\n        }\n      });\n\n      if (remove.length > 0) {\n        removeAwarenessStates(this, remove, 'timeout');\n      }\n    }, math.floor(outdatedTimeout / 10));\n    doc.on('destroy', () => {\n      this.destroy();\n    });\n    this.setLocalState({});\n  }\n\n  destroy() {\n    clearInterval(this._checkInterval);\n  }\n  /**\n   * @return {Object<string,Object>|null}\n   */\n\n\n  getLocalState() {\n    return this.states.get(this.doc.clientID) || null;\n  }\n  /**\n   * @param {Object<string,any>|null} state\n   */\n\n\n  setLocalState(state) {\n    const clientID = this.doc.clientID;\n    const currLocalMeta = this.meta.get(clientID);\n    const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1;\n\n    if (state === null) {\n      this.states.delete(clientID);\n    } else {\n      this.states.set(clientID, state);\n    }\n\n    this.meta.set(clientID, {\n      clock,\n      lastUpdated: time.getUnixTime()\n    });\n    const added = [];\n    const updated = [];\n    const removed = [];\n\n    if (state === null) {\n      removed.push(clientID);\n    } else if (currLocalMeta === undefined) {\n      added.push(clientID);\n    } else {\n      updated.push(clientID);\n    }\n\n    this.emit('change', [{\n      added,\n      updated,\n      removed\n    }, 'local']);\n  }\n  /**\n   * @param {string} field\n   * @param {Object} value\n   */\n\n\n  setLocalStateField(field, value) {\n    const state = this.getLocalState();\n\n    if (state !== null) {\n      state[field] = value;\n      this.setLocalState(state);\n    }\n  }\n  /**\n   * @return {Map<number,Object<string,any>>}\n   */\n\n\n  getStates() {\n    return this.states;\n  }\n\n}\n/**\n * Mark (remote) clients as inactive and remove them from the list of active peers.\n * This change will be propagated to remote clients.\n *\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @param {any} origin\n */\n\nexport const removeAwarenessStates = (awareness, clients, origin) => {\n  const removed = [];\n\n  for (let i = 0; i < clients.length; i++) {\n    const clientID = clients[i];\n\n    if (awareness.states.has(clientID)) {\n      awareness.states.delete(clientID);\n\n      if (clientID === awareness.doc.clientID) {\n        const curMeta =\n        /** @type {MetaClientState} */\n        awareness.meta.get(clientID);\n        awareness.meta.set(clientID, {\n          clock: curMeta.clock + 1,\n          lastUpdated: time.getUnixTime()\n        });\n      }\n\n      removed.push(clientID);\n    }\n  }\n\n  if (removed.length > 0) {\n    awareness.emit('change', [{\n      added: [],\n      updated: [],\n      removed\n    }, origin]);\n  }\n};\n/**\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @return {Uint8Array}\n */\n\nexport const encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {\n  const len = clients.length;\n  const encoder = encoding.createEncoder();\n  encoding.writeVarUint(encoder, len);\n\n  for (let i = 0; i < len; i++) {\n    const clientID = clients[i];\n    const state = states.get(clientID) || null;\n    const clock =\n    /** @type {MetaClientState} */\n    awareness.meta.get(clientID).clock;\n    encoding.writeVarUint(encoder, clientID);\n    encoding.writeVarUint(encoder, clock);\n    encoding.writeVarString(encoder, JSON.stringify(state));\n  }\n\n  return encoding.toUint8Array(encoder);\n};\n/**\n * @param {Awareness} awareness\n * @param {Uint8Array} update\n * @param {any} origin This will be added to the emitted change event\n */\n\nexport const applyAwarenessUpdate = (awareness, update, origin) => {\n  const decoder = decoding.createDecoder(update);\n  const timestamp = time.getUnixTime();\n  const added = [];\n  const updated = [];\n  const removed = [];\n  const len = decoding.readVarUint(decoder);\n\n  for (let i = 0; i < len; i++) {\n    const clientID = decoding.readVarUint(decoder);\n    let clock = decoding.readVarUint(decoder);\n    const state = JSON.parse(decoding.readVarString(decoder));\n    const clientMeta = awareness.meta.get(clientID);\n    const currClock = clientMeta === undefined ? 0 : clientMeta.clock;\n\n    if (currClock < clock || currClock === clock && state === null && awareness.states.has(clientID)) {\n      if (state === null) {\n        // never let a remote client remove this local state\n        if (clientID === awareness.doc.clientID && awareness.getLocalState() != null) {\n          // remote client removed the local state. Do not remote state. Broadcast a message indicating\n          // that this client still exists by increasing the clock\n          clock++;\n        } else {\n          awareness.states.delete(clientID);\n        }\n      } else {\n        awareness.states.set(clientID, state);\n      }\n\n      awareness.meta.set(clientID, {\n        clock,\n        lastUpdated: timestamp\n      });\n\n      if (clientMeta === undefined && state !== null) {\n        added.push(clientID);\n      } else if (clientMeta !== undefined && state === null) {\n        removed.push(clientID);\n      } else if (state !== null) {\n        updated.push(clientID);\n      }\n    }\n  }\n\n  if (added.length > 0 || updated.length > 0 || removed.length > 0) {\n    awareness.emit('change', [{\n      added,\n      updated,\n      removed\n    }, origin]);\n  }\n};","map":{"version":3,"sources":["/Users/meeopp/Development/Others/editor-yjs/client/node_modules/y-protocols/awareness.js"],"names":["encoding","decoding","time","math","Observable","Y","outdatedTimeout","Awareness","constructor","doc","states","Map","meta","_checkInterval","setInterval","now","getUnixTime","getLocalState","get","clientID","lastUpdated","setLocalState","remove","forEach","clientid","has","push","length","removeAwarenessStates","floor","on","destroy","clearInterval","state","currLocalMeta","clock","undefined","delete","set","added","updated","removed","emit","setLocalStateField","field","value","getStates","awareness","clients","origin","i","curMeta","encodeAwarenessUpdate","len","encoder","createEncoder","writeVarUint","writeVarString","JSON","stringify","toUint8Array","applyAwarenessUpdate","update","decoder","createDecoder","timestamp","readVarUint","parse","readVarString","clientMeta","currClock"],"mappings":"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","sourcesContent":["/**\n * @module awareness-protocol\n */\n\nimport * as encoding from 'lib0/encoding.js'\nimport * as decoding from 'lib0/decoding.js'\nimport * as time from 'lib0/time.js'\nimport * as math from 'lib0/math.js'\nimport { Observable } from 'lib0/observable.js'\nimport * as Y from 'yjs' // eslint-disable-line\n\nexport const outdatedTimeout = 30000\n\n/**\n * @typedef {Object} MetaClientState\n * @property {number} MetaClientState.clock\n * @property {number} MetaClientState.lastUpdated unix timestamp\n */\n\n/**\n * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information\n * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of\n * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.\n *\n * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override\n * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is\n * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that\n * a remote client is offline, it may propagate a message with\n * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a\n * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.\n *\n * Before a client disconnects, it should propagate a `null` state with an updated clock.\n *\n * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.\n *\n * @extends {Observable<string>}\n */\nexport class Awareness extends Observable {\n  /**\n   * @param {Y.Doc} doc\n   */\n  constructor (doc) {\n    super()\n    this.doc = doc\n    /**\n     * Maps from client id to client state\n     * @type {Map<number, Object<string, any>>}\n     */\n    this.states = new Map()\n    /**\n     * @type {Map<number, MetaClientState>}\n     */\n    this.meta = new Map()\n    this._checkInterval = setInterval(() => {\n      const now = time.getUnixTime()\n      if (this.getLocalState() !== null && (outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */ (this.meta.get(doc.clientID)).lastUpdated)) {\n        // renew local clock\n        this.setLocalState(this.getLocalState())\n      }\n      /**\n       * @type {Array<number>}\n       */\n      const remove = []\n      this.meta.forEach((meta, clientid) => {\n        if (clientid !== doc.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {\n          remove.push(clientid)\n        }\n      })\n      if (remove.length > 0) {\n        removeAwarenessStates(this, remove, 'timeout')\n      }\n    }, math.floor(outdatedTimeout / 10))\n    doc.on('destroy', () => {\n      this.destroy()\n    })\n    this.setLocalState({})\n  }\n  destroy () {\n    clearInterval(this._checkInterval)\n  }\n  /**\n   * @return {Object<string,Object>|null}\n   */\n  getLocalState () {\n    return this.states.get(this.doc.clientID) || null\n  }\n  /**\n   * @param {Object<string,any>|null} state\n   */\n  setLocalState (state) {\n    const clientID = this.doc.clientID\n    const currLocalMeta = this.meta.get(clientID)\n    const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1\n    if (state === null) {\n      this.states.delete(clientID)\n    } else {\n      this.states.set(clientID, state)\n    }\n    this.meta.set(clientID, {\n      clock,\n      lastUpdated: time.getUnixTime()\n    })\n    const added = []\n    const updated = []\n    const removed = []\n    if (state === null) {\n      removed.push(clientID)\n    } else if (currLocalMeta === undefined) {\n      added.push(clientID)\n    } else {\n      updated.push(clientID)\n    }\n    this.emit('change', [{ added, updated, removed }, 'local'])\n  }\n  /**\n   * @param {string} field\n   * @param {Object} value\n   */\n  setLocalStateField (field, value) {\n    const state = this.getLocalState()\n    if (state !== null) {\n      state[field] = value\n      this.setLocalState(state)\n    }\n  }\n  /**\n   * @return {Map<number,Object<string,any>>}\n   */\n  getStates () {\n    return this.states\n  }\n}\n\n/**\n * Mark (remote) clients as inactive and remove them from the list of active peers.\n * This change will be propagated to remote clients.\n *\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @param {any} origin\n */\nexport const removeAwarenessStates = (awareness, clients, origin) => {\n  const removed = []\n  for (let i = 0; i < clients.length; i++) {\n    const clientID = clients[i]\n    if (awareness.states.has(clientID)) {\n      awareness.states.delete(clientID)\n      if (clientID === awareness.doc.clientID) {\n        const curMeta = /** @type {MetaClientState} */ (awareness.meta.get(clientID))\n        awareness.meta.set(clientID, {\n          clock: curMeta.clock + 1,\n          lastUpdated: time.getUnixTime()\n        })\n      }\n      removed.push(clientID)\n    }\n  }\n  if (removed.length > 0) {\n    awareness.emit('change', [{ added: [], updated: [], removed }, origin])\n  }\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @return {Uint8Array}\n */\nexport const encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {\n  const len = clients.length\n  const encoder = encoding.createEncoder()\n  encoding.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = clients[i]\n    const state = states.get(clientID) || null\n    const clock = /** @type {MetaClientState} */ (awareness.meta.get(clientID)).clock\n    encoding.writeVarUint(encoder, clientID)\n    encoding.writeVarUint(encoder, clock)\n    encoding.writeVarString(encoder, JSON.stringify(state))\n  }\n  return encoding.toUint8Array(encoder)\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Uint8Array} update\n * @param {any} origin This will be added to the emitted change event\n */\nexport const applyAwarenessUpdate = (awareness, update, origin) => {\n  const decoder = decoding.createDecoder(update)\n  const timestamp = time.getUnixTime()\n  const added = []\n  const updated = []\n  const removed = []\n  const len = decoding.readVarUint(decoder)\n  for (let i = 0; i < len; i++) {\n    const clientID = decoding.readVarUint(decoder)\n    let clock = decoding.readVarUint(decoder)\n    const state = JSON.parse(decoding.readVarString(decoder))\n    const clientMeta = awareness.meta.get(clientID)\n    const currClock = clientMeta === undefined ? 0 : clientMeta.clock\n    if (currClock < clock || (currClock === clock && state === null && awareness.states.has(clientID))) {\n      if (state === null) {\n        // never let a remote client remove this local state\n        if (clientID === awareness.doc.clientID && awareness.getLocalState() != null) {\n          // remote client removed the local state. Do not remote state. Broadcast a message indicating\n          // that this client still exists by increasing the clock\n          clock++\n        } else {\n          awareness.states.delete(clientID)\n        }\n      } else {\n        awareness.states.set(clientID, state)\n      }\n      awareness.meta.set(clientID, {\n        clock,\n        lastUpdated: timestamp\n      })\n      if (clientMeta === undefined && state !== null) {\n        added.push(clientID)\n      } else if (clientMeta !== undefined && state === null) {\n        removed.push(clientID)\n      } else if (state !== null) {\n        updated.push(clientID)\n      }\n    }\n  }\n  if (added.length > 0 || updated.length > 0 || removed.length > 0) {\n    awareness.emit('change', [{\n      added, updated, removed\n    }, origin])\n  }\n}\n"]},"metadata":{},"sourceType":"module"}