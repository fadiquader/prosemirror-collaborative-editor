{"ast":null,"code":"import { keydownHandler } from 'prosemirror-keymap';\nimport { NodeSelection, Selection, Plugin, TextSelection } from 'prosemirror-state';\nimport { DecorationSet, Decoration } from 'prosemirror-view';\nimport { Slice } from 'prosemirror-model'; // ::- Gap cursor selections are represented using this class. Its\n// `$anchor` and `$head` properties both point at the cursor position.\n\nvar GapCursor = /*@__PURE__*/function (Selection) {\n  function GapCursor($pos) {\n    Selection.call(this, $pos, $pos);\n  }\n\n  if (Selection) GapCursor.__proto__ = Selection;\n  GapCursor.prototype = Object.create(Selection && Selection.prototype);\n  GapCursor.prototype.constructor = GapCursor;\n\n  GapCursor.prototype.map = function map(doc, mapping) {\n    var $pos = doc.resolve(mapping.map(this.head));\n    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);\n  };\n\n  GapCursor.prototype.content = function content() {\n    return Slice.empty;\n  };\n\n  GapCursor.prototype.eq = function eq(other) {\n    return other instanceof GapCursor && other.head == this.head;\n  };\n\n  GapCursor.prototype.toJSON = function toJSON() {\n    return {\n      type: \"gapcursor\",\n      pos: this.head\n    };\n  };\n\n  GapCursor.fromJSON = function fromJSON(doc, json) {\n    if (typeof json.pos != \"number\") {\n      throw new RangeError(\"Invalid input for GapCursor.fromJSON\");\n    }\n\n    return new GapCursor(doc.resolve(json.pos));\n  };\n\n  GapCursor.prototype.getBookmark = function getBookmark() {\n    return new GapBookmark(this.anchor);\n  };\n\n  GapCursor.valid = function valid($pos) {\n    var parent = $pos.parent;\n\n    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) {\n      return false;\n    }\n\n    var override = parent.type.spec.allowGapCursor;\n\n    if (override != null) {\n      return override;\n    }\n\n    var deflt = parent.contentMatchAt($pos.index()).defaultType;\n    return deflt && deflt.isTextblock;\n  };\n\n  GapCursor.findFrom = function findFrom($pos, dir, mustMove) {\n    search: for (;;) {\n      if (!mustMove && GapCursor.valid($pos)) {\n        return $pos;\n      }\n\n      var pos = $pos.pos,\n          next = null; // Scan up from this position\n\n      for (var d = $pos.depth;; d--) {\n        var parent = $pos.node(d);\n\n        if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {\n          next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);\n          break;\n        } else if (d == 0) {\n          return null;\n        }\n\n        pos += dir;\n        var $cur = $pos.doc.resolve(pos);\n\n        if (GapCursor.valid($cur)) {\n          return $cur;\n        }\n      } // And then down into the next node\n\n\n      for (;;) {\n        var inside = dir > 0 ? next.firstChild : next.lastChild;\n\n        if (!inside) {\n          if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {\n            $pos = $pos.doc.resolve(pos + next.nodeSize * dir);\n            mustMove = false;\n            continue search;\n          }\n\n          break;\n        }\n\n        next = inside;\n        pos += dir;\n        var $cur$1 = $pos.doc.resolve(pos);\n\n        if (GapCursor.valid($cur$1)) {\n          return $cur$1;\n        }\n      }\n\n      return null;\n    }\n  };\n\n  return GapCursor;\n}(Selection);\n\nGapCursor.prototype.visible = false;\nSelection.jsonID(\"gapcursor\", GapCursor);\n\nvar GapBookmark = function GapBookmark(pos) {\n  this.pos = pos;\n};\n\nGapBookmark.prototype.map = function map(mapping) {\n  return new GapBookmark(mapping.map(this.pos));\n};\n\nGapBookmark.prototype.resolve = function resolve(doc) {\n  var $pos = doc.resolve(this.pos);\n  return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);\n};\n\nfunction closedBefore($pos) {\n  for (var d = $pos.depth; d >= 0; d--) {\n    var index = $pos.index(d); // At the start of this parent, look at next one\n\n    if (index == 0) {\n      continue;\n    } // See if the node before (or its first ancestor) is closed\n\n\n    for (var before = $pos.node(d).child(index - 1);; before = before.lastChild) {\n      if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating) {\n        return true;\n      }\n\n      if (before.inlineContent) {\n        return false;\n      }\n    }\n  } // Hit start of document\n\n\n  return true;\n}\n\nfunction closedAfter($pos) {\n  for (var d = $pos.depth; d >= 0; d--) {\n    var index = $pos.indexAfter(d),\n        parent = $pos.node(d);\n\n    if (index == parent.childCount) {\n      continue;\n    }\n\n    for (var after = parent.child(index);; after = after.firstChild) {\n      if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating) {\n        return true;\n      }\n\n      if (after.inlineContent) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n} // :: () â†’ Plugin\n// Create a gap cursor plugin. When enabled, this will capture clicks\n// near and arrow-key-motion past places that don't have a normally\n// selectable position nearby, and create a gap cursor selection for\n// them. The cursor is drawn as an element with class\n// `ProseMirror-gapcursor`. You can either include\n// `style/gapcursor.css` from the package's directory or add your own\n// styles to make it visible.\n\n\nvar gapCursor = function () {\n  return new Plugin({\n    props: {\n      decorations: drawGapCursor,\n      createSelectionBetween: function createSelectionBetween(_view, $anchor, $head) {\n        if ($anchor.pos == $head.pos && GapCursor.valid($head)) {\n          return new GapCursor($head);\n        }\n      },\n      handleClick: handleClick,\n      handleKeyDown: handleKeyDown\n    }\n  });\n};\n\nvar handleKeyDown = keydownHandler({\n  \"ArrowLeft\": arrow(\"horiz\", -1),\n  \"ArrowRight\": arrow(\"horiz\", 1),\n  \"ArrowUp\": arrow(\"vert\", -1),\n  \"ArrowDown\": arrow(\"vert\", 1)\n});\n\nfunction arrow(axis, dir) {\n  var dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\n  return function (state, dispatch, view) {\n    var sel = state.selection;\n    var $start = dir > 0 ? sel.$to : sel.$from,\n        mustMove = sel.empty;\n\n    if (sel instanceof TextSelection) {\n      if (!view.endOfTextblock(dirStr) || $start.depth == 0) {\n        return false;\n      }\n\n      mustMove = false;\n      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());\n    }\n\n    var $found = GapCursor.findFrom($start, dir, mustMove);\n\n    if (!$found) {\n      return false;\n    }\n\n    if (dispatch) {\n      dispatch(state.tr.setSelection(new GapCursor($found)));\n    }\n\n    return true;\n  };\n}\n\nfunction handleClick(view, pos, event) {\n  if (!view.editable) {\n    return false;\n  }\n\n  var $pos = view.state.doc.resolve(pos);\n\n  if (!GapCursor.valid($pos)) {\n    return false;\n  }\n\n  var ref = view.posAtCoords({\n    left: event.clientX,\n    top: event.clientY\n  });\n  var inside = ref.inside;\n\n  if (inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(inside))) {\n    return false;\n  }\n\n  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));\n  return true;\n}\n\nfunction drawGapCursor(state) {\n  if (!(state.selection instanceof GapCursor)) {\n    return null;\n  }\n\n  var node = document.createElement(\"div\");\n  node.className = \"ProseMirror-gapcursor\";\n  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, {\n    key: \"gapcursor\"\n  })]);\n}\n\nexport { GapCursor, gapCursor };","map":{"version":3,"sources":["../src/gapcursor.js","../src/index.js"],"names":["super","let","$cur","const"],"mappings":"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","sourcesContent":["import {Selection, NodeSelection} from \"prosemirror-state\"\nimport {Slice} from \"prosemirror-model\"\n\n// ::- Gap cursor selections are represented using this class. Its\n// `$anchor` and `$head` properties both point at the cursor position.\nexport class GapCursor extends Selection {\n  // : (ResolvedPos)\n  constructor($pos) {\n    super($pos, $pos)\n  }\n\n  map(doc, mapping) {\n    let $pos = doc.resolve(mapping.map(this.head))\n    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos)\n  }\n\n  content() { return Slice.empty }\n\n  eq(other) {\n    return other instanceof GapCursor && other.head == this.head\n  }\n\n  toJSON() {\n    return {type: \"gapcursor\", pos: this.head}\n  }\n\n  static fromJSON(doc, json) {\n    if (typeof json.pos != \"number\") throw new RangeError(\"Invalid input for GapCursor.fromJSON\")\n    return new GapCursor(doc.resolve(json.pos))\n  }\n\n  getBookmark() { return new GapBookmark(this.anchor) }\n\n  static valid($pos) {\n    let parent = $pos.parent\n    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) return false\n    let override = parent.type.spec.allowGapCursor\n    if (override != null) return override\n    let deflt = parent.contentMatchAt($pos.index()).defaultType\n    return deflt && deflt.isTextblock\n  }\n\n  static findFrom($pos, dir, mustMove) {\n    search: for (;;) {\n      if (!mustMove && GapCursor.valid($pos)) return $pos\n      let pos = $pos.pos, next = null\n      // Scan up from this position\n      for (let d = $pos.depth;; d--) {\n        let parent = $pos.node(d)\n        if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {\n          next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1)\n          break\n        } else if (d == 0) {\n          return null\n        }\n        pos += dir\n        let $cur = $pos.doc.resolve(pos)\n        if (GapCursor.valid($cur)) return $cur\n      }\n\n      // And then down into the next node\n      for (;;) {\n        let inside = dir > 0 ? next.firstChild : next.lastChild\n        if (!inside) {\n          if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {\n            $pos = $pos.doc.resolve(pos + next.nodeSize * dir)\n            mustMove = false\n            continue search\n          }\n          break\n        }\n        next = inside\n        pos += dir\n        let $cur = $pos.doc.resolve(pos)\n        if (GapCursor.valid($cur)) return $cur\n      }\n\n      return null\n    }\n  }\n}\n\nGapCursor.prototype.visible = false\n\nSelection.jsonID(\"gapcursor\", GapCursor)\n\nclass GapBookmark {\n  constructor(pos) {\n    this.pos = pos\n  }\n  map(mapping) {\n    return new GapBookmark(mapping.map(this.pos))\n  }\n  resolve(doc) {\n    let $pos = doc.resolve(this.pos)\n    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos)\n  }\n}\n\nfunction closedBefore($pos) {\n  for (let d = $pos.depth; d >= 0; d--) {\n    let index = $pos.index(d)\n    // At the start of this parent, look at next one\n    if (index == 0) continue\n    // See if the node before (or its first ancestor) is closed\n    for (let before = $pos.node(d).child(index - 1);; before = before.lastChild) {\n      if ((before.childCount == 0 && !before.inlineContent) || before.isAtom || before.type.spec.isolating) return true\n      if (before.inlineContent) return false\n    }\n  }\n  // Hit start of document\n  return true\n}\n\nfunction closedAfter($pos) {\n  for (let d = $pos.depth; d >= 0; d--) {\n    let index = $pos.indexAfter(d), parent = $pos.node(d)\n    if (index == parent.childCount) continue\n    for (let after = parent.child(index);; after = after.firstChild) {\n      if ((after.childCount == 0 && !after.inlineContent) || after.isAtom || after.type.spec.isolating) return true\n      if (after.inlineContent) return false\n    }\n  }\n  return true\n}\n","import {keydownHandler} from \"prosemirror-keymap\"\nimport {TextSelection, NodeSelection, Plugin} from \"prosemirror-state\"\nimport {Decoration, DecorationSet} from \"prosemirror-view\"\n\nimport {GapCursor} from \"./gapcursor\"\n\n// :: () â†’ Plugin\n// Create a gap cursor plugin. When enabled, this will capture clicks\n// near and arrow-key-motion past places that don't have a normally\n// selectable position nearby, and create a gap cursor selection for\n// them. The cursor is drawn as an element with class\n// `ProseMirror-gapcursor`. You can either include\n// `style/gapcursor.css` from the package's directory or add your own\n// styles to make it visible.\nexport const gapCursor = function() {\n  return new Plugin({\n    props: {\n      decorations: drawGapCursor,\n\n      createSelectionBetween(_view, $anchor, $head) {\n        if ($anchor.pos == $head.pos && GapCursor.valid($head)) return new GapCursor($head)\n      },\n\n      handleClick,\n      handleKeyDown\n    }\n  })\n}\n\nexport {GapCursor}\n\nconst handleKeyDown = keydownHandler({\n  \"ArrowLeft\": arrow(\"horiz\", -1),\n  \"ArrowRight\": arrow(\"horiz\", 1),\n  \"ArrowUp\": arrow(\"vert\", -1),\n  \"ArrowDown\": arrow(\"vert\", 1)\n})\n\nfunction arrow(axis, dir) {\n  let dirStr = axis == \"vert\" ? (dir > 0 ? \"down\" : \"up\") : (dir > 0 ? \"right\" : \"left\")\n  return function(state, dispatch, view) {\n    let sel = state.selection\n    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty\n    if (sel instanceof TextSelection) {\n      if (!view.endOfTextblock(dirStr) || $start.depth == 0) return false\n      mustMove = false\n      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before())\n    }\n    let $found = GapCursor.findFrom($start, dir, mustMove)\n    if (!$found) return false\n    if (dispatch) dispatch(state.tr.setSelection(new GapCursor($found)))\n    return true\n  }\n}\n\nfunction handleClick(view, pos, event) {\n  if (!view.editable) return false\n  let $pos = view.state.doc.resolve(pos)\n  if (!GapCursor.valid($pos)) return false\n  let {inside} = view.posAtCoords({left: event.clientX, top: event.clientY})\n  if (inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(inside))) return false\n  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)))\n  return true\n}\n\nfunction drawGapCursor(state) {\n  if (!(state.selection instanceof GapCursor)) return null\n  let node = document.createElement(\"div\")\n  node.className = \"ProseMirror-gapcursor\"\n  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, {key: \"gapcursor\"})])\n}\n"]},"metadata":{},"sourceType":"module"}