{"ast":null,"code":"var GOOD_LEAF_SIZE = 200; // :: class<T> A rope sequence is a persistent sequence data structure\n// that supports appending, prepending, and slicing without doing a\n// full copy. It is represented as a mostly-balanced tree.\n\nvar RopeSequence = function RopeSequence() {};\n\nRopeSequence.prototype.append = function append(other) {\n  if (!other.length) {\n    return this;\n  }\n\n  other = RopeSequence.from(other);\n  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);\n}; // :: (union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Prepend an array or other rope to this one, returning a new rope.\n\n\nRopeSequence.prototype.prepend = function prepend(other) {\n  if (!other.length) {\n    return this;\n  }\n\n  return RopeSequence.from(other).append(this);\n};\n\nRopeSequence.prototype.appendInner = function appendInner(other) {\n  return new Append(this, other);\n}; // :: (?number, ?number) → RopeSequence<T>\n// Create a rope repesenting a sub-sequence of this rope.\n\n\nRopeSequence.prototype.slice = function slice(from, to) {\n  if (from === void 0) from = 0;\n  if (to === void 0) to = this.length;\n\n  if (from >= to) {\n    return RopeSequence.empty;\n  }\n\n  return this.sliceInner(Math.max(0, from), Math.min(this.length, to));\n}; // :: (number) → T\n// Retrieve the element at the given position from this rope.\n\n\nRopeSequence.prototype.get = function get(i) {\n  if (i < 0 || i >= this.length) {\n    return undefined;\n  }\n\n  return this.getInner(i);\n}; // :: ((element: T, index: number) → ?bool, ?number, ?number)\n// Call the given function for each element between the given\n// indices. This tends to be more efficient than looping over the\n// indices and calling `get`, because it doesn't have to descend the\n// tree for every element.\n\n\nRopeSequence.prototype.forEach = function forEach(f, from, to) {\n  if (from === void 0) from = 0;\n  if (to === void 0) to = this.length;\n\n  if (from <= to) {\n    this.forEachInner(f, from, to, 0);\n  } else {\n    this.forEachInvertedInner(f, from, to, 0);\n  }\n}; // :: ((element: T, index: number) → U, ?number, ?number) → [U]\n// Map the given functions over the elements of the rope, producing\n// a flat array.\n\n\nRopeSequence.prototype.map = function map(f, from, to) {\n  if (from === void 0) from = 0;\n  if (to === void 0) to = this.length;\n  var result = [];\n  this.forEach(function (elt, i) {\n    return result.push(f(elt, i));\n  }, from, to);\n  return result;\n}; // :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Create a rope representing the given array, or return the rope\n// itself if a rope was given.\n\n\nRopeSequence.from = function from(values) {\n  if (values instanceof RopeSequence) {\n    return values;\n  }\n\n  return values && values.length ? new Leaf(values) : RopeSequence.empty;\n};\n\nvar Leaf = /*@__PURE__*/function (RopeSequence) {\n  function Leaf(values) {\n    RopeSequence.call(this);\n    this.values = values;\n  }\n\n  if (RopeSequence) Leaf.__proto__ = RopeSequence;\n  Leaf.prototype = Object.create(RopeSequence && RopeSequence.prototype);\n  Leaf.prototype.constructor = Leaf;\n  var prototypeAccessors = {\n    length: {\n      configurable: true\n    },\n    depth: {\n      configurable: true\n    }\n  };\n\n  Leaf.prototype.flatten = function flatten() {\n    return this.values;\n  };\n\n  Leaf.prototype.sliceInner = function sliceInner(from, to) {\n    if (from == 0 && to == this.length) {\n      return this;\n    }\n\n    return new Leaf(this.values.slice(from, to));\n  };\n\n  Leaf.prototype.getInner = function getInner(i) {\n    return this.values[i];\n  };\n\n  Leaf.prototype.forEachInner = function forEachInner(f, from, to, start) {\n    for (var i = from; i < to; i++) {\n      if (f(this.values[i], start + i) === false) {\n        return false;\n      }\n    }\n  };\n\n  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner(f, from, to, start) {\n    for (var i = from - 1; i >= to; i--) {\n      if (f(this.values[i], start + i) === false) {\n        return false;\n      }\n    }\n  };\n\n  Leaf.prototype.leafAppend = function leafAppend(other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE) {\n      return new Leaf(this.values.concat(other.flatten()));\n    }\n  };\n\n  Leaf.prototype.leafPrepend = function leafPrepend(other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE) {\n      return new Leaf(other.flatten().concat(this.values));\n    }\n  };\n\n  prototypeAccessors.length.get = function () {\n    return this.values.length;\n  };\n\n  prototypeAccessors.depth.get = function () {\n    return 0;\n  };\n\n  Object.defineProperties(Leaf.prototype, prototypeAccessors);\n  return Leaf;\n}(RopeSequence); // :: RopeSequence\n// The empty rope sequence.\n\n\nRopeSequence.empty = new Leaf([]);\n\nvar Append = /*@__PURE__*/function (RopeSequence) {\n  function Append(left, right) {\n    RopeSequence.call(this);\n    this.left = left;\n    this.right = right;\n    this.length = left.length + right.length;\n    this.depth = Math.max(left.depth, right.depth) + 1;\n  }\n\n  if (RopeSequence) Append.__proto__ = RopeSequence;\n  Append.prototype = Object.create(RopeSequence && RopeSequence.prototype);\n  Append.prototype.constructor = Append;\n\n  Append.prototype.flatten = function flatten() {\n    return this.left.flatten().concat(this.right.flatten());\n  };\n\n  Append.prototype.getInner = function getInner(i) {\n    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);\n  };\n\n  Append.prototype.forEachInner = function forEachInner(f, from, to, start) {\n    var leftLen = this.left.length;\n\n    if (from < leftLen && this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false) {\n      return false;\n    }\n\n    if (to > leftLen && this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false) {\n      return false;\n    }\n  };\n\n  Append.prototype.forEachInvertedInner = function forEachInvertedInner(f, from, to, start) {\n    var leftLen = this.left.length;\n\n    if (from > leftLen && this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false) {\n      return false;\n    }\n\n    if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false) {\n      return false;\n    }\n  };\n\n  Append.prototype.sliceInner = function sliceInner(from, to) {\n    if (from == 0 && to == this.length) {\n      return this;\n    }\n\n    var leftLen = this.left.length;\n\n    if (to <= leftLen) {\n      return this.left.slice(from, to);\n    }\n\n    if (from >= leftLen) {\n      return this.right.slice(from - leftLen, to - leftLen);\n    }\n\n    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen));\n  };\n\n  Append.prototype.leafAppend = function leafAppend(other) {\n    var inner = this.right.leafAppend(other);\n\n    if (inner) {\n      return new Append(this.left, inner);\n    }\n  };\n\n  Append.prototype.leafPrepend = function leafPrepend(other) {\n    var inner = this.left.leafPrepend(other);\n\n    if (inner) {\n      return new Append(inner, this.right);\n    }\n  };\n\n  Append.prototype.appendInner = function appendInner(other) {\n    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {\n      return new Append(this.left, new Append(this.right, other));\n    }\n\n    return new Append(this, other);\n  };\n\n  return Append;\n}(RopeSequence);\n\nvar ropeSequence = RopeSequence;\nexport default ropeSequence;","map":{"version":3,"sources":["/Users/meeopp/Development/Others/editor-yjs/client/node_modules/rope-sequence/dist/index.es.js"],"names":["GOOD_LEAF_SIZE","RopeSequence","prototype","append","other","length","from","leafAppend","leafPrepend","appendInner","prepend","Append","slice","to","empty","sliceInner","Math","max","min","get","i","undefined","getInner","forEach","f","forEachInner","forEachInvertedInner","map","result","elt","push","values","Leaf","call","__proto__","Object","create","constructor","prototypeAccessors","configurable","depth","flatten","start","concat","defineProperties","left","right","leftLen","inner","ropeSequence"],"mappings":"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","sourcesContent":["var GOOD_LEAF_SIZE = 200;\n\n// :: class<T> A rope sequence is a persistent sequence data structure\n// that supports appending, prepending, and slicing without doing a\n// full copy. It is represented as a mostly-balanced tree.\nvar RopeSequence = function RopeSequence () {};\n\nRopeSequence.prototype.append = function append (other) {\n  if (!other.length) { return this }\n  other = RopeSequence.from(other);\n\n  return (!this.length && other) ||\n    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||\n    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||\n    this.appendInner(other)\n};\n\n// :: (union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Prepend an array or other rope to this one, returning a new rope.\nRopeSequence.prototype.prepend = function prepend (other) {\n  if (!other.length) { return this }\n  return RopeSequence.from(other).append(this)\n};\n\nRopeSequence.prototype.appendInner = function appendInner (other) {\n  return new Append(this, other)\n};\n\n// :: (?number, ?number) → RopeSequence<T>\n// Create a rope repesenting a sub-sequence of this rope.\nRopeSequence.prototype.slice = function slice (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from >= to) { return RopeSequence.empty }\n  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))\n};\n\n// :: (number) → T\n// Retrieve the element at the given position from this rope.\nRopeSequence.prototype.get = function get (i) {\n  if (i < 0 || i >= this.length) { return undefined }\n  return this.getInner(i)\n};\n\n// :: ((element: T, index: number) → ?bool, ?number, ?number)\n// Call the given function for each element between the given\n// indices. This tends to be more efficient than looping over the\n// indices and calling `get`, because it doesn't have to descend the\n// tree for every element.\nRopeSequence.prototype.forEach = function forEach (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from <= to)\n    { this.forEachInner(f, from, to, 0); }\n  else\n    { this.forEachInvertedInner(f, from, to, 0); }\n};\n\n// :: ((element: T, index: number) → U, ?number, ?number) → [U]\n// Map the given functions over the elements of the rope, producing\n// a flat array.\nRopeSequence.prototype.map = function map (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  var result = [];\n  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to);\n  return result\n};\n\n// :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Create a rope representing the given array, or return the rope\n// itself if a rope was given.\nRopeSequence.from = function from (values) {\n  if (values instanceof RopeSequence) { return values }\n  return values && values.length ? new Leaf(values) : RopeSequence.empty\n};\n\nvar Leaf = /*@__PURE__*/(function (RopeSequence) {\n  function Leaf(values) {\n    RopeSequence.call(this);\n    this.values = values;\n  }\n\n  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;\n  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Leaf.prototype.constructor = Leaf;\n\n  var prototypeAccessors = { length: { configurable: true },depth: { configurable: true } };\n\n  Leaf.prototype.flatten = function flatten () {\n    return this.values\n  };\n\n  Leaf.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    return new Leaf(this.values.slice(from, to))\n  };\n\n  Leaf.prototype.getInner = function getInner (i) {\n    return this.values[i]\n  };\n\n  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    for (var i = from; i < to; i++)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    for (var i = from - 1; i >= to; i--)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.leafAppend = function leafAppend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(this.values.concat(other.flatten())) }\n  };\n\n  Leaf.prototype.leafPrepend = function leafPrepend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(other.flatten().concat(this.values)) }\n  };\n\n  prototypeAccessors.length.get = function () { return this.values.length };\n\n  prototypeAccessors.depth.get = function () { return 0 };\n\n  Object.defineProperties( Leaf.prototype, prototypeAccessors );\n\n  return Leaf;\n}(RopeSequence));\n\n// :: RopeSequence\n// The empty rope sequence.\nRopeSequence.empty = new Leaf([]);\n\nvar Append = /*@__PURE__*/(function (RopeSequence) {\n  function Append(left, right) {\n    RopeSequence.call(this);\n    this.left = left;\n    this.right = right;\n    this.length = left.length + right.length;\n    this.depth = Math.max(left.depth, right.depth) + 1;\n  }\n\n  if ( RopeSequence ) Append.__proto__ = RopeSequence;\n  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Append.prototype.constructor = Append;\n\n  Append.prototype.flatten = function flatten () {\n    return this.left.flatten().concat(this.right.flatten())\n  };\n\n  Append.prototype.getInner = function getInner (i) {\n    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)\n  };\n\n  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from < leftLen &&\n        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)\n      { return false }\n    if (to > leftLen &&\n        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)\n      { return false }\n  };\n\n  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from > leftLen &&\n        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)\n      { return false }\n    if (to < leftLen &&\n        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)\n      { return false }\n  };\n\n  Append.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    var leftLen = this.left.length;\n    if (to <= leftLen) { return this.left.slice(from, to) }\n    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }\n    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))\n  };\n\n  Append.prototype.leafAppend = function leafAppend (other) {\n    var inner = this.right.leafAppend(other);\n    if (inner) { return new Append(this.left, inner) }\n  };\n\n  Append.prototype.leafPrepend = function leafPrepend (other) {\n    var inner = this.left.leafPrepend(other);\n    if (inner) { return new Append(inner, this.right) }\n  };\n\n  Append.prototype.appendInner = function appendInner (other) {\n    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)\n      { return new Append(this.left, new Append(this.right, other)) }\n    return new Append(this, other)\n  };\n\n  return Append;\n}(RopeSequence));\n\nvar ropeSequence = RopeSequence;\n\nexport default ropeSequence;\n"]},"metadata":{},"sourceType":"module"}